[{"categories":["程序设计"],"content":"摘要：Effective C++(第三版)内容第七、第八章的总结","date":"2022-05-20","objectID":"/2022/05/17_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E5%9B%9B/","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(四)","uri":"/2022/05/17_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E5%9B%9B/"},{"categories":["程序设计"],"content":"前言 这本C++经典著作，本人看的是中文版，侯捷老师翻译的，精读分析并实践推敲后，整理成博客记录下来，非常适合有一定开发经验的朋友们阅读。 Effective-C++总结系列分为四部分，本文为第四部分，涉及原书第7~9章，内容范围Rule41~55。为方便书写，Rule41简写为R41。 Effective-C++系列List 本博客站点系列内容如下： 💡 Effective C++(第3版)精读总结(一) 💡 Effective C++(第3版)精读总结(二) 💡 Effective C++(第3版)精读总结(三) 💡 Effective C++(第3版)精读总结(四) 由于原书在C++11之前写成，有些现代C++特性不会提及，所以会根据本人开发经验新增一些个人感悟👉By the way环节。 CH7 模板与泛型编程 ","date":"2022-05-20","objectID":"/2022/05/17_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E5%9B%9B/:0:0","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(四)","uri":"/2022/05/17_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E5%9B%9B/"},{"categories":["程序设计"],"content":"R41 了解隐式接口和编译期多态 面向对象编程的通常做法： 显式定义接口（参数和返回值类型都是确定的，函数签名 就是确定的） 虚函数实现运行时多态 那么编译期多态呢？在面向对象编程中，我们的答案通常是函数重载。 在Templates 及泛型编程中，更为注重的是隐式接口和编译期多态： 隐式接口： Template的接口属于隐式接口，因为它类型不确定，所以是基于有效表达式来区分。再加上运算符重载等特性，隐式接口的自由度非常大。 编译期多态： Template的多态是通过Template具现化和函数重载决议发生于编译期。 上述描述看起来有点抽象，分析下方Template函数代码： template\u003ctypename T\u003e void doProcessing(T\u0026 w){ if(w.size() \u003e 10 \u0026\u0026 w != someNastyWidget){ ... } } doProcessing属于隐式接口，类型不定，传入不同类型T，就得到不同的函数。 由于 操作符重载operator overloading 的存在，隐式接口对传入的 T 类型的要求比较宽松，列举如下： T类型或其父类型具有 size() 接口，size() 接口返回类型S为整型或者S类型有 bool operator\u003e(int) 接口； T类型有 bool operator != (const T\u0026) 接口；或T类型可以隐式转换为某S类型，S可以与someNastyWidget进行 != 比较，或者干脆someNastyWidget就是T类型； 上述1 、 2 点的描述没有将 operator \u0026\u0026 考虑进来，否则情况会更为复杂，这里不赘述了。 ","date":"2022-05-20","objectID":"/2022/05/17_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E5%9B%9B/:1:0","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(四)","uri":"/2022/05/17_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E5%9B%9B/"},{"categories":["程序设计"],"content":"R42 了解typename的双重意义 typename 和 class 关键字在声明 Template 参数的时候，没有任何区别 如下示例，效果是一致的： template\u003cclass T\u003e class Widget ; //早期C++使用这个声明Template参数 template\u003ctypename T\u003e class Widget; //现在更推荐用这个，暗示参数不一定是个class类型 使用关键字 typename 标识 嵌套从属类型名称nested dependent name 模板内的从属类型，是指在模板函数/模板类中，需要依赖传入的 template 参数间接表示的类型，如果呈嵌套状，就叫嵌套从属名称/类型。 如下示例的 C::const_iterator 就是嵌套从属类型。 template\u003ctypename C\u003e void printContainer2ndVal(const C\u0026 container) { if (container.size() \u003e= 2) { typename C::const_iterator iter(container.begin()); std::cout \u003c\u003c \"this container's second value is: \" \u003c\u003c *++iter \u003c\u003c std::endl; } } 此时，typename 的作用就是告诉编译器 C::const_iterator 是个类型，否则会编译报错。此时可以用 class 关键字替代，但是不建议。 typename 使用范围不只是 template 函数内部，也包括了函数入参 ： template\u003ctypename C\u003e void foo(const C\u0026 container, // 不允许使用 \"typename\" typename C::iterator iter); // 必须使用 \"typename\" ⚠️ 其他特殊情况：不要在 基类列表base class list 或 成员初始化列member initialization list 使用 typename template\u003ctypename T\u003e class Derived: public Base\u003cT\u003e::Nested{ //基类列表不允许使用typename public: explicit Derived(int x):Base\u003cT\u003e::Nested(x){// 成员初值列也不允许typename typedef typename Base\u003cT\u003e::Nested NestedType;//结合typedef定义，常规用法 NestedType temp; ...// 其他操作 } }; ","date":"2022-05-20","objectID":"/2022/05/17_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E5%9B%9B/:2:0","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(四)","uri":"/2022/05/17_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E5%9B%9B/"},{"categories":["程序设计"],"content":"R43 学习处理模板化基类内的名称 模板化基类：指定义 template 模板类时，继承于某基类 Base\u003cT\u003e，这个 Base\u003cT\u003e 类就是模板化基类。 🤔 那么 Base\u003cT\u003e 类有关的函数等名称该如何处理，在子类中直接使用吗？还是有注意事项？这，就是本节要讨论的问题。示例如下： template\u003ctypename Company\u003e class MsgSender{ public: void SendPlain(){ std::cout \u003c\u003c \"send plain\\n\";} void SendEncrypted(){ std::cout \u003c\u003c \"send encrypted\\n\";} }; // 基类 template\u003ctypename Company\u003e class LoggingMsgSender: public MsgSender\u003cCompany\u003e{//子类 public: void SendPlainMsg(){ SendPlain();// ==\u003e 这样直接调用是不行的，想想为什么？ } }; 上述注释中问题的原因：因为当全特化时可随意去除 MsgSender 内的函数，那么编译器无法确定基类是否仍有 SendPlain 这个方法。所以，编译器干脆 拒绝在编译时去模板化基类中主动寻找继承而来的名称。 解决方法有三个： 使用 this-\u003e 调用SendPlain()，即可转化为运行时的问题，推荐这个方法； 使用 using MsgSender::SendPlain; 这样的 using 声明式，我们在 Rule 33: 避免遮掩由继承得来的名称 中用过这种方法，显式地告诉编译器扩大名称搜索范围，尝试去基类找找； 使用显式调用，即 MsgSender::SendPlain(); ，但这样做的坏处是直接断绝了 virtual 函数的灵活性和可能，不太推荐； ","date":"2022-05-20","objectID":"/2022/05/17_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E5%9B%9B/:3:0","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(四)","uri":"/2022/05/17_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E5%9B%9B/"},{"categories":["程序设计"],"content":"R44 将与参数无关的代码抽离templates 通常，在非模板代码中，我们很容易看出重复的代码或者类，一般采用抽取公共部分为单独函数，或者采用类的继承/聚合等面向对象设计方式。 但是， template 有关的代码，有时代码重复是隐晦的。 这一节是为了解决 template 的 代码膨胀code bloat 问题，主要原则为 共性与差异性分析commonality and variability analysis 。 某些不恰当的设计，会导致无畏的代码膨胀。先看下方这个反面教材： template\u003ctypename T, std::size_t n\u003e class SquareMatrix { public: void invert() { std::cout \u003c\u003c \"size is \" \u003c\u003c n \u003c\u003c std::endl; }; }; 应用代码如下： //下面这2句，模板类实例化 1 次。 invert函数有 1 份实现 SquareMatrix\u003cint, 5\u003e mat5; SquareMatrix\u003cint, 5\u003e mat5New; //换成下面这2句，模板类实例化 2 次。invert函数有 2 份实现(问题暴露) SquareMatrix\u003cint, 5\u003e mat5; SquareMatrix\u003cint, 10\u003e mat10; 膨胀原因：在编译器看来，SquareMatrix\u003cint, 5\u003e 和 SquareMatrix\u003cint, 10\u003e 是2个完全不同的 C++ 类，实例化了2次，生成了这2个类。试想，如果代码中还需要其他 size 的SquareMatrix ，都会再生成一个新类，那么最后二进制文件就多了许多重复的目标代码，也就是膨胀。 如果能抽离参数相关代码，做到尺寸无关，便可解决这个问题。 解决思路：新建一个基类 BaseMatrix ，将尺寸参数传入给到基类作为成员变量保管，具体的数据可以用数组指针形式托管。不论有多少个与尺寸有关的派生类，一个 T 类型就只有一个基类，所以基类 baseInvert 函数实现只有一份。 基类实现代码如下： template\u003ctypename T\u003e class BaseSqaureMatrix { public: BaseSqaureMatrix(std::size_t n,T* dataPtr) :n_(n), dataPtr_(dataPtr) {} protected: void baseInvert() { std::cout \u003c\u003c \"invert: pData = \" \u003c\u003c dataPtr_ \u003c\u003c \" , size = \" \u003c\u003c n_ \u003c\u003c std::endl; } void SetDataPtr(T* dataPtr) { dataPtr_ = dataPtr; }; std::size_t n_ = 0; T* dataPtr_ = nullptr; }; 目标派生类实现如下： template\u003ctypename T,std::size_t n\u003e class SquareMatrix : public BaseSqaureMatrix\u003cT\u003e { public: SquareMatrix() :BaseSqaureMatrix\u003cT\u003e(n,nullptr), data_(std::shared_ptr\u003cT\u003e(new T[n*n])) { this-\u003eSetDataPtr(data_.get()); } void invert() { this-\u003ebaseInvert(); }// 参考Rule43 private: std::shared_ptr\u003cT\u003e data_ ;// RAII管理资源 }; 最终效果：相同 T 类型的template实例类(比如SquareMatrix\u003cfloat,5\u003e和SquareMatrix\u003cfloat,6\u003e)，共享实现码，祛除代码膨胀。 ","date":"2022-05-20","objectID":"/2022/05/17_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E5%9B%9B/:4:0","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(四)","uri":"/2022/05/17_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E5%9B%9B/"},{"categories":["程序设计"],"content":"R45 运用模板成员函数接受所有兼容类型 众所周知，Base *pBase = pDerived; 这样普通类型裸指针的隐式转换是被 C++ 所认可的。 那么如果换成智能指针模板类 SmartPtr\u003cBase\u003e 和 SmartPtr \u003cDerived\u003e 呢，还能这样不需额外配置就随意转换吗，答案显然是不行的（纵然 Base 和 Derived 是兼容类型也不行）。 本节，就采用模板成员函数来解决这一问题。 使用模板成员函数，接受所有兼容类型的“泛化构造”/“泛化赋值” 泛化generalizedCopy构造，是指接受其他兼容类型进行模板函数的Copy构造。举例一个粗糙的 RAII 智能指针实现，代码如下：(单击展开)👇 template\u003cclass T\u003e class SmartPtr { public: SmartPtr(T* origPtr) :originPtr_(origPtr) {} SmartPtr(const SmartPtr\u0026 smt) :originPtr_(smt.get()) {}// 正常Copy构造函数 //正常copy操作符函数: 简单演示，就浅复制吧 SmartPtr\u0026 operator=(const SmartPtr\u0026 smt) { originPtr_ = smt.get(); return *this; } template\u003cclass U\u003e //泛化构造函数 SmartPtr(const SmartPtr\u003cU\u003e\u0026 other):originPtr_(other.get()) { } //为了隐式转换不加 explict template\u003cclass U\u003e //泛化赋值操作符 SmartPtr\u0026 operator=(const SmartPtr\u003cU\u003e\u0026 other) { originPtr_ = other.get(); return *this; }//简单演示，浅复制 T* get() const { return originPtr_; } ~SmartPtr() { delete originPtr_;} private: T* originPtr_ = nullptr; }; 有上述的代码支持，我们就能写出如下的应用代码： class BaseObj{}; class DerivedObj:public BaseObj {};//DerivedObj是BaseObj兼容类型 SmartPtr\u003cDerivedObj\u003e smDerived(new DerivedObj()); SmartPtr\u003cBaseObj\u003e smBase(smDerived); SmartPtr\u003cBaseObj\u003e smBase2 = smDerived; 即使有 “泛化构造/ 赋值”，也需要正常的 Copy构造/赋值 注意，模板成员函数不会改变语言规则，也就是说“泛化构造”不能代替正常的 copy 构造函数。所以，需要同时声明正常的 Copy 构造函数和 Copy 赋值操作符函数。 ","date":"2022-05-20","objectID":"/2022/05/17_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E5%9B%9B/:5:0","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(四)","uri":"/2022/05/17_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E5%9B%9B/"},{"categories":["程序设计"],"content":"R46 需要类型转换时请为模板定义非成员函数 有时我们希望 class 支持类型转换，类似本书的另外一节👉 Rule24:若所有参数皆需类型转换，请采用non-member 。 如果 Rule24 中的 Rational 类是 template 模板类，直接仿照 Rule24 利用 non-member 函数做混合运算是行不通的，原因是 template 实参推导是不采纳 “通过构造函数而发生的”隐式类型转换。 解决办法如下: 使用 “template class 内部的friend函数” 完成参数隐式转换 将 Rule24 的 non-member 的 operator *函数改为 inline-friend 函数，因为 template 实例化的时候需要找到该 friend 函数的定义实现，类外定义实现是会链接错误的，所以需要 inline 。 参考代码实现如下： template\u003ctypename T\u003e class RationalNew { public: RationalNew(T numerator = 0, T denominator = 1) :numerator_(numerator), denominator_(denominator) {} T numerator()const { return numerator_; } T denominator()const { return denominator_; } friend const RationalNew\u003cT\u003e operator*(const RationalNew\u003cT\u003e\u0026lhs, const RationalNew\u003cT\u003e\u0026rhs) { return RationalNew\u003cT\u003e(lhs.numerator()*rhs.numerator(),lhs.denominator()*rhs.denominator()); } private: T numerator_ = 0; T denominator_ = 1; }; 那么，对如下的应用代码，就使用自如了： RationalNew\u003cfloat\u003e oneHalf(1.0,2.0); RationalNew\u003cfloat\u003e res = oneHalf * 2; RationalNew\u003cfloat\u003e res2 = 3 * oneHalf; 若inline-friend函数体太大，可以抽离出类外辅助函数供inline调用 上述的 operator* 函数体只有一行，实现简单，但如果实现过程复杂代码量大，考虑 inline 带来的冲击以及代码可读性，可以抽取个函数出来供 inline-friend 调用。 修改方式如下： template\u003ctypename T\u003e class RationalNew { public: // 其他部分略。注意 operator* 函数体实现，改为调用doMultiply friend const RationalNew\u003cT\u003e operator*(const RationalNew\u003cT\u003e\u0026lhs, const RationalNew\u003cT\u003e\u0026rhs) { return doMultiply(lhs,rhs); } }; // 类外函数 doMultiply template\u003ctypename T\u003e const RationalNew\u003cT\u003e doMultiply(const RationalNew\u003cT\u003e\u0026lhs, const RationalNew\u003cT\u003e\u0026rhs) { return RationalNew\u003cT\u003e(lhs.numerator()*rhs.numerator(), lhs.denominator()*rhs.denominator()); } ","date":"2022-05-20","objectID":"/2022/05/17_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E5%9B%9B/:6:0","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(四)","uri":"/2022/05/17_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E5%9B%9B/"},{"categories":["程序设计"],"content":"R47 请使用traits classes表现类型信息 C++ 中通常把 Traits 称为类型萃取技术，即：在 template 编程中，获取模板参数的类型信息，并在编译阶段针对不同的类型响应不同的处理。同时，这个技术要求对C++内置类型built-in 和 用户自定义user-defined 类型的表现必须一样好。 本节讨论此议题，并且以一个 C++ 标准的模板函数作为切入口进行讨论( std::advance，作用是兼容不同类型迭代器，用于后续取用指定偏移量的元素 )。 下方 “By the way” 环节简单展示了 std::advance 标准C++的声明式和基本用法： 👇（单击展开） By the way std::advance 需要的头文件包含为 #include\u003citerator\u003e ，再看下它的函数原型声明： template\u003c class InputIt, class Distance \u003e void advance( InputIt\u0026 it, Distance n ); // C++17 之前 template\u003c class InputIt, class Distance \u003e constexpr void advance( InputIt\u0026 it, Distance n ); // 自C++17 开始 再看下示例应用代码： std::vector\u003cint\u003e nums{1,2,3,4,5}; auto vIter = nums.begin(); std::advance(vIter, 3); std::cout \u003c\u003c \"after advance 3 offset: *vIter = \" \u003c\u003c *vIter \u003c\u003c std::endl; std::deque\u003cfloat\u003e fNums{0.1,0.2,0.3,0.4,0.5,0.6}; auto dIter = fNums.end(); std::advance(dIter,-2); std::cout \u003c\u003c \"after advance -2 offset: *dIter = \" \u003c\u003c *dIter \u003c\u003c std::endl; std::list\u003cchar\u003e chList{10,20,30,40}; auto cIter = chList.begin(); std::advance(cIter,2); std::cout \u003c\u003c \"after advance 2 offset: *cIter = \" \u003c\u003c int(*cIter) \u003c\u003c std::endl; 最终输出信息如下： after advance 3 offset: *vIter = 4 after advance -2 offset: *dIter = 0.5 after advance 2 offset: *cIter = 30 背景知识 👉 STL 迭代器按照功能分为 5 类，如下方表格所述： 描述 特点 应用 input 迭代器 只向前移动，一次一步，只读 istream_iterators output迭代器 只向前移动，一次一步，只写 ostream_iterators forward迭代器 只向前移动，一次一步，可读写 single-list iterator Bidirectional迭代器 双向移动，一次一步，可读写 set/multiset/map/multimap random-access迭代器 双向移动，一次多步，可读写 vetor/deque/string 如何设计一个 trait_class 并运用起来呢？ Step1： 确认若干个希望获取的类型信息 (本例只有一个 iterator 类别信息) 针对5 种迭代器分类，C++ 提供了专属的 卷标结构tag struct 加以区分(可以理解为编译期的枚举作用)，继承关系如下： struct input_iterator_tag{}; struct output_iterato_tag{}; struct forward_iterator_tag:public input_iterator_tag {}; struct bidirectional_iterator_tag: public forward_iterator_tag{}; struct random_access_iterator_tag: public bidirectional_iterator_tag{}; Step2：为该信息选一个名称 (例如 iterator_category) 那么 vector，set之类的目标容器类，如何与上述 iterator_tag 联系起来呢，需要一个名称传递出去： template\u003c ... \u003e //省略template 参数 class vector { public: class iterator{ public: // ps: C++11 之后使用的都是 using 定义式 typedef random_access_iterator_tag iterator_category; }; }; Step3：提供一个 template 类和一组特化版本（特化版本支持某些特殊情况） Traits 技术针对于迭代器的关键模板类 iterator_traits 定义如下： template\u003ctypename IterT\u003e // ⚠️ 注意：使用的是 struct struct iterator_traits { //这里的 IterT 就可以传入vector等容器类 typedef typename IterT::iterator_category iterator_category; } 注意，这里的 IterT 类型不能是指针类型，因为 pointer 不能后续嵌套。那么就需要一个特化版本了，代码如下： template\u003ctypename IterT\u003e struct iterator_traits\u003cIterT*\u003e{ // 指针类型和 random 迭代器类似 typedef random_access_iterator_tag iterator_category; } 至此，iterator_traits 的基本实现就完成了，也就是说 iterator_traits\u003cIterT\u003e::iterator_category 可以在编译期确定，接下来看看advance 函数如何使用它。 💗 正确做法：利用 函数重载overloading 技术，使得 trait classes 在编译期对类型执行 if … else 测试。 回顾我们的 advance 函数，只有迭代器类型 IterT 和 偏移量 DistT 。可以重载其子函数 doAdvance ，完成类型萃取后的自适应： template\u003ctypename IterT, typename DistT\u003e void doAdvance(IterT\u0026 iter, DistT d, std::random_access_iterator_tag) { iter += d; } template\u003ctypename IterT, typename DistT\u003e void doAdvance(IterT\u0026 iter, DistT d, std::bidirectional_iterator_tag) { if (d \u003e= 0) { while (d--) ++iter; } else { while (d++) --iter; } } template\u003ctypename IterT, typename DistT\u003e void doAdvance(IterT\u0026 iter, DistT d, std::input_iterator_tag) { if (d \u003c 0) {throw std::out_of_range(\"Negative distance\");}//ps: msvc中的C++实现是采用编译期间的asset判定 while (d--) ++iter; } 自然地，advance 函数的实现如下所示： template\u003ctypename IterT, typename DistT\u003e void advance(IterT\u0026 iter, DistT d){ doAdvance(iter,d, /*不论 category 的tag类型是什么，重载能找到匹配函数。即编译期的 if...else 测试*/ typename std::iterator_traits\u003cIterT\u003e::iterator_category()); } 至此，一个完整的 (以 iterator_traits 为例)Traits 技术实现与运用的过程就完成了。 By the way 关于 iterator_traits ，不止有 iterator_category，还有 difference_type, value_type, pointer, reference 等4个成员，详细可参考 cpp参考手册：iterator_traits 。 C++ 标准库中类似 iterator_traits 应用了 Traits 技术的模板有十几个。 举例常用的数值类型萃取 numeric_limits ，需要注意2个细节： 头文件是 #include\u003climits\u003e; 成员函数 lowest/min/max 按照顺序，分别代表给定类型的 最低有限值、最小非负值、最大有限值。尤其是 float/double，取最小值是 lowest() ，不是 min(). ","date":"2022-05-20","objectID":"/2022/05/17_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E5%9B%9B/:7:0","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(四)","uri":"/2022/05/17_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E5%9B%9B/"},{"categories":["程序设计"],"content":"R48 认识Template模板元编程 TMP，模板元编程template metaprogramming ，是编写 template-based C++ 程序并执行于编译期的过程。TMP 过程结束后，若干 C++ 源码会被 templates 具现化出来，便会一如往常地被编译。 TMP 有 2 个强大的作用： 可以完成非 TMP 的常规编程做不到的事情 比如代码生成，类型适配等。 可以将某些工作从运行期转移到编译期 可以将运行期的错误提前暴露在编译期，可以获得更小的可执行文件，更快地运行，更少地内存需求，缺点是明显增加编译时间。 TMP 已被证明是个“图灵完备”的机器，意思是它强大到可以计算任何事物。使用 TMP 可以声明变量、执行循环、编写及调用函数…等等。 比较特别的是，TMP 实现上述各类功能的方式不同于常规 C++ 程序。比如上一节 Rule47 中使用重载完成了编译期的 if…else 条件分支。TMP 循环功能也通常会使用 “递归具现化” 来完成的。 下方代码示范如何使用 TMP 的方式来计算阶乘： template\u003cunsigned n\u003e struct Factorial { // 递归的形式体现: f(n) = n * f(n -1) enum {value = n* Factorial\u003cn-1\u003e::value}; }; template\u003c\u003e struct Factorial\u003c0\u003e { // 模板全特化: 实际是初始化 f(0) = 1 enum {value = 1}; }; 那么阶乘计算在编译期就完成了，运行时就是直接取用了： std::cout \u003c\u003c \"Factorial(\" \u003c\u003c 5 \u003c\u003c \") = \" \u003c\u003c Factorial\u003c5\u003e::value \u003c\u003c std::endl; std::cout \u003c\u003c \"Factorial(\" \u003c\u003c 7 \u003c\u003c \") = \" \u003c\u003c Factorial\u003c7\u003e::value \u003c\u003c std::endl; CH8 定制new和delete 由于 C++ 不像 Java 或 .Net 那样有语言层面的 GC (垃圾回收)，需要自己管理内存。本章主题就是讨论 operator new 和 operator delete ，当它们无法满足客户的内存需求时，还需要 new-handler。 另外，堆内存的申请与释放要考虑线程安全，即如何避开线程竞态是值得考虑的。 众所周知，operator new 和 operator delete 结对使用，operator new[] 和 operator delete[] 结对使用。这 2 对除了特性，也有大量共性，除非特别说明，本章所论述的关于 new/delete 的内容，也同样适用于 new[]/delete[] 。 ","date":"2022-05-20","objectID":"/2022/05/17_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E5%9B%9B/:8:0","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(四)","uri":"/2022/05/17_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E5%9B%9B/"},{"categories":["程序设计"],"content":"R49 了解new-handler的行为 当 operator new 无法满足某个内存分配需求时，一般会抛出 std::bad_alloc 异常。 如果用 std::nothrow 修饰 new 操作符，使得内存分配阶段不会抛异常，失败了就返回 null 指针。举例 : int *pArr = new (std::nothrow) int[0x1fffffff]; //即使分配失败，也不抛异常，而是得到null指针. // ⚠️ nothroow-new 不能保证 class 后续的构造函数不抛异常 如果需要抛异常，在抛异常前，实际上会执行一个事先指定的函数指针 new_handler (如果指定了的话)。 指定这个函数指针的方法声明如下： namespace std { typedef void (*new_handler)(); //下方throw()表示不抛异常。现在都使用 noexcept 代替 new_handler set_new_handler(new_handler p) throw(); } // ⚠️ ：set 进新的handler，返回原来旧的handler作为返回值 new-hanlder 的使用示例如下： //先定义一个函数 void OutOfMemTip() { std::cerr \u003c\u003c \"new memory fail,out of memory!\\n\"; std::abort();//终止程序，若调试模式会弹窗提示 } // 故意制造new失败的情形，程序会调用 OutOfMemTip，触发std::abort() std::set_new_handler(OutOfMemTip); int *pArr = new int[0x1fffffff];//约2GB,如果扛的住，调大这个数 可以看出这样的函数指针给了使用者非常大的设计弹性，可以做到以下事情： 提前申请内存，让 new_handler 触发下一次分配使用； 安装另一个 new_handler ，或许新的 handler 可以申请到内存； 卸载 new_handler ，只要传 null 指针即可； 手动抛 std::bad_alloc 的异常； 不返回，通常调用 std::abort() 或 std::exit() ; 🤔 我们思考另外一个问题：是否可以 让不同的 C++ 类拥有自己的 new-handler 呢？ C++ 标准机制是不支持的，我们可以自己实现。有两个实现途径，列举如下： 针对某个特定类 ，类内重载 static 类型的 operator new 以及 set_new_handler方法 具体实现略，只想指出这样做法有个明显弊端，就是每个类都得这么做，比较麻烦，也容易代码冗余。 使用 CRTP 方法（即 怪异的循环模板模式curiously recurring template pattern ）将上述方法 1 塞进 template 类 这样做的好处是使用模板类赋予上述 operator new 和 set_new_hanler 的操作，使用起来方便。 CRTP 方法中的基类 NewHandlerSupport 实现如下 👇(点击打开折叠) ： template\u003ctypename T\u003e class NewHandlerSupport { public: static std::new_handler set_new_handler(std::new_handler p)noexcept { std::new_handler oldHandler = currentHandler_; currentHandler_ = p; return oldHandler; } static void* operator new(std::size_t size) throw(std::bad_alloc) { std::new_handler oldHandle = std::set_new_handler(currentHandler_); void *res = ::operator new(size); //new完后复原global-new-handler std::set_new_handler(oldHandle);//原书使用RAII手法在还原这个handler，这里作用类似 return res; } private: static std::new_handler currentHandler_;//初始化动作放到类外cpp文件里去 }; 那么目标类 TestNewHandler 只要基于 CRTP 方法继承于基类就可以了，实现如下： class TestNewHandler : public NewHandlerSupport\u003cTestNewHandler\u003e { //不必声明 set_new_handler 或 operator new }; //最终应用时也非常简单 TestNewHandler::set_new_handler(OutOfMemTip); TestNewHandler* pTestHandle = new TestNewHandler(); ","date":"2022-05-20","objectID":"/2022/05/17_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E5%9B%9B/:9:0","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(四)","uri":"/2022/05/17_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E5%9B%9B/"},{"categories":["程序设计"],"content":"R50 了解new和delete的合理替换时机 替换编译器提供的 operator new 和 operator delete 的 常见理由 如下： 检测运用上的错误 自定义的new/delete可以很方便地校验实际控制的区段内存，比如可以在目标区块前后额外空间添加内存签名(比如写入特定 int 值)，监测越界的问题。 越界分2种：underruns (区块内存起点之前) 和 overruns (区块内存末尾之后)。 时间或内存使用的优化 通用的 new/delete 需要适用各种分配形态和场景，对于内存碎片或时间性能都是中庸水平。 对特定的需求和场景，定制化地内存管理会有很好的优化效果。 收集内存使用的统计数据 对内存分配细节的把控，例如分配区块的大小分布、存续周期、FIFO/LIFO次序分配回收、内存峰值等情况。 弥补默认内存分配器的 非最佳对齐位suboptimal alignment 例如x86体系结构CPU上访问double都是8bytes对齐，如果能在内存分配时就做好内存对齐，可提升访问效率。 将相关对象成簇集中 比如已知某个数据结构往往一起使用，那么分配的时候应该尽量让所有数据的内存集中一些，避免频繁触发 换页中断page faults ，提升访问效率。 其他的非传统行为 想完成一些系统编译器办不到的事情。比如希望分配释放共享内存的区块，但是只有 C-API 能做到，那就需要定制版的 new/delete 去包裹封装这样的API。 ","date":"2022-05-20","objectID":"/2022/05/17_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E5%9B%9B/:10:0","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(四)","uri":"/2022/05/17_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E5%9B%9B/"},{"categories":["程序设计"],"content":"R51 编写new和delete时需固守常规 上一个条款讲了重写 new/delete 的原因，这一节将讲述具体需要遵守的几个规则。 正确处理 new 失败的情况 如果分配正常，直接返回区块对应的指针即可。可如果失败，就必须得正确调用 new-handler 函数，参考 R49 了解new-handler的行为。 如果要求分配 0 byte 空间 C++规定，如果客户要求分配 0 byte 内存申请，就返回 1byte 空间申请，并返回该有效地址。 理解 operator new 内部的无穷循环 operator new 有个 while(true) 循环，分配成功可以return，或由 new-handler 为 nullptr 时抛出 std::bad_alloc 异常。伪代码pseudocode 如下： void* operator new(std::size_t size) throw(std::bad_alloc){ using namespace std; if (size == 0){ size = 1; } while (true){ 尝试分配 size bytes; if (分配成功) return target_pointer; new_handler globalHandler = set_new_handler(0); set_new_handler(globalHandler);//分配失败了 if(globalHandler) (*globalHanler)(); else throw std::bad_alloc(); } } 当基类的 operator new 被子类继承时 当基类被继承时，成员 operator new 也一起被继承了，要注意的是基类和子类的 size 通常是不一样的。推荐实现如下： class Base{ public: static void* operator new(std::size_t size)throw (std::bad_alloc){ if (size != sizeof(Base)) return ::operator new(size);//子类走这里 } }; 值得注意的是，operator new[] 不能这样在基类中区分。因为即使在Base类，也无法假定每个元素是 sizeof(Base)，通常还有额外内存空间来保存元素个数。 operator delete 的注意事项 C++ 需要保证 “删除NULL指针永远安全”，所以必须兑现这个规则。针对null指针，就什么也不做，直接return。 ","date":"2022-05-20","objectID":"/2022/05/17_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E5%9B%9B/:11:0","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(四)","uri":"/2022/05/17_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E5%9B%9B/"},{"categories":["程序设计"],"content":"R52 写了placement-new 也要写placement-delete placement-new，是指“除size参数以外，接受一个额外参数参与构造”的 特定 operator-new。 其中，“接受一个指针指向对象该被构造之处”是最常使用的 placement-new，即“一个特定位置上的new”，形式如下为： //这个特殊的也是最常涉及的 placement-new 已被纳入C++标准程序库 void * operator new(std::size_t size,void* pMemory) noexcept; 先暂时考虑一个调用了placement-new的正常构造过程： // 有这样一个placement-new,接收一个ostream来log分配时的相关信息 void* operator new(std::size_t size,std::ostream\u0026 logStream) throw (std::bad_alloc); Widget* pw = new (std::cerr) Widget;//传入ostream 对于任何的new对象构造过程，至少可分为下述2个过程： operator new 分配对象需要的内存空间； 执行对应的构造函数 如果上述过程 1 成功了，过程 2 抛异常，已经申请的内存就需要及时回收避免memory-leak，运行期系统就会尝试寻找并调用“额外参数个数和类型都与operator new 一致的operator delete”，完成内存回收。 那么上述事实，就是 placement-new 和 placement-delete 需要成对实现的理由。 针对上例额外参数是 std::ostream 的operator new，operator delete，类声明形式如下: class Widget{ public: static void* operator new(std::size_t size,std::ostream\u0026 logStream) throw (std::bad_alloc); //不抛异常时，最后对象析构时正常调用这个 static void operator delete(void *pMemory) noexcept; //new抛异常时，调用这个 额外参数个数和类型都一致的 placement-delete static void operator delete(void *pMemory,std::ostream\u0026 logStream); }; ⚠️ One More Thing : C++ 在global 作用域提供以下形式的 operator new: void * operator new(std::size_t size) throw (std::bad_alloc); void * operator new(std::size_t size,void*) noexcept; void * operator new(std::size_t size,const std::nothrow_t \u0026) noexcept;//见条款49 new-Handler的行为 😎 所以，如果在class 内声明了上述 operator new， 则global作用域的 operator new 会被名称遮掩。 🤔 解决办法：在基类对global作用域的 ::operator new 进行封装调用，然后在子类中使用using 声明式破除名称遮掩。 CH9 杂项讨论 ","date":"2022-05-20","objectID":"/2022/05/17_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E5%9B%9B/:12:0","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(四)","uri":"/2022/05/17_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E5%9B%9B/"},{"categories":["程序设计"],"content":"R53 不要轻易忽略编译器的警告 严肃对待编译器发出的警告信息 编译器发出的警告信息，经常会被忽略。No-Warning是值得追崇的，除非你对编译 warning 信息是充分了解并确信是无关紧要的。 下面举一个较为常见的例子： class BaseWarn { public: virtual std::string GetWarnInfo() const { return \"Base\"; } }; class DerivedWarn :public BaseWarn { public: virtual std::string GetWarnInfo() {//缺了const return \"Derived\"; } }; 如上代码所示，没有成功实现虚函数重写，而是造成了“名称遮掩”。 这样的错误较为隐蔽，有些编译器会给出警告信息，有些甚至连警告信息都没有（Ps：我自行测试了VS2017，没有warning信息）。 如果编译器给出了警告信息，请认真对待。 不要过度依赖编译器的报警能力 还是上面的例子，不同编译器处理态度不同，警告信息甚至可能换个编译器就消失了。 ","date":"2022-05-20","objectID":"/2022/05/17_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E5%9B%9B/:13:0","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(四)","uri":"/2022/05/17_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E5%9B%9B/"},{"categories":["程序设计"],"content":"R54 熟悉包括TR1在内的标准程序库 C++ Technical Report 1 (TR1) 并非标准，而是一份草稿文件，对C++标准库的第一次扩展，它提出了对C++标准函式库的追加项目。 这份文件的目标在于「为扩充的C++标准函式库建立更为广泛的现实作品」。 我的理解：200x 年发布的 C++ 称为 “C++0x”，持续修改中，所有修改将合并于 TR1，最终绝大部分都定版、收录发布于 C++11。 TR1详细叙述了许多新特性，都放在 std::tr1 命名空间内（以下简称 tr1:: ），列举如下： 智能指针：tr1::shared_ptr 和 tr1::weak_ptr ，RAII 基础，不赘述； tr1::function：表示 可调用物callable entity，即任何函数或函数对象，只要签名一致即可； tr1::bind：对函数调用的封装，将函数和其参数绑定一起； Hash tables：采哈希表形式参与构成，名称以 unordered_ 开头的 set/multiset/map/multimap； 正则表达式：头文件在 \u003cregrex\u003e ； Tuple 元组(或叫变量组)：不定长变量组，是 std::pair 的一种泛化； tr1::array: 和 C 语言数组一样，是个定长数组，包裹了 STL 用法； tr1::mem_fn: 传入一个函数指针（支持对成员函数取址）作为入参，构造一个函数对象，进而调用，类似地还有 mem_fn_ref; tr1::reference_wrapper：“封装引用为一个对象”，通常用于对引用进行封装然后装入标准容器(直接往容器塞引用是不行的)； 随机数生成工具：random_device，可以直接生成或者使用不同的 随机数引擎 和 随机分布算法进行生成，头文件是 \u003crandom\u003e； 数学特殊函数：包括Laguerre多项式、Bessel 函数、完全椭圆积分等特殊数学函数，注意，这些 在 C++17 才引入C++标准，可参考cppreference: special math ，头文件在 \u003ccmath\u003e； C99兼容扩充 ：C99标准是C语言的官方标准第二版，1999年发布，TR1对其进行了兼容； Type traits 类型萃取：template编程的精华之一，参考 Rule47:使用trait表现类型信息，头文件为 \u003ctype_traits\u003e，功能十分丰富，可参考cppreference: type_traits； tr1::result_of ：可以对函数返回值做推断，得到返回值类型，头文件为 \u003ctype_traits\u003e ，示例用法如下： // 假设有个函数 double calcDaySale(int); std::tr1::result_of\u003ccalcDaySale(int)\u003e::type x = 3.14;//x就是double类型. C++11中直接 std::result_of 更详细的定版TR1信息可以参考Effective-C++：TR1 information。 ","date":"2022-05-20","objectID":"/2022/05/17_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E5%9B%9B/:14:0","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(四)","uri":"/2022/05/17_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E5%9B%9B/"},{"categories":["程序设计"],"content":"R55 让自己熟悉Boost Boost是一个C++开发者集结的社群，也是个可自由下载的程序库集，网址是 http://boost.org。 其特殊性：和C++标准委员会有着独一无二的密切关系，且具有很深影响力；接纳程序库非常严谨，需要一次以上的同行专家评审。 Boost 程序库集可处理的场景有许多（且囊括了TR1的实现），可区分出数十个类别，并且还在持续增加，列举一小部分如下： 字符串与文本处理 容器 函数对象与高级编程 泛型编程：覆盖一大组 traits classes 模板元编程：覆盖一个针对编译器 assertions 而写的程序库，以及 Boost MPL程序库 数学和数值:包括有理数、八元数、四元数、公约数、多重运算、随机数等等 正确性与测试性 数据结构 语言间的支持：允许 C++ 和 Python 之间的无缝互联 内存：覆盖Pool程序库和智能指针等 杂项：包括 CRC 校验、日期和时间的处理、文件系统等内容 总的来说，Boost 是一个社群，也是个网站。致力于免费、源码开放、同行复审的 C++ 程序库开发，非常值得经常访问与学习。 ————————————————————- @ 完结-2022-7-6 @ ————————————————————- ","date":"2022-05-20","objectID":"/2022/05/17_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E5%9B%9B/:15:0","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(四)","uri":"/2022/05/17_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E5%9B%9B/"},{"categories":["折腾"],"content":"摘要：LoveIt主题从Github模板到个性化所需要做的重要配置","date":"2022-05-01","objectID":"/2022/05/15_hugo%E6%A1%86%E6%9E%B6%E5%8D%9A%E5%AE%A2loveit%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/","tags":["Hugo","LoveIt"],"title":"Hugo框架LoveIt博客主题配置过程记录","uri":"/2022/05/15_hugo%E6%A1%86%E6%9E%B6%E5%8D%9A%E5%AE%A2loveit%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/"},{"categories":["折腾"],"content":"前言 本篇博客记录的配置过程可能不够全面，但主要是本人认为比较重要的部分，或容易引起疑惑之处，单独拿出来记录，希望可以帮到遇到相同问题的其他人。 Hugo主题的配置，本质就是在配置根目录的 config.toml文件。 配置LoveIt主题前，可以先将其LoveIt/exampleSite/config.toml对照着LoveIt主题配置文档大致看看各个模块的作用与意义，然后拷贝到自己的根目录并自定义修改。 默认md内容模版 hugo使用上手后，知道新建一篇博客可以在hugo博客的根目录，命令行执行hugo new posts/new_blog.md，就会在 content/posts 目录下新建一个名为 ‘my_new_blog.md’ 的 markdown 文件，新文件的默认具体内容我们是可以提前自动配置的。 只需要编辑archetypes/default.md即可，举例，我的default.md内容如下所示： --- title: \"{{ replace .Name \"-\" \" \" | title }}\" subtitle: \"\" description: \"摘要：\" featuredImage: \"/img/\" tags: [\"\",\"\"] categories: [\"\"] # 当前可选分类:计算机图形学,脚本,程序设计,折腾 date: {{ .Date }} draft: true --- \u003c!--more--\u003e 表示每篇新建的md文档，都会预先在文章起始位置填写上述内容：其中，title和date是自动获取的，#号表示注释内容。 是否发布markdown原文 文章的原始文本格式为markdown，在发布时会自动编译出html网页文档，在根目录配置文件config.toml中可以配置是否一起输出markdown，如下注释的设置。 如果选择一并输出markdown文档，则在博客的末尾左下角，能让读者看到markdown原文。例如LoveIt主题的官方文档配置篇，左下角有个“阅读原始文档”。 # 用于 Hugo 输出文档的设置 [outputs] # home = [\"HTML\", \"RSS\", \"JSON\"] page = [\"HTML\"] # 如果都想输出，则设置为[\"HTML\", \"MarkDown\"]，页面底部有\"查看网页原文\" section = [\"HTML\", \"RSS\"] taxonomy = [\"HTML\", \"RSS\"] taxonomyTerm = [\"HTML\"] 我个人是倾向不输出，所以删去了“MarkDown”字段。 文章摘要 文章摘要是用简短的一句话，对标题进行补充解释，让读者在看文章之前就对文章有个大体的印象。 详细设置部分，可参考官方文档-摘要部分 。 我选择的手动摘要，做以下步骤： 在archetypes/default.md文本内新增description字段，以描述为摘要； 新增摘要分隔符＂＂；（可参考本文default内容模板章节） 比如本篇文章的摘要设置如下： description: \"摘要：LoveIt主题从Github模板到个性化所需要做的重要配置\" 这样每篇新建的文章只要填写description字段内容即可，注意，使用纯文本，不要加入代码块、字体加粗格式等富文本，容易引起渲染错误。 文章封面图 LoveIt主题让使用者选择是否设置文章预览图，如果想设置，在markdown文档的最开头的配置部分，填写featuredImage字段，引用的图片可以是网络URL地址的图片，也可以是本博客本地图片。 我选择的是本地图片的static方式加载(还有asset方式)，资源相对路径的起始位置是根目录下的static目录，比如本文的图片目录是static/img/Chore-Pic/LoveIt-Theme.webp，那么这个字段应该填写： featuredImage: \"/img/Chore-Pic/LoveIt-Theme.webp\" 🤔图片的分辨率建议是1000x300或者长宽比相近的分辨率，可以避免预览被裁剪。 图片格式尽量选择webp格式(或使用ffmpeg等工具将其他图片格式转换为webp)。 webp格式的图是新一代的压缩格式，保证最大原图清晰度的情况下，尽可能地缩小了图片内存占用，加快加载速度。 Algolia站内搜索 Algolia是法国的初创公司，类似于存储云服务，计算云服务，提供的是搜索云服务，用户建立应用，接着通过sdk推送数据，然后通过sdk就可以搜索了。个人用户是免费使用，还有个最大的优点是速度快，比LoveIt主题支持的默认站内搜索工具lunar.js快了一个数量级。 按照以下步骤实施即可： 在Algolia官网注册账号后登录，或使用 GitHub、Google 帐号登录； 点击左侧边栏的OverView/dashboard，可以看到自动创建了一个App，可以重新命名，我们新建一个Index，比如命名为My_Blog，点击进去，准备上传index.json作为搜索元数据。 Algolia 为我们提供了三种方式来增加记录：手动添加、上传 json 文件、API自动添加。下面演示自动添加的方式： 生成index.json并上传： 每次更新博客内容并发布时，需要更新index.json，可以做到自动化脚本化，借助第三方工具Atomic-Algolia即可。安装方法： 安装node.js后，可以执行npm指令； 执行 npm install atomic-algolia，可以安装 atomic-algolia； 在hugo根目录修改或新建文件 package.json ，添加如下内容： { \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" \u0026\u0026 exit 1\", \"algolia\": \"atomic-algolia\" } } 根目录下新建.env文件,添加如下内容： ALGOLIA_APP_ID=你的Application ID ALGOLIA_INDEX_NAME=你的algolia-index名字 ALGOLIA_INDEX_FILE=public/index.json ALGOLIA_ADMIN_KEY=你的Admin API Key 上述的关键信息 Application ID 和 Admin API Key可以在algolia的DashBoard页面获取，“API Keys”按钮，点进去后，就能看到，前者是大概10位长度的大写英文与数字，后者大概30位的小写英文与数字。 Index的名字是自己重命名的，index-file的路径指的是你的发布路径和Hugo根目录的相对位置，上述示例是public为发布目录。 ⚠️ ALGOLIA_ADMIN_KEY可以用来管理你的索引，所以最好不要提交到公共仓库。 我的做法是Hugo博客内容为Private仓库，发布的仓库kissingfire123.github.io为public，添加为Private仓库的submodule，一来隔离了隐私数据，二来避免每次更新草稿内容都触发page-deploy。 配置config.toml 找到 [params.search]模块，至少配置以下几个值(以下略去其他内容)： [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"algolia\" [params.search.algolia] index = \"Benjamin-Blog\" # index-name,这个的确是我的，个人自行命名 appID = \"B45S568G91\" # app-id，内容我随意写的 searchKey = \"c00000d11111e22222f444e2333\"#admin-key，内容此处为演示，随意写的 更新索引并自动上传：npm run algolia 输出类似如下内容，“Benjamin-Blog\"是我的index-name。 $ npm run algolia \u003e algolia \u003e atomic-algolia [Algolia] Adding 0 hits to Benjamin-Blog [Algolia] Updating 0 hits to Benjamin-Blog [Algolia] Removing 0 hits from Benjamin-Blog [Algolia] 219 hits unchanged in Benjamin-Blog {} 至此，algolia功能启用成功，使用示范如下： 评论系统Valine LoveIt主题支持多种评论系统，例如Disqus，GitTalk，valine，前2者都需要用户登录后评论且数据托管更方便，valine不需要登录且无后端。 关于valine更详细的介绍，有兴趣的朋友可以看看valine中文文档。 下面只说如何在LoveIt主题上用起来这个评论系统： valine基于LeanCloud登录，注册并登录； 选择国际版，不要选择华北或华东，后面这2个要上传身份证备案的，比较麻烦。(Ps：第一次我就不清楚情况，弄的华北版，各种麻烦，实名认证) 新建应用，比如我的是 Benjamin-Personal-Blog ,然后获取2个关键信息：AppID 和 AppKey。 这2个关键信息在侧边栏设置==\u003e 应用凭证。 设定博客域名：位置在 设置 ==\u003e 安全中心 ==\u003e Web 安全域名 ，将博客域名记录在内，","date":"2022-05-01","objectID":"/2022/05/15_hugo%E6%A1%86%E6%9E%B6%E5%8D%9A%E5%AE%A2loveit%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/:0:0","tags":["Hugo","LoveIt"],"title":"Hugo框架LoveIt博客主题配置过程记录","uri":"/2022/05/15_hugo%E6%A1%86%E6%9E%B6%E5%8D%9A%E5%AE%A2loveit%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/"},{"categories":["折腾"],"content":"Baidu收录 Step1 ：访问 Baidu搜索资源平台，先认证网站是你的 进行基本的注册登录后，在网页的提示下，下载认证文件 baidu_verify_code-jXXaXiYJCY.html ,并且放到网站发布的根目录下，并且部署，再点击认证，即可完成认证； Ps: 上述jXXaXiYJCY是我随意写的，每个站点的verification都不一样。 Step2：让百度知道你站内的所有链接，方便官方收录和爬取 进入用户中心 $\\rightarrow$ 站点管理 $\\rightarrow$ 普通收录，进行资源网址的提交，提交的方式有3种： API提交 ：最及时迅速地被官方收录，自行在终端执行命令，注意需要自行准备 urls.txt ，这个可以用脚本处理 sitemap.xml 得到，建议调用成功后可以写进自己的部署脚本； sitemap提交 ：每次hugo编译成功后，都会在发布文件夹的根目录更新文件 sitemap.xml ，提交该文件即可。( 比如我的填入 https://kissingfire123.github.io/sitemap.xml ) 手动提交：非常直白，就是一个个的复制粘贴到文本框，一行一个，然后提交 关注其他信息：比如网站信息、抓取诊断等。 ","date":"2022-05-01","objectID":"/2022/05/15_hugo%E6%A1%86%E6%9E%B6%E5%8D%9A%E5%AE%A2loveit%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/:1:0","tags":["Hugo","LoveIt"],"title":"Hugo框架LoveIt博客主题配置过程记录","uri":"/2022/05/15_hugo%E6%A1%86%E6%9E%B6%E5%8D%9A%E5%AE%A2loveit%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/"},{"categories":["折腾"],"content":"Bing收录 访问：Bing搜索管理员工具 ，操作类似 Baidu 收录。 ","date":"2022-05-01","objectID":"/2022/05/15_hugo%E6%A1%86%E6%9E%B6%E5%8D%9A%E5%AE%A2loveit%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/:2:0","tags":["Hugo","LoveIt"],"title":"Hugo框架LoveIt博客主题配置过程记录","uri":"/2022/05/15_hugo%E6%A1%86%E6%9E%B6%E5%8D%9A%E5%AE%A2loveit%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/"},{"categories":["折腾"],"content":"Google收录 访问：Google搜索控制台 ，操作类似 Baidu 收录。 参考链接 LoveIt主题文档 - 基本概念 LoveIt主题文档 - 内容配置 掘金：Hugo 集成 Algolia 搜索 知乎：LeanCloud-Valine保姆级配置教程 Lewis个人博客 ：LoveIt主题美化第二章 ","date":"2022-05-01","objectID":"/2022/05/15_hugo%E6%A1%86%E6%9E%B6%E5%8D%9A%E5%AE%A2loveit%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/:3:0","tags":["Hugo","LoveIt"],"title":"Hugo框架LoveIt博客主题配置过程记录","uri":"/2022/05/15_hugo%E6%A1%86%E6%9E%B6%E5%8D%9A%E5%AE%A2loveit%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/"},{"categories":["脚本"],"content":"摘要：讨论Shell脚本编写时用到的一些常用\u0026实用技巧","date":"2022-03-07","objectID":"/2022/03/16_shell%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/","tags":["shell脚本","unix"],"title":"Shell脚本实用技巧小结","uri":"/2022/03/16_shell%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"categories":["脚本"],"content":"前言 Shell脚本 ，故名思义，是“外壳程序”，由于用户无法和内核直接对话，给Kernel套了一层外壳语言Shell，通过这个中间层来和系统交互，主要功能是提升各项日常事务的自动化程度，并不像C/C++那般集中于复杂的特定任务计算。 Shell有很多种，$sh$、$csh$、$ksh$、$bash$、$zsh$ 是比较常见的，可以通过echo $SHELL查看当前使用的Shell是什么，也可以通过chsh命令来管理终端使用的SHELL类别： #查看系统安装了哪些shell chsh -l #如果有zsh，可以选择切换为zsh chsh -s /bin/zsh 在Shell脚本的开头，需要指定该脚本使用哪个shell来执行（可以和终端使用的SHELL不同）： #!/bin/bash 或者开头加上： #!/bin/zsh 当然，bash是最常用的，建议shell脚本还是用bash，即使在win平台的git-bash，也可以运行bash。 所以，本文提及的Shell语法技巧，是跨平台的，适用于 Windows/Linux/MacOS。 基本语句结构 ","date":"2022-03-07","objectID":"/2022/03/16_shell%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/:0:0","tags":["shell脚本","unix"],"title":"Shell脚本实用技巧小结","uri":"/2022/03/16_shell%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"categories":["脚本"],"content":"if ","date":"2022-03-07","objectID":"/2022/03/16_shell%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/:1:0","tags":["shell脚本","unix"],"title":"Shell脚本实用技巧小结","uri":"/2022/03/16_shell%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"categories":["脚本"],"content":"基本用法 if语句应该是使用最多的分支结构了，基本结构是if...then...fi，多种情况可插入else和elif。 注意条件判断的括号可以用中括号[ ]，也可以用 (( )) ，或者[[ ]] 。 [ ]和[[ ]] 的区别是，前者使用-a，-o表示与、或的逻辑关系，或者用\u0026\u0026和||。 (( ))和[[ ]] 的区别是，前者才可以判断简单数学运算的判断，后者更适合处理字符串比较。 关于空格： if和括号之间要留空格 括号和内部表达式之间要有空格 ⚠️shell脚本里的赋值语句，等号=前后不要留空格 #!/bin/sh a=20 #⚠️等号=前后不要留空格! b=10 if [[ $a == $b || $a \u003e $b ]] # 左边的$a和最右边的$b，都和括号至少留有1个空格s then # then语句可以写在第二行 echo \"a is equal or greater than b\" fi if [ $a != $b ] ;then #then语句可以写在同一行，加分号; echo \"a is not equal to b\" fi if (( $a + $b \u003c 100 )) ; then # 数学四则运算用这个括号(( )) echo \"sum of a and b is smaller than 100\" else echo \"sum of a and b is greater than 100\" fi 🚀如果有多个分支结构，需要else if的逻辑，那么使用elif ... then即可。 ","date":"2022-03-07","objectID":"/2022/03/16_shell%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/:1:1","tags":["shell脚本","unix"],"title":"Shell脚本实用技巧小结","uri":"/2022/03/16_shell%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"categories":["脚本"],"content":"数值判断 有2种情况： 写在[ ]或[[ ]]内部 比较数字表达式的大小要注意，只支持\u003e,\u003c，==，``!=的判断，不支持\u003e=和\u003c=的判断。需要使用-ge和-le来替换。当然，大于、小于、等于、不等于也可以用-gt、-lt、-eq、-ne`来替换。 📍Ps：gt表示greater than ,ge 表示 greater or equal,lt表示little than,le表示little or equal。 #!/bin/bash a=5 b=6 if [ $a -le $b ] ; then echo \"a is little or equal than b\" fi 写在(( ))内部 (( ))内部可以非常完美地支持四则运算，所以关于数字表达式的判断，建议和支持使用这种形式，非常自然地支持\u003e,\u003c,\u003e=,\u003c=四种符号的判断。 ","date":"2022-03-07","objectID":"/2022/03/16_shell%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/:1:2","tags":["shell脚本","unix"],"title":"Shell脚本实用技巧小结","uri":"/2022/03/16_shell%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"categories":["脚本"],"content":"文件属性判断 一般是对文件或者文件夹做判断，常用的类型如下几类： 选项 含义 -e 判断文件或目录是否存在 -d 判断是不是目录，并是否存在 -f 判断是否是普通文件，并存在 -r 判断文档是否有读权限 -w 判断是否有写权限 -x 判断是否可执行 使用时的具体格式举例为：if [ -e filename ] ; then ","date":"2022-03-07","objectID":"/2022/03/16_shell%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/:1:3","tags":["shell脚本","unix"],"title":"Shell脚本实用技巧小结","uri":"/2022/03/16_shell%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"categories":["脚本"],"content":"字符串判断 选项 含义 -z 判断该字符串是否为空(为空返回真) -n 判断该字符串是否为非空(非空返回真) == 字符串1和 字符串2是否相等 != 字符串1和 字符串2是否不同 =~ 字符串str和正则表达式reg是否匹配 ","date":"2022-03-07","objectID":"/2022/03/16_shell%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/:1:4","tags":["shell脚本","unix"],"title":"Shell脚本实用技巧小结","uri":"/2022/03/16_shell%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"categories":["脚本"],"content":"逻辑复合判断 逻辑判断，通常指“与”，“或”，“非”。 与：即and，用于[ ]内部之间，使用-a表示；用于[[ ]]内部之间，使用\u0026\u0026表示； 或：即or，用于[ ]内部之间，使用-o表示；用于[[ ]]内部之间，使用||表示； 非：即not，使用 ! 表示。 -a 和 -o 作为测试命令的参数用在测试命令的内部，而 \u0026\u0026 和 || 则用来运算测试的返回值，! 为两者通用。 ","date":"2022-03-07","objectID":"/2022/03/16_shell%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/:1:5","tags":["shell脚本","unix"],"title":"Shell脚本实用技巧小结","uri":"/2022/03/16_shell%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"categories":["脚本"],"content":"for for循环分为数字型循环和字符型循环。基本结构为for ... do ...done。 通常，do是独占一行，也可以与for语句同行，但要使用分号; 隔开。 ","date":"2022-03-07","objectID":"/2022/03/16_shell%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/:2:0","tags":["shell脚本","unix"],"title":"Shell脚本实用技巧小结","uri":"/2022/03/16_shell%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"categories":["脚本"],"content":"数字型for 注意注释中另外2种写法建议。 #!/bin/bash for((i=1;i\u003c=10;i++)) #可以换成 for i in $(seq 1 10) 或 for i in {1..10} do echo $i*5-1 = $(expr $i \\* 5 - 1); done ","date":"2022-03-07","objectID":"/2022/03/16_shell%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/:2:1","tags":["shell脚本","unix"],"title":"Shell脚本实用技巧小结","uri":"/2022/03/16_shell%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"categories":["脚本"],"content":"字符型for 字符型的循环一般用来列表的遍历，或者文件的遍历。 文件的遍历： #!/bin/bash echo \"in current dir,include these files/dirs:\" for i in `ls .` #文件的遍历 do echo $i #输出的文件/文件夹不带路径 done # 文件/文件夹的遍历的第二种方法 echo \"in director ~/Downloads,has theses files/sub-directories\" for dir in ~/Downloads/* do echo $dir #输出的文件/文件夹是全路径 done 🚥 如果需要递归遍历子目录，需要命令选项-R，即 ls -R。 字符串的遍历： echo \"one week,has seven days:\" #下方列表以空格为间隔符 weekDays=\"Monday Tuesday Wednesday Thursday Friday Saturday Sundat\" for day in $weekDays #可以换成for param in $* 变成对脚本入参的遍历 do echo $day done ","date":"2022-03-07","objectID":"/2022/03/16_shell%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/:2:2","tags":["shell脚本","unix"],"title":"Shell脚本实用技巧小结","uri":"/2022/03/16_shell%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"categories":["脚本"],"content":"while shell脚本的while循环和其他语言的逻辑判断一致，当条件不符合时跳出循环。基本语句结构是while... do...done。 同样地，可以让 do语句独立成行，也可以while 判别式; do以分号隔开，实现while和do同一行。 #!/bin/bash sum=0 echo \"请输入您要累加的数字，按 Ctrl+D 组合键结束读取\" while read n do ((sum += n)) # (( ))符号内部放置四则运算，支持+=运算 done echo \"The sum is: $sum\" ","date":"2022-03-07","objectID":"/2022/03/16_shell%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/:3:0","tags":["shell脚本","unix"],"title":"Shell脚本实用技巧小结","uri":"/2022/03/16_shell%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"categories":["脚本"],"content":"case case语句对应其他语言的switch-case结构，只是在写法上有所区别。通常用于针对用户的不同输入，作出不同的分支流程。 举例一个编译脚本需要选择分支，代码如下： #!/bin/bash echo \"想要编译的模式为:r(表示release),d(d表示debug)\" read type case $type in r) #每个case以单个右括号结束，作为界定 echo \"build type is release\" ;; #2个连续的分号,;;相当于c语言的每个case需要的break语句 d) echo \"build type is debug\" ;; *) # * 表示default情况，上述情况都没匹配上 echo \"unkown build type\" ;; esac # 以esac结尾，其实是case反过来拼写 ","date":"2022-03-07","objectID":"/2022/03/16_shell%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/:4:0","tags":["shell脚本","unix"],"title":"Shell脚本实用技巧小结","uri":"/2022/03/16_shell%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"categories":["脚本"],"content":"continue/break 这2者的用法都是结合for/while循环使用的，意义和其他语言类似，此处不赘述。 遍历文件 有时会有需要对文件夹内每个文件都进行相同的处理，这时遍历文件操作是无法避免的了。 #注意shell里的赋值语句，等号左右2边不要留空格 ScriptPath=`dirname $0` #比如想遍历打印脚本所在目录的所有文件 for file in `ls ${ScriptPath}` do echo file is $file done 脚本运行计时 ","date":"2022-03-07","objectID":"/2022/03/16_shell%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/:5:0","tags":["shell脚本","unix"],"title":"Shell脚本实用技巧小结","uri":"/2022/03/16_shell%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"categories":["脚本"],"content":"系统time指令 主要使用了time指令，time后接linux指令可以测量指令运行时间。 time ./build.sh # 在build结束后输出: 114.75s user 10.32s system 423% cpu 29.552 total 具体time指令的用法，可以参考：菜鸟教程：time指令 ","date":"2022-03-07","objectID":"/2022/03/16_shell%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/:6:0","tags":["shell脚本","unix"],"title":"Shell脚本实用技巧小结","uri":"/2022/03/16_shell%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"categories":["脚本"],"content":"脚本内计时 startTime=$(date +%s) # ... 脚本主体内容 ... endTime=$(date +%s) echo -e \"Cost time:$(($endTime - $startTime))seconds\\n\" 接收命令行参数 ","date":"2022-03-07","objectID":"/2022/03/16_shell%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/:7:0","tags":["shell脚本","unix"],"title":"Shell脚本实用技巧小结","uri":"/2022/03/16_shell%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"categories":["脚本"],"content":"命令行特殊变量 通常Shell脚本内可以自定义变量，比如buildDir=\"build\",读引用的时候使用$buildDir或者${buildDir}。 但还有一类变量不需要定义，每个shell脚本内都可以直接使用，可以理解为built-in 变量。 变量 含义 $0 当前脚本的文件名 $n 传递给脚本或函数的参数。n 是一个数字，表示第几个参数 $# 传递给脚本或函数的参数个数。 $* 传递给脚本或函数的所有参数。 $@ 传递给脚本或函数的所有参数。加双引号\"才和$*有区别，引号中返回每个参数。 $? 上个命令的退出状态，或函数的返回值。 $$ 当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。 ✳️对比$*和$@的区别（使用时要加引号\"才会体现区别，不加引号就一样，都是逐个参数多行输出）： #!/bin/bash # testParam.sh echo \"-- \\$* 演示 ---\" for i in \"$*\"; do # 使用时要加引号\"，才会体现区别 echo $i # 若不加引号\"，也是逐行单个参数输出 done echo \"-- \\$@ 演示 ---\" for i in \"$@\"; do # 使用时要加引号\"，才会体现区别 echo $i done 如果执行./testParam.sh a b 1 2 -x -y,那么输出如下内容： -- $* 演示 --- a b 1 2 -x -y -- $@ 演示 --- a b 1 2 -x -y ","date":"2022-03-07","objectID":"/2022/03/16_shell%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/:8:0","tags":["shell脚本","unix"],"title":"Shell脚本实用技巧小结","uri":"/2022/03/16_shell%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"categories":["脚本"],"content":"命令行参数分析 运行一个脚本可能会带有参数，比如 ./build.sh -d -arm64的含义可能为“编译arm64架构的debug包”。 在学会getopts分析之前，我是对$1,$2...$n逐个分析(n为参数个数$#)，然后利用case语句赋值的，写出来的代码比较冗长麻烦且不美观。 废话不多说，直接看getopts的使用吧： while与getops联合使用，待选的选项里有2类，带参数的以冒号:隔开，不带参数的不需分隔，写在一起。示例代码如下所示 ⬇️ #!/bin/bash # build.sh 文件内容 function usage(){ echo \"-h : print help message\" echo \"-r : build type is release\" echo \"-d : build type is debug\" echo \"-a : architecture type,with value,one of i386/x86_64/arm64\" echo \"-s : compiler sdk version,with value,format like 10.16,no limits about value\" } while getopts \"a:s:hd\" o; do case \"${o}\" in h) usage ;; d) buildDebug=true echo \"build debug version, without optimizations\" ;; a) arch=${OPTARG} echo \"Architecture: ${arch}\" ;; s) sdkVersion=${OPTARG} versionFull=\"${sdkDir}/OSX${sdkVersion}.sdk\" echo \"==\u003e Now using sdk-root version is : ${versionFull}\" ;; *) usage ;; esac done 鉴于上述getopts的定义，可以使用./build.sh -h来查看帮助信息，也可以使用./build.sh -r -a x86_64 -s 10.15来执行脚本进行build（示例代码略去build脚本其他内容）。 字符串处理 说起字符串，先说个比较常用的，字符串的长度表示为${#str}： #!/bin/bash str=\"Hello World\" echo str's length is ${#str} ","date":"2022-03-07","objectID":"/2022/03/16_shell%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/:9:0","tags":["shell脚本","unix"],"title":"Shell脚本实用技巧小结","uri":"/2022/03/16_shell%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"categories":["脚本"],"content":"字符串截取 Shell脚本中字符串截取分2种情况：使用数字下标，或使用特定字符标记。 数字下标截取 这种方式就是选定一个起始点start-pos，然后按照从左往右的阅读顺序截取一段长度为length的子串。 从字符串开头截取 形式为${originStr:start_pos:length}，起始点为从左边第一个字符(下标0)开始数，数到下标为start_pos的字符，从左往右截取长度为length的字串，length设置过大则到远串末尾截止。 从字符串尾部开始截取 形式为${originStr:0-start_pos:length}，“0-”是表示从后往前数，起始点为从右边第一个字符(下标1，倒着数，从1开始)开始数，数到下标为start_pos的字符，同样从左往右截取长度为length的字串，length设置过大则到远串末尾截止。 从字符串开头截取 #!/bin/bash originStr=\"https://kissingfire123.github.io\" echo \"originStr is $originStr\" subStr1=${originStr:3:6} # 从字符串开头截取 echo \"subStr1 is $subStr1\" subStr2=${originStr:0-6:4} # 从字符串尾部开始截取 echo \"subStr2 is $subStr2\" 运行后输出如下内容: originStr is https://kissingfire123.github.io subStr1 is ps://k subStr2 is hub. 特定子串标记 特定字符标记的意思是“遍历字符串，遇到某个目标字符串chars为止，截取其前/其后的部分”。明显，这种方式不能指定长度。 🤔 这种截取方式的截取内容，都不包括分隔符chars。 截取左边 使用%来截取左边的字符串，其中星号* 表示通配符，注意是char*，因为需要左边，所有chars的右边内容我们不关心。 格式 含义 ${originStr%chars*} 遍历originStr，遇到第一个子字符串chars为止，截取左边内容 ${originStr%%chars*} 遍历originStr，遇到最后一个子字符串chars为止，截取左边内容 示例代码如下所示： #!/bin/bash originStr=\"https://kissingfire123.github.io\" echo \"originStr is $originStr\" subStr1=${originStr%.*} # 匹配第一个符号'.' echo \"subStr1 is $subStr1\" subStr2=${originStr%%.*} # 匹配最后一个符号'.' echo \"subStr2 is $subStr2\" subStr3=${originStr%ss*} # 匹配第一个子字符串'ss' echo \"subStr3 is $subStr3\" 输出内容为： originStr is https://kissingfire123.github.io subStr1 is https://kissingfire123.github subStr2 is https://kissingfire123 subStr3 is https://ki 截取右边 使用#来截取左边的字符串。逻辑和上述左边字串的非常类似，注意是*char，因为需要右边，所有chars的左边内容我们不关心。类似地有下列表格： 格式 含义 ${originStr#*chars} 遍历originStr，遇到第一个子字符串chars为止，截取右边内容 ${originStr##*chars} 遍历originStr，遇到最后一个子字符串chars为止，截取右边内容 示例代码如下： #!/bin/bash originStr=\"https://kissingfire123.github.io\" echo \"originStr is $originStr\" subStr1=${originStr#*i} # 寻找第一个字符串'i'，保留其右边 echo \"subStr1 is $subStr1\" subStr2=${originStr##*i} # 寻找最后一个字符串'i'，保留其右边 echo \"subStr2 is $subStr2\" subStr3=${originStr#*ss} # 寻找第一个字符串'ss'，保留其右边 echo \"subStr3 is $subStr3\" 输出如下内容： originStr is https://kissingfire123.github.io subStr1 is ssingfire123.github.io subStr2 is o subStr3 is ingfire123.github.io ","date":"2022-03-07","objectID":"/2022/03/16_shell%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/:10:0","tags":["shell脚本","unix"],"title":"Shell脚本实用技巧小结","uri":"/2022/03/16_shell%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"categories":["脚本"],"content":"字符串替换 如果说，上一小节是描述substr功能，那么本小节就是描述replace功能了。 格式 含义 ${originStr/match_str/replace_str} 1个/，表示将匹配到的第一个match_str，替换成replace_str ${originStr//match_str/replace_str} 2个/，表示将匹配到的所有match_str，全替换成replace_str 示例如下： #!/bin/bash originStr=\"https://kissingfire123.github.io/2022/02/14_Shell语法小结/\" echo \"originStr is $originStr\" subStr1=${originStr/s/T} # 第一个匹配的子字符串's'，替换为T echo \"subStr1 is $subStr1\" subStr2=${originStr//02/哈哈} # 所有匹配的子字符串'02'，都替换为'哈哈' echo \"subStr2 is $subStr2\" 输出内容为： originStr is https://kissingfire123.github.io/2022/02/14_Shell语法小结/ subStr1 is httpT://kissingfire123.github.io/2022/02/14_Shell语法小结/ subStr2 is https://kissingfire123.github.io/2哈哈2/哈哈/14_Shell语法小结/ ⚠️：match_str可以为正则表达式，留待下节讲述。 ","date":"2022-03-07","objectID":"/2022/03/16_shell%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/:11:0","tags":["shell脚本","unix"],"title":"Shell脚本实用技巧小结","uri":"/2022/03/16_shell%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"categories":["脚本"],"content":"字符串正则 正则表达式，用于模糊查找匹配 ，本身比较复杂，但掌握后受益良多，详细可参考菜鸟教程：正则表达式。 Shell 字符串的正则表达式主要用于2处，一处为字符串比较判断，另一处为字符串的正则匹配后替换。 Shell 脚本中应用正则表达式的几个常用命令为 grep 、sed 、 cut、 awk ，需要注意的是，具体命令支持的正则功能范围可能是不同的。 正则比较判断 正则比较判断的比较符号是 =~ ，使用原始字符串和匹配正则pattern进行匹配，如果成功匹配返回1，失败返回0，常用于判断字符类型(比如时间、电话号、版本类型等)。关于 if 语句针对 =~ 的应用，可参考GNU-Bash参考手册: 条件表达式 。 正则字符替换 在 sed 指令中使用频繁，在 vim 指令中也可以发挥用武之地，此处不赘述。 下方代码使用 if 表达式 和 grep 简单示范上述2者的用法： #!/bin/bash fullVimStr=`vim --version | grep IMproved` # 提取Vim版本号的关键行 echo fullVimStr is ${fullVimStr} pattern=^.*[0-9]\\.[0-9].*$ # 此处正则表达式可以用单引号' 包裹，也可以不用 if [[ $fullVimStr =~ $pattern ]] ; then echo -e \"match Ok:match a valid version !\" numPattern='[0-9]\\.[0-9]' versionNum=`echo $fullVimStr | grep -P $numPattern -o ` echo \"split Ok: versionNum is $versionNum\" fi 上述脚本执行后输出如下内容： fullVimStr is VIM - Vi IMproved 8.2 (2019 Dec 12, compiled Jun 1 2020 06:42:35) match Ok:match a valid version ! split Ok: versionNum is 8.2 多行注释 多行注释有以下2种方法可以做到 👇 ","date":"2022-03-07","objectID":"/2022/03/16_shell%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/:12:0","tags":["shell脚本","unix"],"title":"Shell脚本实用技巧小结","uri":"/2022/03/16_shell%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"categories":["脚本"],"content":"空命令接收注释行 用 “:\u003c\u003c任意字符与数字” + \"相同字符与数字\"将需要注释的多行内容包裹起来即可。注意，这个字符尽量不要取单引号，双引号，以免和注释内容中的引号提前匹配。 下方代码取字符为\"EOF\"，其实换成其他的，比如\"Comment\"也是一样的。 :\u003c\u003cEOF 被注释的Line1 被注释的Line2 被注释的Line3 EOF 值得注意的是，这里是用个空命令来接收注释内容，被注释内容也确实没有在当前终端执行，但是“空命令接收”这一动作还是背后有开销的。 ","date":"2022-03-07","objectID":"/2022/03/16_shell%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/:13:0","tags":["shell脚本","unix"],"title":"Shell脚本实用技巧小结","uri":"/2022/03/16_shell%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"categories":["脚本"],"content":"函数定义式 对于要注释的多行内容，将其封装成一个函数，这样在脚本运行时完全没有开销。 还是上述的例子，可以使用函数的形式，只定义，不调用： EofFuncHere(){ 被注释的Line1 被注释的Line2 被注释的Line3 } 重要的FAQs echo的常用输出选项？ echo -n: 取消换行符 echo -e:启用反斜杠转义 单引号' '和双引号\" \"的区别？ 单引号：也叫hard quote，关闭所有引用 双引号：也叫soft quote，保留$引用 变量赋值和export差别？ 变量赋值：使用等号=赋值，等号前后不能留有空格 export变量：如果是在Shell脚本内export，即成为当前Shell脚本运行时的环境变量；如果是在终端命令窗口export，有效范围为当前窗口；在~/.bash_profile export，有效范围为当前用户；在/etc/bashrc(Ubuntu为/etc/bash.bashrc)，有效范围为本机所有用户。 exec和source的差异？ 我们执行一个shell脚本时，实际是先产生一个sub-shell的子进程，然后sub-shell在去产生命令行的子进程。 ./test.sh：创建sub-shell执行脚本； source test.sh ：以当前shell执行； exec test.sh：当前shell执行后退出； 如何实现命令替换和变量替换？ 命令替换：使用圆括号$( )或者反引号**` `**，将命令包裹其中 变量替换：使用大括号${ }，将变量包裹其中 不同情况下的’退出’含义? break：是提前结束循环 return：是结束function exit：是结束Shell脚本，并给出返回值 如何检测脚本是否执行成功？ 第一，当然是打印信息或者直接写result文件了。 其二，Shell中有个特殊的变量$?，就是上一句命令或者上一个刚执行完的脚本的返回值，只需要echo $?，就能快速查看上一条语句/脚本是否成功了。 通常来说，脚本执行成功都是约定俗成返回值0。 Shell脚本的数组怎么使用？ 比如定义一个数组A=(a b c d)，那么如下示例： # 引用数组 ${A[@]} ${A[*]} # 访问数组成员 ${A[0]} # 数组长度 ${#A[@]} ${#A[*]} # 数组修改赋值 A[2]=xyzw 参考链接： 菜鸟教程：Shell传递参数 C语言中文网：Shell字符串截断 腾讯云：Shell正则遇到的问题 CSDN：Shell正则表达式 博客园：Shell 多行注释 知乎：Shell 实现多行注释的几种常用方法 Linux科技：你应该知道的Shell十三问 ","date":"2022-03-07","objectID":"/2022/03/16_shell%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/:14:0","tags":["shell脚本","unix"],"title":"Shell脚本实用技巧小结","uri":"/2022/03/16_shell%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"categories":["脚本"],"content":"摘要：常用KaTex语法总结，在网页、Markdown中常用的数学公式写法","date":"2022-02-20","objectID":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/","tags":["Markdown","Katex"],"title":"常用数学公式排版KaTex语法总结","uri":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["脚本"],"content":" 零、 前言 $\\TeX$ 数学公式是以文本的形式和规则书写，由公式渲染器进行渲染，可以嵌入Markdown，HTML网页等内容。知名且广泛使用的数学JS渲染器支持有$MathJax$，$\\KaTeX$ ，两者底层采用的都是 $\\TeX$ 排版协议。 $MathJax$支持的公式功能更多更全面，但是$\\KaTeX$ 渲染速度更快，而且其特性覆盖范围足够大多数人使用。 本博客主题为HugoTheme-LoveIt，使用的是$\\KaTeX$ 数学渲染器，所以涉及的语法都是$\\KaTeX$ 和$MathJax$都支持的部分。 ⚠️ 关于公式内换行，标准的$MathJax$和$\\KaTeX$是\"\\\\\"，而本博客主题的$\\KaTeX$是\"\\\\\\\\\"，这个很重要！（尤其是输入矩阵这类多行公式 ） 本博客主题的$\\KaTeX$ 使用\\对其他单个字符进行转义时，也是类似，比如公式内空格可以\\space或者用\\\\,或\\\\;，某些场合需要大括号{},也是使用\\\\{和\\\\}$\\Longrightarrow$注意$\\KaTeX$ 对于单个符号转义就是用2个斜杠\\。 一、公式使用 ","date":"2022-02-20","objectID":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/:0:0","tags":["Markdown","Katex"],"title":"常用数学公式排版KaTex语法总结","uri":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["脚本"],"content":"1．如何插入公式 $\\LaTeX$ 的数学公式有两种：行内公式和独立公式。行中公式放在文中与其它文字混编，独立公式单独成行。 行内公式可以用单个美元符号包裹表示：例如$a^2+b^2 = c^2$，渲染后$a^2+b^2 = c^2$。 独立成行的公式用2个美元符号包裹表示：例如$$a^2+b^2 = c^2$$,渲染后： $$a^2+b^2 = c^2$$ ","date":"2022-02-20","objectID":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/:1:0","tags":["Markdown","Katex"],"title":"常用数学公式排版KaTex语法总结","uri":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["脚本"],"content":"2．输入上下标 ^ 表示上标, _ 表示下标。如果上下标的内容多于一个字符，需要用 {} 将这些内容括成一个整体。上下标可以嵌套，也可以同时使用。 例子： $$x^{y^z}=(1+{\\rme}^x)^{-2xy^w} $$ 显示： $$ x^{y^z}=(1+{\\rm e}^x)^{-2xy^w} $$ ","date":"2022-02-20","objectID":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/:2:0","tags":["Markdown","Katex"],"title":"常用数学公式排版KaTex语法总结","uri":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["脚本"],"content":"3．输入括号和分隔符 ()、[] 和 | 表示符号本身，使用 \\{\\} 来表示 {} 。当要显示大号的括号或分隔符时，要用 \\left 和 \\right 命令。 一些特殊的括号： 输入 显示 输入 显示 \\langle $\\langle$ \\rangle $\\rangle$ \\lceil $\\lceil$ \\rceil $\\rceil$ \\lfloor $\\lfloor$ \\rfloor $\\rfloor$ \\lbrace $\\lbrace$ \\rbrace $\\rbrace$ \\lvert $\\lvert$ \\rvert $\\rvert$ \\lVert $\\lVert$ \\rVert $\\rVert$ 有时，我们需要在行内使用两个竖杠表示向量间的某种空间距离，可以这样写 \\lVert \\boldsymbol{X}_i - \\boldsymbol{S}_j \\rVert^2 → $\\lVert \\boldsymbol{X}_i - \\boldsymbol{S}_j \\rVert^2$ 例子： $$f(x,y,z)=3y^2z \\left(3+\\frac{7x+5}{1+y^2} \\right)$$ 显示： $$ f(x,y,z) = 3y^2z \\left( 3+\\frac{7x+5}{1+y^2} \\right) $$ 有时要用 \\left. 或 \\right. 进行匹配而不显示本身。 例子： $$\\left. \\frac{{\\rmd}u}{{\\rmd}x} \\right| _{x=0} $$ 显示：$$ \\left. \\frac{{\\rm d}u}{{\\rm d}x} \\right| _{x=0} $$ ","date":"2022-02-20","objectID":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/:3:0","tags":["Markdown","Katex"],"title":"常用数学公式排版KaTex语法总结","uri":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["脚本"],"content":"4．输入分数 通常使用 \\frac {分子} {分母} 来生成一个分数，分数可多层嵌套。如果分式较为复杂，亦可使用 分子 \\over 分母 此时分数仅有一层。 例子： $$\\frac{a-1}{b-1} \\quador \\quad{a+1\\overb+1} $$ 显示：$$ \\frac{a-1}{b-1} \\quad or \\quad {a+1 \\over b+1} $$ 当分式 仅有两个字符时 可直接输入 \\frac ab 来快速生成一个 $\\large\\frac ab$ 。 例子： $$\\frac12,\\frac1a,\\fraca2\\quad\\mid\\quad\\text{2letters only:} \\quad\\frac12a \\\\,, k\\fracq{r^2} $$ 显示：$$ \\frac 12,\\frac 1a,\\frac a2 \\quad \\mid \\quad \\text{2 letters only:} \\quad \\frac 12a \\,, k\\frac q{r^2} $$ ","date":"2022-02-20","objectID":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/:4:0","tags":["Markdown","Katex"],"title":"常用数学公式排版KaTex语法总结","uri":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["脚本"],"content":"5．输入开方 使用 \\sqrt [根指数，省略时为2] {被开方数} 命令输入开方。 例子： $$\\sqrt{2} \\quador \\quad\\sqrt[n]{3} $$ 显示：$$ \\sqrt{2} \\quad or \\quad \\sqrt[n]{3} $$ ","date":"2022-02-20","objectID":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/:5:0","tags":["Markdown","Katex"],"title":"常用数学公式排版KaTex语法总结","uri":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["脚本"],"content":"6．输入省略号 数学公式中常见的省略号有两种，\\ldots 表示与 文本底线 对齐的省略号，\\cdots 表示与 文本中线 对齐的省略号。 例子： $$f(x_1,x_2\\ldotsx_n)=x_1^2+x_2^2+\\cdots+x_n^2$$ 显示： $$ f(x_1,x_2 \\ldots x_n) = x_1^2 + x_2^2 + \\cdots + x_n^2 $$ ","date":"2022-02-20","objectID":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/:6:0","tags":["Markdown","Katex"],"title":"常用数学公式排版KaTex语法总结","uri":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["脚本"],"content":"7．输入向量 使用 \\vec{向量} 来自动产生一个向量。也可以使用 \\overrightarrow 等命令自定义字母上方的符号。 例子： $$\\vec{a} \\cdot\\vec{b}=0$$ 显示：$$ \\vec{a} \\cdot \\vec{b}=0 $$ 例子： $$xy \\text{ with arrows:} \\quad\\overleftarrow{xy} \\\\; \\mid\\\\; \\overleftrightarrow{xy} \\\\; \\mid\\\\; \\overrightarrow{xy} $$ 显示：$$ xy \\text{ with arrows:} \\quad \\overleftarrow{xy} \\; \\mid \\; \\overleftrightarrow{xy} \\; \\mid \\; \\overrightarrow{xy} $$ ","date":"2022-02-20","objectID":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/:7:0","tags":["Markdown","Katex"],"title":"常用数学公式排版KaTex语法总结","uri":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["脚本"],"content":"8．输入积分 使用 \\int_积分下限^积分上限 {被积表达式} 来输入一个积分。 例子： $$\\int_0^1{x^2} \\,{\\rmd}x $$ 显示：$$ \\int_0^1 {x^2} ,{\\rm d}x $$ 本例中 \\, 和 {\\rm d} 部分可省略，但加入能使式子更美观，详见“在字符间加入空格”及“如何进行字体转换”。 ","date":"2022-02-20","objectID":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/:8:0","tags":["Markdown","Katex"],"title":"常用数学公式排版KaTex语法总结","uri":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["脚本"],"content":"9．输入极限运算 使用 \\lim_{变量 \\to 表达式} 表达式 来输入一个极限。如有需求，可以更改 \\to 符号至任意符号。 例子： $$\\lim_{n \\to\\infty} \\frac{1}{n(n+1)} \\quadand \\quad\\lim_{x\\leftarrow{示例}} \\frac{1}{n(n+1)} $$ 显示：$$ \\lim_{n \\to \\infty} \\frac{1}{n(n+1)} \\quad and \\quad \\lim_{x\\leftarrow{示例}} \\frac{1}{n(n+1)} $$ ","date":"2022-02-20","objectID":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/:9:0","tags":["Markdown","Katex"],"title":"常用数学公式排版KaTex语法总结","uri":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["脚本"],"content":"10．输入累加、累乘运算 使用 \\sum_{下标表达式}^{上标表达式} {累加表达式} 来输入一个累加。与之类似，使用 \\prod \\bigcup \\bigcap 来分别输入累乘、并集和交集，更多符号可参考“其它特殊字符”。 此类符号在行内显示时上下标表达式将会移至右上角和右下角，如 $\\sum_{i=1}^n \\frac{1}{i^2}$。 例子： $$\\sum_{i=1}^n \\frac{1}{i^2} \\quadand \\quad\\prod_{i=1}^n \\frac{1}{i^2} \\quadand \\quad\\bigcup_{i=1}^{2} \\Bbb{R} $$ 显示：$$ \\sum_{i=1}^n \\frac{1}{i^2} \\quad and \\quad \\prod_{i=1}^n \\frac{1}{i^2} \\quad and \\quad \\bigcup_{i=1}^{2} \\Bbb{R} $$ ","date":"2022-02-20","objectID":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/:10:0","tags":["Markdown","Katex"],"title":"常用数学公式排版KaTex语法总结","uri":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["脚本"],"content":"11．输入希腊字母 输入 \\小写希腊字母英文全称 和 \\首字母大写希腊字母英文全称 来分别输入小写和大写希腊字母。 对于大写希腊字母与现有字母相同的，直接输入大写字母即可。 输入 显示 输入 显示 输入 显示 输入 显示 \\alpha $\\alpha$ A $A$ \\beta $\\beta$ B $B$ \\gamma $\\gamma$ \\Gamma $\\Gamma$ \\delta $\\delta$ \\Delta $\\Delta$ \\epsilon $\\epsilon$ E $E$ \\zeta $\\zeta$ Z $Z$ \\eta $\\eta$ H $H$ \\theta $\\theta$ \\Theta $\\Theta$ \\iota $\\iota$ I $I$ \\kappa $\\kappa$ K $K$ \\lambda $\\lambda$ \\Lambda $\\Lambda$ \\mu $\\mu$ M $M$ \\nu $\\nu$ N $N$ \\xi $\\xi$ \\Xi $\\Xi$ o $o$ O $O$ \\pi $\\pi$ \\Pi $\\Pi$ \\rho $\\rho$ P $P$ \\sigma $\\sigma$ \\Sigma $\\Sigma$ \\tau $\\tau$ T $T$ \\upsilon $\\upsilon$ \\Upsilon $\\Upsilon$ \\phi $\\phi$ \\Phi $\\Phi$ \\chi $\\chi$ X $X$ \\psi $\\psi$ \\Psi $\\Psi$ \\omega $\\omega$ \\Omega $\\Omega$ 部分字母有变量专用形式，以 \\var- 开头。 小写形式 大写形式 变量形式 显示 \\epsilon E \\varepsilon $\\epsilon \\mid E \\mid \\varepsilon$ \\theta \\Theta \\vartheta $\\theta \\mid \\Theta \\mid \\vartheta$ \\rho P \\varrho $\\rho \\mid P \\mid \\varrho$ \\sigma \\Sigma \\varsigma $\\sigma \\mid \\Sigma \\mid \\varsigma$ \\phi \\Phi \\varphi $\\phi \\mid \\Phi \\mid \\varphi$ ","date":"2022-02-20","objectID":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/:11:0","tags":["Markdown","Katex"],"title":"常用数学公式排版KaTex语法总结","uri":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["脚本"],"content":"12．输入其它特殊字符 完整的 $\\LaTeX$ 可用符号列表可以在 这份文档 中查阅（极长，共 348 页），大部分常用符号可以参阅 这份精简版文档 查询。 若需要显示更大或更小的字符，在符号前插入 \\large 或 \\small 命令，比如“$\\small{x} + \\normalsize{x}+\\large{x}$”，显示为$\\small{x} + \\normalsize{x}+\\large{x}$。 $KaTeX$ 针对任意元素均提供从小至大 \\tiny \\scriptsize \\small \\normalsize \\large \\Large \\LARGE \\huge \\Huge 等渲染尺寸。 ","date":"2022-02-20","objectID":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/:12:0","tags":["Markdown","Katex"],"title":"常用数学公式排版KaTex语法总结","uri":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["脚本"],"content":"(1)．关系运算符 输入 显示 输入 显示 输入 显示 输入 显示 \\pm $\\pm$ \\times $\\times$ \\div $\\div$ \\mid $\\mid$ \\nmid $\\nmid$ \\cdot $\\cdot$ \\circ $\\circ$ \\ast $\\ast$ \\bigodot $\\bigodot$ \\bigotimes $\\bigotimes$ \\bigoplus $\\bigoplus$ \\leq $\\leq$ \\geq $\\geq$ \\neq $\\neq$ \\approx $\\approx$ \\equiv $\\equiv$ \\sum $\\sum$ \\prod $\\prod$ \\coprod $\\coprod$ \\backslash $\\backslash$ ","date":"2022-02-20","objectID":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/:12:1","tags":["Markdown","Katex"],"title":"常用数学公式排版KaTex语法总结","uri":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["脚本"],"content":"(2)．集合运算符 输入 显示 输入 显示 输入 显示 \\emptyset $\\emptyset$ \\in $\\in$ \\notin $\\notin$ \\subset $\\subset$ \\supset $\\supset$ \\subseteq $\\subseteq$ \\supseteq $\\supseteq$ \\cap $\\cap$ \\cup $\\cup$ \\vee $\\vee$ \\wedge $\\wedge$ \\uplus $\\uplus$ \\top $\\top$ \\bot $\\bot$ \\complement $\\complement$ ","date":"2022-02-20","objectID":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/:12:2","tags":["Markdown","Katex"],"title":"常用数学公式排版KaTex语法总结","uri":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["脚本"],"content":"(3)．对数运算符 输入 显示 输入 显示 输入 显示 \\log $\\log$ \\lg $\\lg$ \\ln $\\ln$ ","date":"2022-02-20","objectID":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/:12:3","tags":["Markdown","Katex"],"title":"常用数学公式排版KaTex语法总结","uri":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["脚本"],"content":"(4)．三角运算符 输入 显示 输入 显示 输入 显示 \\backsim $\\backsim$ \\cong $\\cong$ \\angle A $\\angle A$ \\sin $\\sin$ \\cos $\\cos$ \\tan $\\tan$ \\csc $\\csc$ \\sec $\\sec$ \\cot $\\cot$ ","date":"2022-02-20","objectID":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/:12:4","tags":["Markdown","Katex"],"title":"常用数学公式排版KaTex语法总结","uri":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["脚本"],"content":"(5)．微积分运算符 输入 显示 输入 显示 输入 显示 \\int $\\int$ \\iint $\\iint$ \\iiint $\\iiint$ \\partial $\\partial$ \\oint $\\oint$ \\prime $\\prime$ \\lim $\\lim$ \\infty $\\infty$ \\nabla $\\nabla$ ","date":"2022-02-20","objectID":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/:12:5","tags":["Markdown","Katex"],"title":"常用数学公式排版KaTex语法总结","uri":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["脚本"],"content":"(6)．逻辑运算符 输入 显示 输入 显示 输入 显示 \\because $\\because$ \\therefore $\\therefore$ \\neg $\\neg$ \\forall $\\forall$ \\exists $\\exists$ \\not\\subset $\\not\\subset$ \\not\u003c $\\not\u003c$ \\not\u003e $\\not\u003e$ \\not= $\\not=$ ","date":"2022-02-20","objectID":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/:12:6","tags":["Markdown","Katex"],"title":"常用数学公式排版KaTex语法总结","uri":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["脚本"],"content":"(7)．戴帽符号 输入 显示 输入 显示 输入 显示 \\hat{xy} $\\hat{xy}$ \\widehat{xyz} $\\widehat{xyz}$ \\bar{y} $\\bar{y}$ \\tilde{xy} $\\tilde{xy}$ \\widetilde{xyz} $\\widetilde{xyz}$ \\acute{y} $\\acute{y}$ \\breve{y} $\\breve{y}$ \\check{y} $\\check{y}$ \\grave{y} $\\grave{y}$ \\dot{x} $\\dot{x}$ \\ddot{x} $\\ddot{x}$ 若需要在特定文字顶部\\底部放置内容，可使用 \\overset{顶部内容}{正常内容} 和 \\underset{底部内容}{正常内容} 命令。 例子： $$\\verb+\\overset{above}{level}+\\qquad\\overset{xx}{ABC} \\\\;\\\\; \\mid\\quad\\overset{x^2}{\\longmapsto}\\ \\\\, \\mid\\quad\\overset{\\bullet\\circ\\circ\\bullet}{T} $$ 显示： $$ \\verb+\\overset{above}{level}+ \\qquad \\overset{xx}{ABC} \\;\\; \\mid \\quad \\overset{x^2}{\\longmapsto}\\ \\, \\mid \\quad \\overset{\\bullet\\circ\\circ\\bullet}{T} $$ 例子： $$\\verb+\\underset{below}{level}+\\qquad\\underset{xx}{ABC} \\\\;\\\\; \\mid\\quad\\underset{x^2}{\\longmapsto}\\ \\\\, \\mid\\quad\\underset{\\bullet\\circ\\circ\\bullet}{T} $$ 显示： $$ \\verb+\\underset{below}{level}+ \\qquad \\underset{xx}{ABC} \\;\\; \\mid \\quad \\underset{x^2}{\\longmapsto}\\ \\, \\mid \\quad \\underset{\\bullet\\circ\\circ\\bullet}{T} $$ 此命令可叠加嵌套使用，生成类似化学反应式的多重条件符号， 例子： \\rm {SrO} + V^{''}_{Sr} \\overset{H_2}{\\underset{1300℃}{\\Longleftrightarrow}} 2e^{'}+\\frac 12O_2(g) + Sr^{\\times}_S 显示： $$ \\rm {SrO} + V^{''}_{Sr} \\overset{H_2}{\\underset{1300℃}{\\Longleftrightarrow}} 2e^{'}+\\frac 12O_2(g) + Sr^{\\times}_S$$ ","date":"2022-02-20","objectID":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/:12:7","tags":["Markdown","Katex"],"title":"常用数学公式排版KaTex语法总结","uri":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["脚本"],"content":"(8)．连线符号 其它可用的文字修饰符可参见官方文档 “Additional decorations”。 输入 显示 \\fbox{a+b+c+d} 高级框选需声明 enclose 标签 $\\fbox{a+b+c+d}$ \\overleftarrow{a+b+c+d} $\\overleftarrow{a+b+c+d}$ \\overrightarrow{a+b+c+d} $\\overrightarrow{a+b+c+d}$ \\overleftrightarrow{a+b+c+d} $\\overleftrightarrow{a+b+c+d}$ \\underleftarrow{a+b+c+d} $\\underleftarrow{a+b+c+d}$ \\underrightarrow{a+b+c+d} $\\underrightarrow{a+b+c+d}$ \\underleftrightarrow{a+b+c+d} $\\underleftrightarrow{a+b+c+d}$ \\overline{a+b+c+d} $\\overline{a+b+c+d}$ \\underline{a+b+c+d} $\\underline{a+b+c+d}$ \\overbrace{a+b+c+d}^{Sample} $\\overbrace{a+b+c+d}^{Sample}$ \\underbrace{a+b+c+d}_{Sample} $\\underbrace{a+b+c+d}_{Sample}$ \\overbrace{a+\\underbrace{b+c}_{1.0}+d}^{2.0} $\\overbrace{a+\\underbrace{b+c}_{1.0}+d}^{2.0}$ \\underbrace{a\\cdot a\\cdots a}_{b\\text{ times}} $\\underbrace{a\\cdot a\\cdots a}_{b\\text{ times}}$ ","date":"2022-02-20","objectID":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/:12:8","tags":["Markdown","Katex"],"title":"常用数学公式排版KaTex语法总结","uri":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["脚本"],"content":"(9)．箭头符号 推荐使用符号： 输入 显示 输入 显示 输入 显示 \\to $\\to$ \\mapsto $\\mapsto$ \\underrightarrow{1℃/min} $\\underrightarrow{1℃/min}$ \\implies $\\implies$ \\iff $\\iff$ \\impliedby $\\impliedby$ 其它可用符号： 输入 显示 输入 显示 \\uparrow $\\uparrow$ \\Uparrow $\\Uparrow$ \\downarrow $\\downarrow$ \\Downarrow $\\Downarrow$ \\leftarrow $\\leftarrow$ \\Leftarrow $\\Leftarrow$ \\rightarrow $\\rightarrow$ \\Rightarrow $\\Rightarrow$ \\leftrightarrow $\\leftrightarrow$ \\Leftrightarrow $\\Leftrightarrow$ \\longleftarrow $\\longleftarrow$ \\Longleftarrow $\\Longleftarrow$ \\longrightarrow $\\longrightarrow$ \\Longrightarrow $\\Longrightarrow$ \\longleftrightarrow $\\longleftrightarrow$ \\Longleftrightarrow $\\Longleftrightarrow$ ","date":"2022-02-20","objectID":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/:12:9","tags":["Markdown","Katex"],"title":"常用数学公式排版KaTex语法总结","uri":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["脚本"],"content":"13．如何进行字体转换 若要对公式的某一部分字符进行字体转换，可以用 {\\字体 {需转换的部分字符}} 命令，其中 \\字体 部分可以参照下表选择合适的字体。一般情况下，公式默认为斜体字 $italic$ 。 示例中 全部大写 的字体仅大写可用。 输入 全字母可用 显示 输入 仅大写可用 显示 \\rm 罗马体 $\\rm{Sample}$ \\mathcal 花体（数学符号等） $\\mathcal{SAMPLE}$ \\it 斜体 $\\it{Sample}$ \\mathbb 黑板粗体（定义域等） $\\mathbb{SAMPLE}$ \\bf 粗体 $\\bf{Sample}$ \\mathit 数学斜体 $\\mathit{SAMPLE}$ \\sf 等线体 $\\sf{Sample}$ \\mathscr 手写体 $\\mathscr{SAMPLE}$ \\tt 打字机体 $\\tt{Sample}$ \\frak 旧德式字体 $\\frak{Sample}$ ⚠️注意： \\boldsymbol{\\vec \\alpha} 用来表示向量或者矩阵的加粗斜体，如向量 $\\boldsymbol{\\vec\\alpha}$。 转换字体十分常用，例如在积分中： 例子： \\begin{array}{cc} \\mathrm{Bad} \u0026 \\mathrm{Better} \\\\\\\\ \\hline \\\\\\\\ \\int_0^1 x^2 dx \u0026 \\int_0^1 x^2 \\\\,{\\rm d}x \\end{array} 显示： $$\\begin{array}{cc} \\mathrm{Bad} \u0026 \\mathrm{Better} \\\\ \\hline \\\\ \\int_0^1 x^2 dx \u0026 \\int_0^1 x^2 \\,{\\rm d}x \\end{array}$$ 注意比较两个式子间 $dx$ 与 ${\\rm d} x$ 的不同。 使用 \\operatorname 命令也可以达到相同的效果。 ","date":"2022-02-20","objectID":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/:13:0","tags":["Markdown","Katex"],"title":"常用数学公式排版KaTex语法总结","uri":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["脚本"],"content":"14．大括号和行标的使用 在 \\left 和 \\right 之后加上要使用的括号来创建自动匹配高度的圆括号 ( )，方括号 [ ] 和花括号 \\{ \\}。 在每个公式末尾前使用 \\tag {行标} 来实现行标。 例子：注意：本博客主题的$\\KaTeX$使用\\\\{和\\\\}对左、右括号转义，如果是$MathJax$，使用\\{和\\}。 $$f\\left(\\left[\\frac{ 1+\\left\\\\{x,y\\right\\\\} }{ \\left(\\fracxy +\\fracyx \\right)(u+1)}+a \\right]^{3/2} \\right)\\tag{行标} $$ 显示： $$ f\\left( \\left[ \\frac{ 1+\\left\\{x,y\\right\\} }{ \\left( \\frac xy + \\frac yx \\right) (u+1) }+a \\right]^{3/2} \\right) \\tag {行标} $$ 如果你需要在不同的行显示对应括号，可以在每一行对应处使用 \\left. 或 \\right. 来放一个“不存在的括号”。 例子： $$\\begin{aligned} a=\u0026\\left(1+2+3+\\cdots\\right. \\\\\\\\\u0026\\cdots+\\left. \\infty-2+\\infty-1+\\infty\\right)\\end{aligned} $$ 显示： $$ \\begin{aligned} a=\u0026\\left(1+2+3+ \\cdots \\right. \\\\ \u0026\\cdots+\\left. \\infty-2+\\infty-1+\\infty\\right) \\end{aligned} $$ ","date":"2022-02-20","objectID":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/:14:0","tags":["Markdown","Katex"],"title":"常用数学公式排版KaTex语法总结","uri":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["脚本"],"content":"15．其它命令 ","date":"2022-02-20","objectID":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/:15:0","tags":["Markdown","Katex"],"title":"常用数学公式排版KaTex语法总结","uri":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["脚本"],"content":"(1)．添加注释文字 在 \\text {文字} 中仍可以使用 $公式$ 插入其它公式。 例子： $$f(n)=\\begin{cases} n/2, \u0026 \\text{if $n$ is even} \\\\\\\\3n+1, \u0026 \\text{if $n$ is odd} \\end{cases} $$ 显示： $$ f(n)= \\begin{cases} n/2, \u0026 \\text {if $n$ is even} \\\\ 3n+1, \u0026 \\text{if $n$ is odd} \\end{cases} $$ ","date":"2022-02-20","objectID":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/:15:1","tags":["Markdown","Katex"],"title":"常用数学公式排版KaTex语法总结","uri":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["脚本"],"content":"(2)．在字符间加入空格 有四种宽度的空格可以使用： \\\\,、\\\\;、\\quad 和 \\qquad，灵活使用 \\text{n个空格} 也可以在任意位置实现空格。 再次提醒：本博客主题的$\\KaTeX$ 是使用2个斜杠来转义，所以是\\\\;和\\\\,，如果是$MathJax$，则是一个斜杠，即\\, 和 \\;。 例子： $$A B \\quadVs \\quadA\\\\,B \\\\\\\\C D \\quadVs \\quadC\\\\;D \\\\\\\\E F \\quadVs \\quadE\\spaceF $$ 显示：(注意$AB$在公式中手动输入空格是没用的，需要上述的特殊字符作为空格)： $$ A B \\quad Vs \\quad A\\,B \\\\ C D \\quad Vs \\quad C\\;D \\\\ E F \\quad Vs \\quad E\\space F $$ 一些常见的公式单位可表达如下： 例子：(注意：本博客主题转义感叹号!也用了2个反斜杠，即\\\\!) $$\\mu_0=4\\pi\\times10^{-7} \\ \\left.\\mathrm{\\mathrm{T}\\\\!\\cdot\\\\!\\mathrm{m}}\\middle/\\mathrm{A}\\right.$$ $$180^\\circ=\\pi\\ \\mathrm{rad} $$ $$\\mathrm{N_A} =6.022\\times10^{23} \\ \\mathrm{mol}^{-1}$$ 显示： $$ \\mu_0=4\\pi\\times10^{-7} \\ \\left.\\mathrm{\\mathrm{T}\\!\\cdot\\!\\mathrm{m}}\\middle/\\mathrm{A}\\right. $$ $$ 180^\\circ=\\pi \\ \\mathrm{rad} $$ $$ \\mathrm{N_A} = 6.022\\times10^{23} \\ \\mathrm{mol}^{-1} $$ ","date":"2022-02-20","objectID":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/:15:2","tags":["Markdown","Katex"],"title":"常用数学公式排版KaTex语法总结","uri":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["脚本"],"content":"(3)．更改文字颜色 使用 \\color{颜色}{文字} 来更改特定的文字颜色。 更改文字颜色需要浏览器支持 ，如果浏览器不知道你所需的颜色，那么文字将被渲染为黑色。对于较旧的浏览器（HTML4 \u0026 CSS2），以下颜色是被支持的： 输入 显示 输入 显示 black $\\color{black}{text}$ grey $\\color{grey}{text}$ silver $\\color{silver}{text}$ white $\\color{white}{text}$ maroon $\\color{maroon}{text}$ red $\\color{red}{text}$ yellow $\\color{yellow}{text}$ lime $\\color{lime}{text}$ olive $\\color{olive}{text}$ green $\\color{green}{text}$ teal $\\color{teal}{text}$ auqa $\\color{auqa}{text}$ blue $\\color{blue}{text}$ navy $\\color{navy}{text}$ purple $\\color{purple}{text}$ fuchsia $\\color{fuchsia}{text}$ 对于较新的浏览器（HTML5 \u0026 CSS3），HEX 颜色将被支持： 输入 \\color {#rgb} {text} 来自定义更多的颜色，其中 #rgb 或 #rrggbb 的 r g b 可输入 0-9 和 a-f 来表示红色、绿色和蓝色的纯度（饱和度）。 例子： \\begin{array}{|rrrrrrrr|}\\hline \\verb+#000+ \u0026 \\color{#000}{text} \u0026 \u0026 \u0026 \\verb+#00F+ \u0026 \\color{#00F}{text} \u0026 \u0026 \\\\\\\\ \u0026 \u0026 \\verb+#0F0+ \u0026 \\color{#0F0}{text} \u0026 \u0026 \u0026 \\verb+#0FF+ \u0026 \\color{#0FF}{text} \\\\\\\\ \\verb+#F00+ \u0026 \\color{#F00}{text} \u0026 \u0026 \u0026 \\verb+#F0F+ \u0026 \\color{#F0F}{text} \u0026 \u0026 \\\\\\\\ \u0026 \u0026 \\verb+#FF0+ \u0026 \\color{#FF0}{text} \u0026 \u0026 \u0026 \\verb+#FFF+ \u0026 \\color{#FFF}{text} \\\\\\\\ \\hline\\end{array} 显示：$$ \\begin{array}{|rrrrrrrr|}\\hline \\verb+#000+ \u0026 \\color{#000}{text} \u0026 \u0026 \u0026 \\verb+#00F+ \u0026 \\color{#00F}{text} \u0026 \u0026 \\\\ \u0026 \u0026 \\verb+#0F0+ \u0026 \\color{#0F0}{text} \u0026 \u0026 \u0026 \\verb+#0FF+ \u0026 \\color{#0FF}{text} \\\\ \\verb+#F00+ \u0026 \\color{#F00}{text} \u0026 \u0026 \u0026 \\verb+#F0F+ \u0026 \\color{#F0F}{text} \u0026 \u0026 \\\\ \u0026 \u0026 \\verb+#FF0+ \u0026 \\color{#FF0}{text} \u0026 \u0026 \u0026 \\verb+#FFF+ \u0026 \\color{#FFF}{text} \\\\ \\hline\\end{array}$$ 例子： \\begin{array}{|rrrrrrrr|}\\hline \\verb+#000+ \u0026 \\color{#000}{text} \u0026 \\verb+#005+ \u0026 \\color{#005}{text} \u0026 \\verb+#00A+ \u0026 \\color{#00A}{text} \u0026 \\verb+#00F+ \u0026 \\color{#00F}{text} \\\\\\\\ \\verb+#500+ \u0026 \\color{#500}{text} \u0026 \\verb+#505+ \u0026 \\color{#505}{text} \u0026 \\verb+#50A+ \u0026 \\color{#50A}{text} \u0026 \\verb+#50F+ \u0026 \\color{#50F}{text} \\\\\\\\ \\verb+#A00+ \u0026 \\color{#A00}{text} \u0026 \\verb+#A05+ \u0026 \\color{#A05}{text} \u0026 \\verb+#A0A+ \u0026 \\color{#A0A}{text} \u0026 \\verb+#A0F+ \u0026 \\color{#A0F}{text} \\\\\\\\ \\verb+#F00+ \u0026 \\color{#F00}{text} \u0026 \\verb+#F05+ \u0026 \\color{#F05}{text} \u0026 \\verb+#F0A+ \u0026 \\color{#F0A}{text} \u0026 \\verb+#F0F+ \u0026 \\color{#F0F}{text} \\\\\\\\ \\hline \\verb+#080+ \u0026 \\color{#080}{text} \u0026 \\verb+#085+ \u0026 \\color{#085}{text} \u0026 \\verb+#08A+ \u0026 \\color{#08A}{text} \u0026 \\verb+#08F+ \u0026 \\color{#08F}{text} \\\\\\\\ \\verb+#580+ \u0026 \\color{#580}{text} \u0026 \\verb+#585+ \u0026 \\color{#585}{text} \u0026 \\verb+#58A+ \u0026 \\color{#58A}{text} \u0026 \\verb+#58F+ \u0026 \\color{#58F}{text} \\\\\\\\ \\verb+#A80+ \u0026 \\color{#A80}{text} \u0026 \\verb+#A85+ \u0026 \\color{#A85}{text} \u0026 \\verb+#A8A+ \u0026 \\color{#A8A}{text} \u0026 \\verb+#A8F+ \u0026 \\color{#A8F}{text} \\\\\\\\ \\verb+#F80+ \u0026 \\color{#F80}{text} \u0026 \\verb+#F85+ \u0026 \\color{#F85}{text} \u0026 \\verb+#F8A+ \u0026 \\color{#F8A}{text} \u0026 \\verb+#F8F+ \u0026 \\color{#F8F}{text} \\\\\\\\ \\hline \\verb+#0F0+ \u0026 \\color{#0F0}{text} \u0026 \\verb+#0F5+ \u0026 \\color{#0F5}{text} \u0026 \\verb+#0FA+ \u0026 \\color{#0FA}{text} \u0026 \\verb+#0FF+ \u0026 \\color{#0FF}{text} \\\\\\\\ \\verb+#5F0+ \u0026 \\color{#5F0}{text} \u0026 \\verb+#5F5+ \u0026 \\color{#5F5}{text} \u0026 \\verb+#5FA+ \u0026 \\color{#5FA}{text} \u0026 \\verb+#5FF+ \u0026 \\color{#5FF}{text} \\\\\\\\ \\verb+#AF0+ \u0026 \\color{#AF0}{text} \u0026 \\verb+#AF5+ \u0026 \\color{#AF5}{text} \u0026 \\verb+#AFA+ \u0026 \\color{#AFA}{text} \u0026 \\verb+#AFF+ \u0026 \\color{#AFF}{text} \\\\\\\\ \\verb+#FF0+ \u0026 \\color{#FF0}{text} \u0026 \\verb+#FF5+ \u0026 \\color{#FF5}{text} \u0026 \\verb+#FFA+ \u0026 \\color{#FFA}{text} \u0026 \\verb+#FFF+ \u0026 \\color{#FFF}{text} \\\\\\\\ \\hline\\end{array} 显示： $$\\begin{array}{|rrrrrrrr|}\\hline \\verb+#000+ \u0026 \\color{#000}{text} \u0026 \\verb+#005+ \u0026 \\color{#005}{text} \u0026 \\verb+#00A+ \u0026 \\color{#00A}{text} \u0026 \\verb+#00F+ \u0026 \\color{#00F}{text} \\\\ \\verb+#500+ \u0026 \\color{#500}{text} \u0026 \\verb+#505+ \u0026 \\color{#505}{text} \u0026 \\verb+#50A+ \u0026 \\color{#50A}{text} \u0026 \\verb+#50F+ \u0026 \\color{#50F}{text} \\\\ \\verb+#A00+ \u0026 \\color{#A00}{text} \u0026 \\verb+#A05+ \u0026 \\color{#A05}{text} \u0026 \\verb+#A0A+ \u0026 \\color{#A0A}{text} \u0026 \\verb+#A0F+ \u0026 \\color{#A0F}{text} \\\\ \\verb+#F00+ \u0026 \\color{#F00}{text} \u0026 \\verb+#F05+ \u0026 \\color{#F05}{text} \u0026 \\verb+#F0A+ \u0026 \\color{#F0A}{text} \u0026 \\verb+#F0F+ \u0026 \\color{#F0F}{text} \\\\ \\hline \\verb+#080+ \u0026 \\color{#080}{text} \u0026 \\verb+#085+ \u0026 \\color{#085}{text} \u0026 \\verb+#08A+ \u0026 \\color{#08A}{text} \u0026 \\verb+#08F+ \u0026 \\color{#08F}{text} \\\\ \\verb+#580+","date":"2022-02-20","objectID":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/:15:3","tags":["Markdown","Katex"],"title":"常用数学公式排版KaTex语法总结","uri":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["脚本"],"content":"1．输入无框矩阵 在开头使用 \\begin{matrix}，在结尾使用 \\end{matrix}，在中间插入矩阵元素，每个元素之间插入 \u0026 ，并在每行结尾处使用 \\\\ 。（不同于标准的$\\KaTeX$ ，本博客主题需要使用4个反斜杠换行，即\\\\\\\\） 使用矩阵时必须声明 $ 或 $$ 符号。 例子：(⚠️：这里换行用了4个反斜杠\\，因为本博客主题的$KaTeX$ 还需\\转义自身) $$\\begin{matrix} 1\u0026 x \u0026 x^2\\\\\\\\1\u0026 y \u0026 y^2\\\\\\\\1\u0026 z \u0026 z^2\\\\\\\\\\end{matrix} $$ 显示： $$ \\begin{matrix} 1 \u0026 x \u0026 x^2 \\\\ 1 \u0026 y \u0026 y^2 \\\\ 1 \u0026 z \u0026 z^2 \\\\ \\end{matrix} $$ ","date":"2022-02-20","objectID":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/:16:0","tags":["Markdown","Katex"],"title":"常用数学公式排版KaTex语法总结","uri":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["脚本"],"content":"2．输入边框矩阵 在开头将 matrix 替换为 pmatrix bmatrix Bmatrix vmatrix Vmatrix 。 例子： $\\begin{matrix} 1\u0026 2\\\\\\\\3\u0026 4\\\\\\\\\\end{matrix} $ $\\begin{pmatrix} 1\u0026 2\\\\\\\\3\u0026 4\\\\\\\\\\end{pmatrix} $ $\\begin{bmatrix} 1\u0026 2\\\\\\\\3\u0026 4\\\\\\\\\\end{bmatrix} $ $\\begin{Bmatrix} 1\u0026 2\\\\\\\\3\u0026 4\\\\\\\\\\end{Bmatrix} $ $\\begin{vmatrix} 1\u0026 2\\\\\\\\3\u0026 4\\\\\\\\\\end{vmatrix} $ $\\begin{Vmatrix} 1\u0026 2\\\\\\\\3\u0026 4\\\\\\\\\\end{Vmatrix} $ 显示： matrix pmatrix bmatrix Bmatrix vmatrix Vmatrix $ \\begin{matrix} 1 \u0026 2 \\\\ 3 \u0026 4 \\\\ \\end{matrix} $ $ \\begin{pmatrix} 1 \u0026 2 \\\\ 3 \u0026 4 \\\\ \\end{pmatrix} $ $ \\begin{bmatrix} 1 \u0026 2 \\\\ 3 \u0026 4 \\\\ \\end{bmatrix} $ $ \\begin{Bmatrix} 1 \u0026 2 \\\\ 3 \u0026 4 \\\\ \\end{Bmatrix} $ $ \\begin{vmatrix} 1 \u0026 2 \\\\ 3 \u0026 4 \\\\ \\end{vmatrix} $ $ \\begin{Vmatrix} 1 \u0026 2 \\\\ 3 \u0026 4 \\\\ \\end{Vmatrix} $ ","date":"2022-02-20","objectID":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/:17:0","tags":["Markdown","Katex"],"title":"常用数学公式排版KaTex语法总结","uri":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["脚本"],"content":"3．输入带省略符号的矩阵 使用 \\cdots $\\cdots$ , \\ddots $\\ddots$ , \\vdots $\\vdots$ 来输入省略符号。 例子： $$\\begin{pmatrix} 1\u0026 a_1\u0026 a_1^2\u0026 \\cdots\u0026 a_1^n \\\\\\\\1\u0026 a_2\u0026 a_2^2\u0026 \\cdots\u0026 a_2^n \\\\\\\\\\vdots\u0026 \\vdots\u0026 \\vdots\u0026 \\ddots\u0026 \\vdots\\\\\\\\1\u0026 a_m \u0026 a_m^2\u0026 \\cdots\u0026 a_m^n \\\\\\\\\\end{pmatrix} $$ 显示： $$ \\begin{pmatrix} 1 \u0026 a_1 \u0026 a_1^2 \u0026 \\cdots \u0026 a_1^n \\\\ 1 \u0026 a_2 \u0026 a_2^2 \u0026 \\cdots \u0026 a_2^n \\\\ \\vdots \u0026 \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ 1 \u0026 a_m \u0026 a_m^2 \u0026 \\cdots \u0026 a_m^n \\\\ \\end{pmatrix} $$ ","date":"2022-02-20","objectID":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/:18:0","tags":["Markdown","Katex"],"title":"常用数学公式排版KaTex语法总结","uri":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["脚本"],"content":"4．输入带分割符号的矩阵 详见\"数组使用参考\"。 例子： $$\\left[\\begin{array}{cc|c} 1\u0026 2\u0026 3\\\\\\\\4\u0026 5\u0026 6\\\\\\\\\\end{array} \\right]$$ 显示： $$ \\left[ \\begin{array}{cc|c} 1 \u0026 2 \u0026 3 \\\\ 4 \u0026 5 \u0026 6 \\\\ \\end{array} \\right] $$ 其中 cc|c 代表在一个三列矩阵中的第二和第三列之间插入分割线。 ","date":"2022-02-20","objectID":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/:19:0","tags":["Markdown","Katex"],"title":"常用数学公式排版KaTex语法总结","uri":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["脚本"],"content":"5．输入行中矩阵 若想在一行内显示矩阵， 使用\\bigl(\\begin{smallmatrix} ... \\end{smallmatrix}\\bigr)。 例子： 这是一个行中矩阵的示例 $\\bigl(\\begin{smallmatrix} a \u0026 b \\\\\\\\c \u0026 d \\end{smallmatrix}\\bigr)$ 。 显示： 这是一个行中矩阵的示例 $\\bigl(\\begin{smallmatrix} a \u0026 b \\\\ c \u0026 d \\end{smallmatrix}\\bigr)$ 。 三、方程式序列使用 ","date":"2022-02-20","objectID":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/:20:0","tags":["Markdown","Katex"],"title":"常用数学公式排版KaTex语法总结","uri":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["脚本"],"content":"1．输入一个方程组 可以使用 \\begin{array} … \\end{array} 和 \\left\\{ … \\right. 来创建一个方程组。 在等号=前加符号\u0026是为了让等号以后的内容对齐。 同样地，本博客主题是使用4个\\换行，标准$\\KaTeX$ 和$MathJax$都是使用2个\\换行，以及对符号{的转义\\\\{。 例子： $$\\left\\\\{ \\begin{array}{c} a_1x+b_1y+c_1z \u0026=d_1\\\\\\\\a_2x+b_2y+c_2z \u0026=d_2\\\\\\\\a_3x+b_3y+c_3z \u0026=d_3\\\\\\\\\\end{array} \\right. $$ 显示： $$ \\left\\{ \\begin{array}{c} a_1x+b_1y+c_1z \u0026=d_1 \\\\ a_2x+b_2y+c_2z \u0026=d_2 \\\\ a_3x+b_3y+c_3z \u0026=d_3 \\\\ \\end{array} \\right. $$ 或使用条件表达式组 \\begin{cases} … \\end{cases} 来实现相同效果： 例子： \\begin{cases} a_1x+b_1y+c_1z \u0026=d_1 \\\\\\\\ a_2x+b_2y+c_2z \u0026=d_2 \\\\\\\\ a_3x+b_3y+c_3z \u0026=d_3 \\\\\\\\ \\end{cases} 显示： $$\\begin{cases} a_1x+b_1y+c_1z \u0026=d_1 \\\\ a_2x+b_2y+c_2z \u0026=d_2 \\\\ a_3x+b_3y+c_3z \u0026=d_3 \\\\ \\end{cases}$$ ","date":"2022-02-20","objectID":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/:21:0","tags":["Markdown","Katex"],"title":"常用数学公式排版KaTex语法总结","uri":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["脚本"],"content":"2．输入一个方程式序列 人们经常想要一列等号对齐且居中的方程式序列。使用 \\begin{align}…\\end{align} 来创造一列方程式，其中在每行结尾处使用 \\\\ （本博客主题是\\\\\\\\）。使用方程式序列无需声明公式符号 $ 或 $$ 。 请注意 {align} 语句是自动编号的，使用 {aligned} 声明不自动编号。（详细资料可参考katex-environments） 例子： \\begin{aligned} \\sqrt{37} \u0026 = \\sqrt{\\frac{73^2-1}{12^2}} \\\\\\\\ \u0026 = \\sqrt{\\frac{73^2}{12^2}\\cdot\\frac{73^2-1}{73^2}} \\\\\\\\ \u0026 = \\sqrt{\\frac{73^2}{12^2}}\\sqrt{\\frac{73^2-1}{73^2}} \\\\\\\\ \u0026 = \\frac{73}{12}\\sqrt{1-\\frac{1}{73^2}} \\\\\\\\ \u0026 \\approx \\frac{73}{12}\\left(1-\\frac{1}{2\\cdot73^2}\\right) \\\\\\\\ \\end{aligned} 显示： $$\\begin{aligned} \\sqrt{37} \u0026 = \\sqrt{\\frac{73^2-1}{12^2}} \\\\ \u0026 = \\sqrt{\\frac{73^2}{12^2}\\cdot\\frac{73^2-1}{73^2}} \\\\ \u0026 = \\sqrt{\\frac{73^2}{12^2}}\\sqrt{\\frac{73^2-1}{73^2}} \\\\ \u0026 = \\frac{73}{12}\\sqrt{1-\\frac{1}{73^2}} \\\\ \u0026 \\approx \\frac{73}{12}\\left(1-\\frac{1}{2\\cdot73^2}\\right) \\\\ \\end{aligned}$$ ","date":"2022-02-20","objectID":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/:22:0","tags":["Markdown","Katex"],"title":"常用数学公式排版KaTex语法总结","uri":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["脚本"],"content":"3．方程式序列每一行注明原因 在 {align}或{aligned} 中后添加 \u0026 符号来自动对齐后面的内容，可灵活组合 \\text 和 \\tag 语句。\\tag 语句编号优先级高于自动编号。 例子： \\begin{aligned} v + w \u0026 = 0 \u0026 \\text{Given} \\\\\\\\ -w \u0026 = -w + 0 \u0026 \\text{additive identity} \\\\\\\\ -w + 0 \u0026 = -w + (v + w) \u0026 \\text{equations} \\\\\\\\ \\end{aligned} 显示： $$\\begin{aligned} v + w \u0026 = 0 \u0026 \\text{Given} \\\\ -w \u0026 = -w + 0 \u0026 \\text{additive identity} \\\\ -w + 0 \u0026 = -w + (v + w) \u0026 \\text{equations} \\\\ \\end{aligned}$$ 四、条件表达式组的使用 ","date":"2022-02-20","objectID":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/:23:0","tags":["Markdown","Katex"],"title":"常用数学公式排版KaTex语法总结","uri":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["脚本"],"content":"1．输入一个条件表达式组 使用 \\begin{cases}…\\end{cases} 来创造一组条件表达式，在每一行条件中插入 \u0026 来指定需要对齐的内容，并在每一行结尾处使用 \\\\。 例子： $$f(n)=\\begin{cases} n/2, \u0026 \\text{if $n$ is even} \\\\\\\\3n+1, \u0026 \\text{if $n$ is odd} \\\\\\\\\\end{cases} $$ 显示： $$ f(n) = \\begin{cases} n/2, \u0026\\text{if $n$ is even} \\\\ 3n+1, \u0026\\text{if $n$ is odd} \\\\ \\end{cases} $$ ","date":"2022-02-20","objectID":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/:24:0","tags":["Markdown","Katex"],"title":"常用数学公式排版KaTex语法总结","uri":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["脚本"],"content":"2．左侧对齐的条件表达式组 若想让文字在左侧对齐显示，则有如下方式： 例子：（注意：本博客主题的$\\KaTeX$ 需要\\\\}来表示\\}，$MathJax$ 可改为\\}） $$\\left. \\begin{array}{l} \\text{if $n$ is even:} \u0026 n/2\\\\\\\\\\text{if $n$ is odd:} \u0026 3n+1\\\\\\\\\\end{array} \\right\\\\} =f(n)$$ 显示： $$\\left. \\begin{array}{l} \\text{if $n$ is even:} \u0026 n/2 \\\\ \\text{if $n$ is odd:} \u0026 3n+1 \\\\ \\end{array} \\right\\} =f(n)$$ ","date":"2022-02-20","objectID":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/:25:0","tags":["Markdown","Katex"],"title":"常用数学公式排版KaTex语法总结","uri":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["脚本"],"content":"3．适配指定行高 在一些情况下，条件表达式中某些行的行高为非标准高度，此时使用 \\\\[2ex] 语句代替该行末尾的 \\\\ 来让编辑器适配2倍行高。 一个 [ex] 指一个 “X-Height”，即 x 字母高度。 例子1： 不适配2倍行高[2ex]： $$f(n)=\\begin{cases} \\frac{n}{2}, \u0026 \\text{if $n$ is even} \\\\\\\\3n+1, \u0026 \\text{if $n$ is odd} \\\\\\\\\\end{cases} $$ 例子1显示： $$ f(n) = \\begin{cases} \\frac{n}{2}, \u0026 \\text{if $n$ is even} \\\\ 3n+1, \u0026 \\text{if $n$ is odd} \\\\ \\end{cases} $$ 例子2: 适配2倍行高[2ex]： $$f(n)=\\begin{cases} \\frac{n}{2}, \u0026 \\text{if $n$ is even} \\\\\\\\[2ex]3n+1, \u0026 \\text{if $n$ is odd} \\\\\\\\\\end{cases} $$ 例子2显示： $$ f(n) = \\begin{cases} \\frac{n}{2}, \u0026 \\text{if $n$ is even} \\\\[2ex] 3n+1, \u0026 \\text{if $n$ is odd} \\\\ \\end{cases} $$ 可以根据情况指定多个 [ex]，如 [3ex]、[4ex] 等。 其实可以在任意换行处使用 \\\\[2ex] 语句，只要你觉得合适。 五、数组与表格使用 ","date":"2022-02-20","objectID":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/:26:0","tags":["Markdown","Katex"],"title":"常用数学公式排版KaTex语法总结","uri":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["脚本"],"content":"1．输入一个数组或表格 通常，一个格式化后的表格比单纯的文字或排版后的文字更具有可读性。 数组和表格均以 \\begin{array} 开头，并在其后定义列数及每一列的文本对齐属性，c l r 分别代表居中、左对齐及右对齐。若需要插入垂直分割线，在定义式中插入 | ，若要插入水平分割线，在下一行输入前插入 \\hline 。 与矩阵相似，每行元素间均须要插入 \u0026 ，每行元素以 \\\\ 结尾，最后以 \\ end{array} 结束数组。 使用单个数组或表格时无需声明 $ 或 $$ 符号。 例子： \\begin{array}{c|lcr} n \u0026 \\text{左对齐} \u0026 \\text{居中对齐} \u0026 \\text{右对齐} \\\\\\\\ \\hline 1 \u0026 0.24 \u0026 1 \u0026 125 \\\\\\\\ 2 \u0026 -1 \u0026 189 \u0026 -8 \\\\\\\\ 3 \u0026 -20 \u0026 2000 \u0026 1+10i \\\\\\\\ \\end{array} 显示： $$\\begin{array}{c|lcr} n \u0026 \\text{左对齐} \u0026 \\text{居中对齐} \u0026 \\text{右对齐} \\\\ \\hline 1 \u0026 0.24 \u0026 1 \u0026 125 \\\\ 2 \u0026 -1 \u0026 189 \u0026 -8 \\\\ 3 \u0026 -20 \u0026 2000 \u0026 1+10i \\\\ \\end{array}$$ ","date":"2022-02-20","objectID":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/:27:0","tags":["Markdown","Katex"],"title":"常用数学公式排版KaTex语法总结","uri":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["脚本"],"content":"2．输入一个嵌套的数组或表格 多个数组\\表格可 互相嵌套 并组成一组数组或表格。 使用嵌套前必须声明 $$ 符号。 例子： $$\\begin{array}{c} % 总表格 \\begin{array}{cc} % 第一行内分成两列 \\begin{array}{c|cccc} % 第一列\"最小值\"数组 \\text{min} \u0026 0\u0026 1\u0026 2\u0026 3\\\\\\\\\\hline0\u0026 0\u0026 0\u0026 0\u0026 0\\\\\\\\1\u0026 0\u0026 1\u0026 1\u0026 1\\\\\\\\2\u0026 0\u0026 1\u0026 2\u0026 2\\\\\\\\3\u0026 0\u0026 1\u0026 2\u0026 3\\\\\\\\\\end{array} \u0026 \\begin{array}{c|cccc} % 第二列\"最大值\"数组 \\text{max} \u0026 0\u0026 1\u0026 2\u0026 3\\\\\\\\\\hline0\u0026 0\u0026 1\u0026 2\u0026 3\\\\\\\\1\u0026 1\u0026 1\u0026 2\u0026 3\\\\\\\\2\u0026 2\u0026 2\u0026 2\u0026 3\\\\\\\\3\u0026 3\u0026 3\u0026 3\u0026 3\\\\\\\\\\end{array} \\end{array} % 第一行表格组结束 \\\\\\\\\\begin{array}{c|cccc} % 第二行 Delta 值数组 \\Delta\u0026 0\u0026 1\u0026 2\u0026 3\\\\\\\\\\hline0\u0026 0\u0026 1\u0026 2\u0026 3\\\\\\\\1\u0026 1\u0026 0\u0026 1\u0026 2\\\\\\\\2\u0026 2\u0026 1\u0026 0\u0026 1\\\\\\\\3\u0026 3\u0026 2\u0026 1\u0026 0\\\\\\\\\\end{array} % 第二行表格结束 \\end{array} % 总表格结束 $$ 显示： $$ \\begin{array}{c} % 总表格 \\begin{array}{cc} % 第一行内分成两列 \\begin{array}{c|cccc} % 第一列\"最小值\"数组 \\text{min} \u0026 0 \u0026 1 \u0026 2 \u0026 3 \\\\ \\hline 0 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \\\\ 1 \u0026 0 \u0026 1 \u0026 1 \u0026 1 \\\\ 2 \u0026 0 \u0026 1 \u0026 2 \u0026 2 \\\\ 3 \u0026 0 \u0026 1 \u0026 2 \u0026 3 \\\\ \\end{array} \u0026 \\begin{array}{c|cccc} % 第二列\"最大值\"数组 \\text{max} \u0026 0 \u0026 1 \u0026 2 \u0026 3 \\\\ \\hline 0 \u0026 0 \u0026 1 \u0026 2 \u0026 3 \\\\ 1 \u0026 1 \u0026 1 \u0026 2 \u0026 3 \\\\ 2 \u0026 2 \u0026 2 \u0026 2 \u0026 3 \\\\ 3 \u0026 3 \u0026 3 \u0026 3 \u0026 3 \\\\ \\end{array} \\end{array} % 第一行表格组结束 \\\\ \\begin{array}{c|cccc} % 第二行 Delta 值数组 \\Delta \u0026 0 \u0026 1 \u0026 2 \u0026 3 \\\\ \\hline 0 \u0026 0 \u0026 1 \u0026 2 \u0026 3 \\\\ 1 \u0026 1 \u0026 0 \u0026 1 \u0026 2 \\\\ 2 \u0026 2 \u0026 1 \u0026 0 \u0026 1 \\\\ 3 \u0026 3 \u0026 2 \u0026 1 \u0026 0 \\\\ \\end{array} % 第二行表格结束 \\end{array} % 总表格结束 $$ 六、连分数使用 ","date":"2022-02-20","objectID":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/:28:0","tags":["Markdown","Katex"],"title":"常用数学公式排版KaTex语法总结","uri":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["脚本"],"content":"1．输入一个连分数 就像输入分式时使用 \\frac 一样，使用 \\cfrac 来创建一个连分数。 例子： $$x =a_0+\\cfrac{1^2}{a_1+\\cfrac{2^2}{a_2+\\cfrac{3^2}{a_3+\\cfrac{4^4}{a_4+\\cdots} } } } $$ 显示： $$ x = a_0 + \\cfrac{1^2}{a_1 + \\cfrac{2^2}{a_2 + \\cfrac{3^2}{a_3 + \\cfrac{4^4}{a_4 + \\cdots } } } } $$ 不要使用普通的 \\frac 或 \\over 来生成连分数，这样会看起来很恶心。 反例： $$x =a_0+\\frac{1^2}{a_1+\\frac{2^2}{a_2+\\frac{3^2}{a_3+\\frac{4^4}{a_4+\\cdots} } } } $$ 显示： $$ x = a_0 + \\frac{1^2}{a_1 + \\frac{2^2}{a_2 + \\frac{3^2}{a_3 + \\frac{4^4}{a_4 + \\cdots } } } } $$ 当然，你可以使用 \\frac 来表达连分数的紧缩记法。 例子： $$x =a_0+\\frac{1^2}{a_1+} \\frac{2^2}{a_2+} \\frac{3^2}{a_3+} \\frac{4^4}{a_4+} \\cdots$$ 显示： $$ x = a_0 + \\frac{1^2}{a_1 +} \\frac{2^2}{a_2 +} \\frac{3^2}{a_3 +} \\frac{4^4}{a_4 +} \\cdots $$ 连分数通常都太大以至于不易排版，所以建议在连分数前后声明 $$ 符号，或使用像 [a0,a1,a2,a3,…] 一样的紧缩记法。 七、其他注意事项 现在指出的小问题并不会影响公式的正确显示，但能让它们看起来明显更好看。 在以 e 为底的指数函数、极限和积分中尽量不要使用 \\frac 符号; $\\Longrightarrow$ 它会使整段函数看起来很奇怪并可能产生歧义，因此它在专业数学排版中不会被采用。 可试着横着写这些分式，中间使用斜线间隔 / （用斜线代替分数线）。 例子： \\begin{array}{cc} \\mathrm{Bad} \u0026 \\mathrm{Better} \\\\\\\\ \\hline \\\\\\\\ \\large e^{i\\frac{\\pi}2} \\quad e^{\\frac{i\\pi}2}\u0026 \\large e^{i\\pi/2} \\\\\\\\[2ex] \\int_{-\\frac\\pi2}^\\frac\\pi2 \\sin x\\\\,dx \u0026 \\int_{-\\pi/2}^{\\pi/2}\\sin x\\\\,dx \\\\\\\\ \\end{array} 显示： $$\\begin{array}{cc} \\mathrm{Bad} \u0026 \\mathrm{Better} \\\\ \\hline \\\\ \\large e^{i\\frac{\\pi}2} \\quad e^{\\frac{i\\pi}2}\u0026 \\large e^{i\\pi/2} \\\\[2ex] \\int_{-\\frac\\pi2}^\\frac\\pi2 \\sin x\\,dx \u0026 \\int_{-\\pi/2}^{\\pi/2}\\sin x\\,dx \\\\ \\end{array}$$ 使用 | 符号作为分隔符时会产生错误的间距，因此在需要分隔时最好使用 \\mid 来代替它; 例子: \\begin{array}{cc} \\mathrm{Bad} \u0026 \\mathrm{Better} \\\\\\\\ \\hline \\\\\\\\ \\{x|x^2\\in\\Bbb Z\\} \u0026 \\{x\\mid x^2\\in\\Bbb Z\\} \\\\\\\\ \\end{array} 显示： $$\\begin{array}{cc} \\mathrm{Bad} \u0026 \\mathrm{Better} \\\\ \\hline \\\\ {x|x^2\\in\\Bbb Z} \u0026 {x\\mid x^2\\in\\Bbb Z} \\\\ \\end{array}$$ 使用多重积分符号时，不要多次使用 \\int 来声明，直接使用 \\iint 来表示二重积分，使用 \\iiint 来表示三重积分; 个人补充：在表示面积分和体积分时下标建议使用 \\boldsymbol{S} 和 \\boldsymbol{V} 符号； 例子： \\begin{array}{cc} \\mathrm{Bad} \u0026 \\mathrm{Better} \\\\\\\\ \\hline \\\\\\\\ \\int\\int_S f(x)\\\\,dy\\\\,dx \u0026 \\iint_{\\boldsymbol{S}} f(x)\\\\,{\\rm d}y\\\\,{\\rm d}x \\\\\\\\ \\int\\int\\int_V f(x)\\\\,dz\\\\,dy\\\\,dx \u0026 \\iiint_{\\boldsymbol{V}} f(x)\\\\,{\\rm d}z\\\\,{\\rm d}y\\\\,{\\rm d}x \\\\\\\\[3ex] \\hline \\\\\\\\ \\end{array} 显示： $$ \\begin{array}{cc} \\mathrm{Bad} \u0026 \\mathrm{Better} \\\\ \\hline \\\\ \\int\\int_S f(x)\\,dy\\,dx \u0026 \\iint_{\\boldsymbol{S}} f(x)\\,{\\rm d}y\\,{\\rm d}x \\\\ \\int\\int\\int_V f(x)\\,dz\\,dy\\,dx \u0026 \\iiint_{\\boldsymbol{V}} f(x)\\,{\\rm d}z\\,{\\rm d}y\\,{\\rm d}x \\\\[3ex] \\hline \\\\ \\end{array} $$ 使用多重积分时，在被积变量后加入 \\, 或\\space（或在微分符号 ${\\rm d}$ 之前）插入一个小的间距; 否则各种被积变量将会挤成一团。注意比较 ${\\rm d}z{\\rm d} y{\\rm d} x$ 的不同。 例子： \\begin{array}{cc} \\mathrm{Bad} \u0026 \\mathrm{Better} \\\\\\\\ \\hline \\\\\\\\ \\iiint_V f(x){\\rm d}z {\\rm d}y {\\rm d}x \u0026 \\iiint_{\\boldsymbol{V}} f(x)\\\\,{\\rm d}z\\\\,{\\rm d}y\\\\,{\\rm d}x \\\\\\\\ \\end{array} 显示： $$ \\begin{array}{cc} \\mathrm{Bad} \u0026 \\mathrm{Better} \\\\ \\hline \\\\ \\iiint_V f(x){\\rm d}z {\\rm d}y {\\rm d}x \u0026 \\iiint_{\\boldsymbol{V}} f(x)\\,{\\rm d}z\\,{\\rm d}y\\,{\\rm d}x \\\\ \\end{array} $$ 参考链接 数学公式Cmd-Markdown参考 MathJax basic tutorial and quick reference 清华镜像站Mannual-PDF：A Gentle Introduction to TEX Katex官方：Supported Table Katex官方：Supported Function Katex官方：在线语法测试 ","date":"2022-02-20","objectID":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/:29:0","tags":["Markdown","Katex"],"title":"常用数学公式排版KaTex语法总结","uri":"/2022/02/18_%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8Fkatex%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":["程序设计"],"content":"摘要：Effective C++(第三版)内容第五、第六章的总结","date":"2022-02-14","objectID":"/2022/02/14_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E4%B8%89/","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(三)","uri":"/2022/02/14_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E4%B8%89/"},{"categories":["程序设计"],"content":"前言 这本C++经典著作，本人看的是中文版，侯捷老师翻译的，精读分析并实践推敲后，整理成博客记录下来，非常适合有一定开发经验的朋友们阅读。 Effective-C++总结系列分为四部分，本文为第三部分，涉及原书第5~6章，内容范围Rule26~40。为方便书写，Rule26简写为R26。 Effective-C++系列List 本博客站点系列内容如下： 💡 Effective C++(第3版)精读总结(一) 💡 Effective C++(第3版)精读总结(二) 💡 Effective C++(第3版)精读总结(三) 💡 Effective C++(第3版)精读总结(四) 由于原书在C++11之前写成，有些现代C++特性不会提及，所以会根据本人开发经验新增一些个人感悟👉By the way环节。 CH5. 实现 ","date":"2022-02-14","objectID":"/2022/02/14_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E4%B8%89/:0:0","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(三)","uri":"/2022/02/14_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E4%B8%89/"},{"categories":["程序设计"],"content":"R26 尽可能延后变量定义式的出现时间 尽可能延后变量定义式的出现，可增加程序清晰度和效率 定义后，在使用前就遭遇抛异常 这种情况，如果是定义了对象ObjectA a，便白白地浪费了对象a的构造和析构成本。 不只是延后变量定义到使用时，而是尽量延后到能给它初值时 结合上述第1，2点，考虑以下代码的合理性： std::string encryptPassword(const std::string\u0026 password){ if(password.length() \u003c 8){ throw std::logic_error(\"Password is too short\"); }// 考虑1：在异常之后定义变量 std::string encrypted(password);//考虑2：定义延后至变量能赋初值的时机 encrypt(encrypted); return encrypted; } 思考变量定义是否该在循环内 方法A：定义于循环外 方法B：定义于循环内 Widget w; for(int i = 0 ; i for(int i = 0 ; i 1个构造+1个析构+n个赋值 n个构造+n个析构 究竟是A还是B方法好，取决于 一个赋值成本和一组构造+析构成本，这2者之间，如果是赋值成本低，那么A更好，否则B更好。 ","date":"2022-02-14","objectID":"/2022/02/14_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E4%B8%89/:1:0","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(三)","uri":"/2022/02/14_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E4%B8%89/"},{"categories":["程序设计"],"content":"R27 尽量少做转型动作 通常的转型是可能会这样写：函数风格的int(expression)或者C风格的(int)expression，这都被成为“旧式转型 ”。 在C++中，有4种新式转型操作符： const_cast (expression) 作用是移除变量的常量性(cast away the constness)，是唯一有此能力的操作符。 dynamic_cast(expression) 作用是“安全向下转型”(safe downcasting)，决定某个对象是否属于某继承体系。耗费重大运行成本（原因：需要查询RTTI信息，而且不同编译器实现的方法和效率有所不同）。 reinterpret_cast(expression) 执行低级转型，实际结果取决于编译器，移植性差。（比如int* 转为int）要清楚自己在做什么，慎用。 static_cast(expression) 强迫隐式类型转换，代替C风格的\"旧式转换\"。也可以给变量加上const特性。 新式转换的好处：很容易在代码找到“类型系统在何处转变或破坏”；对const特性的严控，让类型系统更健壮。 派生类里直接调用基类成员函数时，不要用转型 class SpecialWindow:public Window{ public: virtual void onResize(){ Window::onResize();//不要使用 static_cast\u003cWindow\u003e(*this).onResize(); } }; 关于dynamic_cast需要注意的 如何替代和避免 一般是持有一个Base *pBase，但是指向的是DerivedObj，于是转型为pDerived。可以这样修改： 修改设计，窄化类型，持有一个pDerived即可；或者将想做的事放到虚函数中，利用多态去完成。 避免串联 避免下方这样的代码，一连串的dynamic_cast： class Window{ ... }; // 定义子类 SpecialWindow1,SpecalWindow2,SpecialWindow3 Window* winPtr; // 省略winPtr的其他操作 ... if(SpecialWindow1 *psw1 = dynamic_cast\u003cSpecialWindow1*\u003e(winPtr)){ ... } else if(SpecialWindow2 *psw2 = dynamic_cast\u003cSpecialWindow2*\u003e(winPtr)){ ... } else if(SpecialWindow3 *psw3 = dynamic_cast\u003cSpecialWindow3*\u003e(winPtr)){ ... } 这样的代码又大又慢，每次继承体系有所改变，代码就需要重新检阅判断。这样的代码应该用“基于virtual函数调用”取代它。 By the way 自 C++11 起，针对智能指针 shared_ptr 的转型，推出了另外 4 个模版函数： std::static_pointer_cast 函数的原型声明为： template\u003c class T, class U \u003e std::shared_ptr\u003cT\u003e static_pointer_cast( const std::shared_ptr\u003cU\u003e\u0026 r ) noexcept; 含义以及应用场景与 static_cast 类似，比如子类型指针转为父类型： auto basePtr = std::make_shared\u003cBase\u003e(); auto derivedPtr = std::make_shared\u003cDerived\u003e(); basePtr = std::static_pointer_cast\u003cBase\u003e(derivedPtr); 或许我们会有疑问，是否有必要用这个函数进行转型呢，如下实现不是一样的吗： basePtr = std::shared_ptr\u003cBase\u003e(static_cast\u003cBase*\u003e(derivedPtr.get())); 🤔 当然不一样，static_cast\u003cT*\u003e((U*)nullptr)是未定义行为，而且就语法描述上来看，哪个更简洁不言自明。 另外，自 C++20 起支持右值引用，也就是如下形式： template\u003c class T, class U \u003e std::shared_ptr\u003cT\u003e static_pointer_cast( std::shared_ptr\u003cU\u003e\u0026\u0026 r ) noexcept; std::dynamic_pointer_cast 含义以及应用场景与 dynamic_cast 类似，用法传参与 std::static_pointer_cast 类似，且自 C++20 起支持右值引用，不赘述。 std::const_pointer_cast：与前 2 者类似，不赘述。 std::reinterpret_pointer_cast：与前 3 者类似，不赘述。 ","date":"2022-02-14","objectID":"/2022/02/14_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E4%B8%89/:2:0","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(三)","uri":"/2022/02/14_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E4%B8%89/"},{"categories":["程序设计"],"content":"R28 避免返回handles指向对象内部成分 这里的handles（号码牌）包括指向对象内部的指针、迭代器、引用。 以下讲述当返回对象内部的handles时，存在的2个问题： 可能会破坏封装性 考虑一个场景：public函数返回一个private成员的非const引用，就让外界有了修改private的机会，破坏了封装性。 此时，需要将非const引用改为const引用，只读属性。 struct Pixel{ float r,g,b; } class Image{ public: //注意：后面这const只保证成员变量vPixPtrs_不改 Pixel\u0026 GetThePixel(int idx) const{ return vPixPtrs_[i];}//隐患：其实外部调用者仍能直接修改Pixel的rgb值 // 上一句的返回值应该改为 \"const Pixel\u0026\" private: std::vector\u003cstd::shared_ptr\u003cPixel\u003e\u003e vPixPtrs_; } 可能会引起“空悬handles” 即使用const解决了封装性的问题，因为很容易出现“handles比其所指对象更长寿”，可能存在对象已析构，但handles还留存的问题。尤其是临时变量的析构，不太容易察觉。 class SceneGraph{ ... }; const Image CaptureImage(const SceneGraph\u0026 graph); //那么调用方可能会这样使用 SceneGraph Grap; //下面这句之后，Image临时对象被销毁，pPix指向一个不存在的对象 const Pixel *pPix = \u0026(CaptureImage(Grap).GetThePixel(0)); 注意，CaptureImage的确能返回一个临时Image对象，能成功调用GetThePixel，但这句结束后，临时对象立马会被销毁，造成空悬现象，或叫虚吊(dangling) ！ ","date":"2022-02-14","objectID":"/2022/02/14_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E4%B8%89/:3:0","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(三)","uri":"/2022/02/14_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E4%B8%89/"},{"categories":["程序设计"],"content":"R29 为“异常安全”而努力是值得的 “异常安全”是指，当异常抛出时，代码依然能做到如下2点： 不泄露任何资源 包括内存资源，锁资源。 不允许数据败坏 不会因为异常而导致空悬指针等未定义行为。 考虑下方的示例代码，（如果new Image抛std::bad_alloc异常）则会同时违背了上述2条： class PrettyMenu{ private: Mutex mutex_; //互斥器 Image* bgImage_ = nullptr; int imageChangeCnt_ = 0; public: void PrettyMenu::changeBackground(std::ifstream\u0026 imgSrc){ lock(\u0026mutex_);// 这个可以改为RAII的锁，来保证异常安全 delete bgImage_; ++imageChangeCnt_; //这里new Image抛异常，导致无法解锁；且bgImage_指向资源已经释放，空悬指针 bgImage_ = new Image(imageSrc_); unlock(\u0026mutex_); } }; ","date":"2022-02-14","objectID":"/2022/02/14_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E4%B8%89/:4:0","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(三)","uri":"/2022/02/14_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E4%B8%89/"},{"categories":["程序设计"],"content":"异常安全的3个等级 异常安全的函数，有3个等级的异常安全保证，会满足三者之一： 基本承诺 如果异常被抛出，程序内的任何事务仍然保持在有效状态下，也没有任何数据败坏。比如上例中如果抛异常，会另外添加实现，使bgImage_持有某个默认图像，或保持原值，让程序继续有效运行。 强烈保证 如果异常被抛出，程序状态不改变。这样的函数要么成功，要么退回到执行前的状态。 上述案例则应该会被修改成如下形式： class PrettyMenu{ private: std::shared_ptr\u003cImage\u003e bgImage_; //RAII避免了异常发生时的资源泄漏和数据败坏 //... 省略其他成员 public: void PrettyMenu::changeBackground(std::ifstream\u0026 imgSrc){ CLock ml(\u0026mutex_);//RAII封装的Lock类，详细可参考 阅读总结(二)-Rule14 bgImage_.reset(new Image(imgSrc));//若new失败，则不会reset ++imageChangeCnt_;//把事情做完再++count } }; 不抛异常 在原书中，这个“No Throw”不是绝对不抛异常，而是一旦意外抛异常，就会调用unexpected函数进而abort（例如int doSomething() throw();//空白的异常明细）。 By the way 原书中例子的 throw() 在不同编译器表现不一致，现在已经 不推荐使用。 更详细资料可参考A Pragmatic Look at Exception Specifications和Should I use an exception specifier in C++ 在C++11中，有了更可靠有效的关键字noexcept，使用也很简单，有操作符和异常提示符两种作用，下方展示简单用法： void f() noexcept; // 函数 f() 不会抛出 void (*fp)() noexcept(false); // fp 指向可能会抛出的函数 void g(void pfa() noexcept); // g 接收指向不会抛出的函数的指针 // typedef int (*pf)() noexcept; // 错误 更详细的noexcept介绍可以访问cppreference：noexcept操作符和cppreference：noexcept异常说明符 ","date":"2022-02-14","objectID":"/2022/02/14_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E4%B8%89/:4:1","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(三)","uri":"/2022/02/14_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E4%B8%89/"},{"categories":["程序设计"],"content":"使用copy-and-swap保障异常安全 copy-and-swap技术：先拷贝一份想修改的对象，等修改彻底完成后（过程中不抛异常），再与原对象交换。 为了更形象展示这一过程，使用pIml手法对bgImage_封装一下： struct ImgPimpl{ //选用struct而非Class：方便；最后被private成员形式使用，封装性不用担心 std::shared_ptr\u003cImage\u003e bgImage_; int imageChangeCnt_ = 0; }; 那么PrettyMenu类可以改为如下： class PrettyMenu{ private: Mutex mutex_; std::shared_ptr\u003cImgPimpl\u003e pImpl_; public: //构造略 void PrettyMenu::changeBackground(std::ifstream\u0026 imgSrc){ using std::swap; //参考 阅读总结(二)-Rule25 CLock ml(\u0026mutex_);//RAII封装的Lock类，详细可参考总结(二)-Rule14 std::shared_ptr\u003cImgPimpl\u003e pNewCopy(new ImgPimpl(*pImpl_)); pNewCopy-\u003ebgImage_.reset(new Image(imgSrc)); //修改副本 ++pNewCopy-\u003eimageChangeCnt_; swap(pImpl_,pNewCopy);//改完之后swap } }; ","date":"2022-02-14","objectID":"/2022/02/14_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E4%B8%89/:4:2","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(三)","uri":"/2022/02/14_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E4%B8%89/"},{"categories":["程序设计"],"content":"异常安全的连带影响(side effects) 函数提供的“异常安全保证等级”只取决于其调用的各个子函数的“最不安全者”。 考虑以下函数SomeFunc代码： void SomeFunc{ ... // 对local状态做一份副本 f1(); f2(); ... //将修改后的状态置换过来 } 分析：显然copy-and-swap在尽力强烈保证异常安全，但是，f1或者f2的异常安全如果比较低，那么可能需要单独对f1，f2进行copy-and-swap，来尝试保证“强烈异常安全”；即使如此，如果f1能成功做了修改，但是f2修改失败了并回退，那么f1、f2整体看起来还是“改了一部分”。 这也告诫我们，如果引入了异常不安全的旧代码，那么这种特性会波及其他代码。 就设计者而言，只能根据实际情况，尽可能保证“异常安全”，选择3个异常安全等级之一实施。 ","date":"2022-02-14","objectID":"/2022/02/14_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E4%B8%89/:4:3","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(三)","uri":"/2022/02/14_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E4%B8%89/"},{"categories":["程序设计"],"content":"R30 透彻了解inline的里里外外 inline是C++的关键字，表示内联函数。直接在对应位置展开代码，免去函数调用的开销，难以避免 “代码膨胀”问题。 使用inline时应该注意以下问题： inline只是对编译器的申请 inline只是对编译器的申请/建议，不是强制命令，编译器有权利 对其认为不适合inline的函数拒绝inline。 （原书说：如果编译器拒绝，通常它会给出warning信息。实际本人实测VS2017没看到） inline有2种申请方式 ： 在函数定义 时使用关键字inline显式强调 实现在Class内的成员函数或friend函数，属于隐式inline inline和Template没有任何必然联系 虽然有不少简短的Template函数是带有inline（例如下方的std::max），但不是必然为之，两者没有因果关系。 template\u003ctypename T\u003e inline const T\u0026 std::max(const T\u0026 a, const T\u0026 b){ //可以申请inline，但不是必须申请 return a \u003c b ? b : a; } 编译器拒绝复杂函数进行inline 复杂函数的inline会带来较严重的“代码膨胀”问题，并且可能会更慢，因为增加了运行时的“额外换页”行为，降低了指令cache命中率。 inline函数内不要出现循环或递归 虚函数也不适合做inline 因为inline是编译期间决定的事，而虚函数是运行时决定的事，两者就不是同一个场景的。 构造/析构函数也不适合做inline ​ 编译器可能会在构造/析构函数内部做精妙复杂的异常处理；以及在继承体系下，Base类函数体到处inline膨胀。 以函数指针形式的调用通常不能inline 对绝大多数编译器而言，是否inline是compile阶段决定的事情，少数编译器放到了link阶段。 讨论大多数情况：需要在编译时得知inline的本体，而函数指针办不到，示例代码如下： inline void f() {...} //假设编译器有意愿inline “对f的调用” void (* pf)() = f;//pf 执行f ... f(); //这个调用将被inlined，因为是个正常调用 pf(); //这个很可能不被inlined 过度inline对调试和发布带来困难 inline是代码嵌入与展开，而非函数调用，所以某些编译器不支持inline的单步Debug（就像宏展开一样不支持调试）；另外，inline只要已修改，涉及调用它的代码全都要编译，如果是non-inline则可能只需要重新link即可。 ","date":"2022-02-14","objectID":"/2022/02/14_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E4%B8%89/:5:0","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(三)","uri":"/2022/02/14_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E4%B8%89/"},{"categories":["程序设计"],"content":"R31 将文件间的编译依赖关系降至最低 C++的Class定义式包括了成员变量，假设某成员变量是类对象ClassObjA a，如果ClassObjA类的内部实现发生了改变（哪怕这个ClassObjA.h内只在某处加了一个空格 ），那么include了ClassObjA.h的所有.h文件.cpp文件都会重新编译。 👆这就是由“编译依赖”关系带来的问题。 使用 PIMPL 手法(pointer to implementation)可以很好地分离声明和定义： //Person.h文件 不需要include \"PersonImpl.h\"和\"BirthDay.h\" class PersonImpl; class BirthDay;// 前置声明代替include class Person { public:// 构造函数这里放实现无所谓，因为是函数指针，不需知道PersonImpl本体实现 Person(const std::shared_ptr\u003cPersonImpl\u003e\u0026 pImpl);//构造函数的实现也放到cpp里去 const BirthDay\u0026 GetBirthDay();// 注意：这里只声明，把实现部分放到cpp里 std::string GetName();//实现细节由pImpl_转发实现 private: std::shared_ptr\u003cPersonImpl\u003e pImpl_; }; //Person.cpp文件 #include \"PersonImpl.h\" //在\"PersonImpl.h\"文件内include那个\"BirthDay.h\"#include \"Person.h\" 注意：Impl用法，相关的头文件里不要放置任何函数实现代码 。 上述做法可以让使用Person类的客户不需要再关心PersonImpl以及BirthDay的实现细节了，做到了“接口与实现分离”，关键点在于把“定义的依赖性” 换成 $\\Rightarrow$ “声明的依赖性”。 这里突出了如何最小化编译依赖性的本质：让头文件尽可能自我满足，如果不行，也要依赖于其他文件的声明式而非定义式。 具体到设计策略上，有以下几种做法： 如果能用object references 或 object pointers完成任务，就别用objects 如果要定义某类型的objects，就要使用定义式，指针和应用则可以只用声明式。 尽量以class声明式替换class定义式 函数声明种的Class类型可以只用声明式，即使以by-object-value形式传值也是如此。 为声明式和定义式提供不同的文件 比如Date类，分为只包含声明式的\"Datefwd.h\"和包含定义式的\"Date.h\"，那么使用时用声明式头文件代替前置声明，在需要应用代码client.cpp里include定义式头文件。这种方式在标准库里采用较多，参考\u003ciosfwd\u003e和\u003csstream\u003e,\u003cfstream\u003e,\u003cstreambuf\u003e等。 By the way C/C++可以使用编译器预处理指令#pragma message，打印出该文件是否参与此次编译，以及参与编译时被哪个文件所依赖。 //比如可以在 testEffective.h 文件内加上这句，就能在编译输出信息里看到打印信息，观察到依赖关系 #pragma message(\"testEffective.h 参与重新编译\") //还可以用于测试某些宏是否真的生效，有时IDE的高亮显示不准确而令人生疑。 关于头文件include的其他编写规范，可以参考：Google-C++风格指南：1.头文件 使用 Interface Class 也能做到接口和实现的真正分离： 这种方式常见于输出动态库给到客户使用，客户能见到接口定义和使用，但无法看到内部实现。 用法较为常见，不赘述，直接show-code： //VirtualPerson.h //和 lib文件一起提供给到客户 class VirtualPerson { public: //create的返回值还可以根据需求，换成RAII的智能指针 static VirtualPerson * create(int level, int salary); virtual int Level() = 0; virtual int Salary() = 0; virtual ~VirtualPerson();// avoid memory leak }; //VirtualPerson.cpp //源码不提供给客户，而是编译好的二进制 lib文件 VirtualPerson* VirtualPerson::create(int level, int salary) { if (level == 3) { //工厂方法，还可以生成其他子类 return new Engineer(level, salary); } return nullptr; } VirtualPerson::~VirtualPerson() { } // Engineer.h //Engineer也是参与编译到 lib文件中 class Engineer: public VirtualPerson { public: Engineer(int level,int salary); virtual int Level() ; virtual int Salary() ; private: int level_ = 3; int salary_ = 0; }; CH6. 继承与面向对象设计 ","date":"2022-02-14","objectID":"/2022/02/14_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E4%B8%89/:6:0","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(三)","uri":"/2022/02/14_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E4%B8%89/"},{"categories":["程序设计"],"content":"R32 确定你的public继承塑造出is-a关系 原书标题：Make sure public inheritance models “is-a”. 侯捷老师翻译为“塑模”，我个人更愿意称为“塑造”。 “public继承”意味着is-a is-a，即“是一种”，就是说，适用于Base Class身上的每一件事，也一定适用于Derived Class身上。 By the way 面向设计对象的设计有著名的5大原则， SOLID 原则，每个字母分别代表一种原则： S–单一责任原则(SRP) –Single Responsibility Principle O–开放封闭原则(OCP)– Open-Closed Principle L–里式替换原则(LSP)– Liskov Substitution Principle I –- 接口分离原则(ISP)–Interface Segregation Principle D–-依赖倒置原则(DIP)– Dependency Inversion Principle 更详细的叙述可以参考：腾讯云：SOLID原则 本节条款的中心思想即里氏替换原则 ：一个对象出现的地方都可以由其子类代替并且不会出错。 继承关系有时候听起来很好理解，比如 Class Student: public Person 理所应当，但有时也会导致误解。比如企鹅属于鸟类，但企鹅不会飞，那么基类Bird::Fly方法又当如何处理，下方满足设计意图： class Bird{ //... 不声明Fly()方法 }; class FylingBird:public Bird{ public: virtual void Fly(); }; class Penguin: public Bird{ //... 不声明Fly()方法 }; // 注：如果Bird类以及子类都不考虑Fly()方法，那么Penguin直接继承于Bird即可 还有另一种场景，父类和子类对于同一个方法的数据修改规则不同，导致了继承体系的缺陷。 比如Class Square:public Rectangle $\\rightarrow$ 正方形继承于长方形，但是考虑这样一个类外方法: void makeBigger(Rectangle\u0026 r){ //普通非成员函数 int oldHeight = r.height(); r.setWidth(r.width() + 10);//如果r是Squqre，可能内部自动就长宽一起变了 assert(r.height() == oldHeight);//这个assert对于正方形就不合适了,贸然去除又违背设计本意 } 应对上述这样的情况，就需要修改设计或修改继承体系了。 ","date":"2022-02-14","objectID":"/2022/02/14_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E4%B8%89/:7:0","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(三)","uri":"/2022/02/14_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E4%B8%89/"},{"categories":["程序设计"],"content":"R33 避免遮掩由继承得来的名称 首先，什么是名称的遮掩，通俗地说，是指由于作用域不同带来的变量名覆盖。考虑下方代码： int x = 10; void someFunc(){ double x = 0.1; std::cout\u003c\u003c\"x is\" \u003c\u003c x \u003c\u003c std::endl; // local作用域找到了x，直接覆盖全局的x，输出0.1 } 那么如果将继承体系考虑进来呢：Derived的作用域会覆盖Base的作用域，包括virtual和non-virtual。考虑下方代码： class Base { public: virtual void mf1() = 0; virtual void mf1(int x) { std::cout \u003c\u003c \"Base::mf1():x =\" \u003c\u003c x \u003c\u003c std::endl; } virtual void mf2() { std::cout \u003c\u003c \"Base::mf2()\\n\"; } void mf3() { std::cout \u003c\u003c \"Base::mf3()\\n\"; } void mf3(int x) { std::cout \u003c\u003c \"Base::mf3():x =\" \u003c\u003c x \u003c\u003c std::endl; } virtual ~Base() {} }; class Derived :public Base { public: virtual void mf1() { std::cout \u003c\u003c \"Derived::mf1()\\n\"; } void mf3(){ std::cout \u003c\u003c \"Derived::mf3()\\n\"; } }; 很明显存在名称遮掩的问题，Derived的mf1，mf3会遮掩子类的所有同名函数，测试结果如下： Derived d; d.mf1(); //OK，输出: Derived::mf1() //d.mf1(100); 编译报错，因为名称被遮掩 d.mf2(); //OK，输出: Base::mf2() d.mf3(); //OK，输出: Derived::mf3() //d.mf3(300); 编译报错，同理 d.Base::mf3(300); //OK，输出: Base::mf3():x =300 . 但是不太建议这么写，丑！！ 为解决上述问题，可以采用using声明式或转发函数 using 声明式 可以使用using声明式，让Derived可以忽略名称遮掩，看到Base作用域内的函数。可以让上方代码的“编译报错”消失，正常调用d.mf1(100)和d.mf3(300)。 class Derived :public Base { public: //修改本节内容中上方代码的Derived类的声明 using Base::mf1; using Base::mf3; //这2个using使得Base类作用域内所有mf1,mf3函数都可见 // ... 其他，略 } 转发函数(forwarding function) 应用场景：在private继承下，强调的是继承实现而非继承接口，如果想在子类的成员中调用父类函数，此时可以通过函数转发来实现。 class Derived: private Base{ //改写本节上方代码，注意，是私有继承 public: virtual void mf1(){ Base::mf1(); //拿到了父类的函数实现 // ... 该函数其他部分 } }; // 应用代码 Derived d; d.mf1(); //调用成功，Derived::mf1 d.mf1(100); //编译失败 当然，public继承也能使用转发函数，写出d.Base::mf3(300); 这样的代码。但是，一来public继承理应遵循\"is-a\"规则，using声明拿到所有被遮掩的接口；二来明显代码不美观。 ","date":"2022-02-14","objectID":"/2022/02/14_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E4%B8%89/:8:0","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(三)","uri":"/2022/02/14_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E4%B8%89/"},{"categories":["程序设计"],"content":"R34 区分接口继承和实现继承 当一个子类Derived继承于父类Base，那么要时刻清楚，对于类中的成员函数，是想继承父类的接口，还是想继承父类的实现。 对于Public继承，接口总是会被继承 基于“is-a”的关系，作用于父类的任何事情也一定要适用于子类。 声明纯虚函数(pure-virtual)的目的是让子类只继承函数接口 对于纯虚函数，子类必须重新实现该接口。注意，父类可以选择性给出纯虚函数的实现，但是一般不会给。 隐患：从非纯虚函数(impure-virtual)同时继承接口和缺省实现 非纯虚函数，可以让子类选择是否重新实现该接口。那么，如果子类是有必要重写，但是忘记写了却默默用父类版本，便事与愿违了。 举例：父类Airplane有子类PlaneModelA、PlaneModelB、PlaneModelC，其中C型飞机不同于AB型，是新式飞机： class Airport {...};//机场类，实现略 class Airplane{ public: virtual void fly(const Airport\u0026 destination);//父类还会给出默认的fly实现 }; class PlaneModelA: public Airplane{ ... }; // 不重写fly，继承父类的fly实现 class PlaneModelB: public Airplane{ ... }; // B和A一样 class PlaneModelC: public Airplane{ ... }; //新型飞机，本来要重写fly，结果忘了 那么这个隐患该如何解决 呢，也就是说，在实现C型飞机类时别忘了fly方法？ 核心思想是“切断virtual函数接口和其默认实现之间的连接”。 方法1：设置fly为纯虚函数，并新增一个defaultyFly方法 注意细节：defaultFly方法要设置为protected属性的non-virtual函数，代码如下： class Airplane{ public: virtual void fly(const Airport\u0026 destination) = 0;// 父类不给出实现 protected: void defaultFly(const Airport\u0026 destination){ ... }//默认的fly实现 }; class PlaneModelA: public Airplane{ public: //纯虚接口,子类必须给出实现 virtual void fly(const Airport\u0026 destination){ defaultFly(destination); //调用父类的缺省实现 } };//PlaneModelB 和 PlaneModelA 类似,略 class PlaneModelC: public Airplane{ ...};// 重写fly方法 这样写还有个好处：fly()和defaultFly()享有不同的保护级别。 方法2： 父类的默认实现塞到纯虚接口fly中 这样就不需要定义defaultFly方法了，因为子类必须实现fly方法，对于A 型、B型飞机，子类fly()转发一次父类的fly()即可，C类飞机实现新式的fly()。缺点是让原本在defaultFly内的实现内容暴露在外了(指public属性)。 By The Way: 个人认为，这方法2还有个缺点：它让虚基类的纯虚接口承载了接口实现，不够纯粹(比如需要输出给到客户，应该只继承接口)。 non-virtual函数具体指定接口继承和强制性实现继承 如果成员函数是non-virtual，表示它不打算在子类中有不同的行为，或者说，不变性凌驾于特异性。对应地，绝不应该在子类中重写non-virtual函数。 ","date":"2022-02-14","objectID":"/2022/02/14_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E4%B8%89/:9:0","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(三)","uri":"/2022/02/14_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E4%B8%89/"},{"categories":["程序设计"],"content":"R35 考虑virtual函数的替代选择 假设这样一个场景：设计一款游戏，不同人物以不同方式计算生命值，那么$\\Longrightarrow$ 设计继承体系，子类共同继承父类的public-virtual方法healthValue()，子类各自重新实现healthValue()接口。 😄很好，中规中矩，那么，有没有其他方式呢？ NVI手法(non-virtual interface)实现Template Method模式 思路就是父类定义个non-virtual的public方法healthValue()，调用virtual的private方法healthValueImpl。子类直接重写healthValueImpl，达到类似模版方法设计模式的效果。 父类GameCharacter设计如下： class GameCharacter{//构造函数和虚析构均略去 public: int healthValue()const{ //ps:方便展示，而写在了头文件里，成了inline std::cout\u003c\u003c \"Do prepare works...\\n\";//事前，如加锁,写log,验证条件等 int retVal = healthValueImpl(); std::cout\u003c\u003c \"\\nDo post works...\\n\";//事后,如解锁,更新数据 return retVal; } private: virtual int healthValueImpl() const{ int val=0; std::cout \u003c\u003c \"default caculate process... GetValue:\" \u003c\u003c val;//随后进行计算，过程略 return val; } }; 子类GoodGuy 和 BadGuy设计如下： class GoodGuy:public GameCharacter{ private: virtual int healthValueImpl() const{ int val = 60; std::cout \u003c\u003c \"goodGuy caculate ... GetValue: \" \u003c\u003c val \u003c\u003c \" \";//过程略 return val; } }; class BadGuy:public GameCharacter{ private: virtual int healthValueImpl() const{ int val = 80; std::cout \u003c\u003c \"badGuy caculate ... GetValue: \" \u003c\u003c val \u003c\u003c \" \";//过程略 return val; } }; 应用端代码如下： std::shared_ptr\u003cGameCharacter\u003e pGood = std::make_shared\u003cGoodGuy\u003e(); pGood-\u003ehealthValue(); //得到60 std::shared_ptr\u003cGameCharacter\u003e pBad = std::make_shared\u003cBadGuy\u003e(); pBad-\u003ehealthValue();//得到80 用函数指针实现Strategy模式 主体思想是添加一个函数指针为private成员变量pFunc，这个函数通过外部传入，从而实现不同的行为。 class GameCharacter;//forward declaration int defaultHealthCalc(const GameCharacter\u0026 gc);//默认算法实现 class GameCharacter{ public: typedef int (*HealthCalcFunc)(const GameCharacter\u0026 gc); explicit GameCharacter(HealthCalcFunc hcf = defaultHealthCalc):calcFunc_(hcf){}//传入函数指针,自定义实现 int healthValue()const{ return calcFunc_(*this); } private: HealthCalcFunc calcFunc_ = nullptr; }; 这个设计有2个有趣的设计弹性： 即使同一个人物类型的不同实体，允许拥有不同的生命值计算方法； 某个人物对象的生命值计算方法，在其生命期内可以任意修改，只要添加一个set方法即可； 用std::function实现Strategy模式 private成员变量由上文的函数指针替换成std::function对象，相当于是指向函数的泛化指针。就更具设计弹性了。std::function可以传入函数指针、仿函数、std::bind函数对象。GameCharacter的类实现修改为： class GameCharacter{ public: typedef std::function\u003cint (const GameCharacter\u0026)\u003e healthCalcFunc; explicit GameCharacter(healthCalcFunc hcf = defaultHealthCalc):healthValueImpl_(hcf){} int healthValue()const{ std::cout\u003c\u003c \"Do prepare works...\\n\"; int retVal = healthValueImpl_(*this); //⚠️ 这里改了 std::cout\u003c\u003c \"\\nDo post works...\\n\"; return retVal; } private: healthCalcFunc healthValueImpl_ = nullptr; }; 传入函数指针 gameChashort quickHurtHealthCalc(const GameCharacter2\u0026 gc);//返回值不是int,可隐式转换;实现略去 //应用端代码如下： GameCharacter quickGuy(quickHurtHealthCalc); quickGuy.healthValue();//内部调用quickHurtHealthCalc 传入仿函数 仿函数：即函数对象，而且重载了operator() 。 struct HealthCalculator{// int operator()(const GameCharacter2\u0026 gc) const{ return 180;//省略实现 } }; //应用端代码如下： GameCharacter functorGuy( (HealthCalculator()) );//用括号将仿函数括起来 functorGuy.healthValue(); 传入std::bind函数对象 std::bind是函数对象模板，接收一个函数指针f和若干函数入参得到fObj，调用fObj等同于调用带参数的f。本例代码如下： class GameLevel{ public: //用类内函数作为函数指针f float health(const GameCharacter\u0026 gc) const{ return -20.3; } }; //应用端代码如下： GameLevel curLevel; GameCharacter levelGuy(std::bind(\u0026GameLevel::health, curLevel,std::placeholders::_1)); levelGuy.healthValue();//内部调用等价于curLevel.health(leveGuy); By the way 其实这里传入C++11新增的Lambda表达式作为std::function也是可以的，而且更方便，示例代码如下： GameCharacter lamGuy([\u0026](const GameCharacter\u0026 gc){ std::cout\u003c\u003c \"value is \" \u003c\u003c 75 \u003c\u003c std::endl;//具体计算略 return 75; }); lamGuy.healthValue(); 关于Strategy设计模式更多参考： Strategy设计模式-原理讲解 Strategy设计模式-C++代码参考 ","date":"2022-02-14","objectID":"/2022/02/14_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E4%B8%89/:10:0","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(三)","uri":"/2022/02/14_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E4%B8%89/"},{"categories":["程序设计"],"content":"R36 绝不重新定义继承而来的non-virtual函数 由于名称遮掩，不要重新定义继承而来的non-virtual函数 看个反例： class B{ public: void mf(){ std::cout \u003c\u003c \"B::mf()\"; } } class D: public B{ public: void mf(){//重新定义mf()，违反了Rule33 std::cout \u003c\u003c \"D::mf()\"; } }; 那么看这样的应用代码： D d; D* pD = \u0026d; B* pB = \u0026d; d.mf(); // 输出 D::mf() pD -\u003e mf();// 输出 D::mf() pB -\u003e mf();// 输出 B::mf() 这就很诡异了！都通过对象d调用成员函数mf，调用结果应该相同。 另外一点，出于public继承的“is-a”特性，这样重新定义non-virtual函数也是对\"is-a“的严重违背。 ","date":"2022-02-14","objectID":"/2022/02/14_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E4%B8%89/:11:0","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(三)","uri":"/2022/02/14_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E4%B8%89/"},{"categories":["程序设计"],"content":"R37 绝不重新定义继承而来的缺省入参值 这里说的缺省入参，指的是函数入参的默认值，在重写带有缺省入参的virtual函数时，不要修改那个默认参数的默认值。 原因：virtual函数为动态绑定特性，而缺省参数值是静态绑定特性。修改后会造成一些令人费解的现象。 请看下方反面教材： enum class Color { RED = 0,GREEN ,BLUE }; class Shape { public: // 🎉：父类默认入参是RED virtual void draw(Color col = Color::RED) { std::cout \u003c\u003c \"Shape:col is \" \u003c\u003c int(col) \u003c\u003c std::endl; } }; class Rectangle : public Shape{ // 🎉：子类类修改默认入参为GREEN virtual void draw(Color col = Color::GREEN) { std::cout \u003c\u003c \"Rectangle:col is \" \u003c\u003c int(col) \u003c\u003c std::endl; } }; 那么当出现典型应用场景Base* pB=new Derived时，就会造成“父类子类各出一半力”的情形： Shape *pRec = new Rectangle(); pRec-\u003edraw(); // 输出：Rectangle:col is 0 （0是RED） 结果确实调用子类draw，但是默认入参取的是基类的 RED，而非子类的GREEN。 那怎么修改合适呢，都带默认参数，且子类父类相同？带来一个耦合问题，如果父类改了，所有子类都得改。 正如Rule35提到的NVI(non-virtual interface)手法，此处便是绝佳的应用场景$\\Longrightarrow$ draw方法改为默认参数的non-virtual，把virtual函数放到private里去，代码修改如下： class Shape { public: //子类继承该默认入参的non-virtual接口，别重写 void draw(Color col = Color::RED) { drawImpl(col); } private: //纯虚函数是强制子类重写，看具体情况，impure-virtual也行 virtual void drawImpl(Color col) = 0;//子类重写这个drawImpl }; ","date":"2022-02-14","objectID":"/2022/02/14_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E4%B8%89/:12:0","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(三)","uri":"/2022/02/14_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E4%B8%89/"},{"categories":["程序设计"],"content":"R38 通过复合塑造出has-a或\"根据某物实现出” 原书标题：Model “has-a” or “is-implemented-in-terms-of” through composition，同Rule32，侯捷老师翻译为“塑模”。 复合关系（composition）是一种常见的类关系，当某种类型的对象内含有它种类型的对象时，便是此种关系。 复合关系分为2种：\"has-a\" 和 “is-implemented-in-terms-of\"。 “has-a”关系： 指的是应用域部分，不参与内的具体各项实现。是一种单纯的完备对象的包含关系，比如Person类有Address、PhoneNumber、Job等类型的成员变量，又或是Image类有Buffer、Mutexx、SearchTree等类型的成员。 “is-implemented-in-terms-of“关系： 指的是实现域部分，参与类的各类实现，比如数据结构的设计中，想用现有的 std::list来实现Set类，这样可能效率不高(通常更具效率的实现是采用平衡查找树 )，但是可行。 📌：此处不能让Set以public继承于std::list，因为list允许重复元素，而Set不行，不满足“is-a”关系。 正确实现部分代码示例如下： template\u003cclass T\u003e class Set{ public: bool contains(const T\u0026 item)const{ return std::find(rep_.begin(),rep_.end(),item) != rep_.end(); } void insert(const T\u0026 item){ if(!contains(item)) rep_.push_back(item); } void remove(const T\u0026 item);// 实现略 std::size_t size() const; // 实现略 private: std::list\u003cT\u003e rep_; //用来表述Set的数据 }; ","date":"2022-02-14","objectID":"/2022/02/14_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E4%B8%89/:13:0","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(三)","uri":"/2022/02/14_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E4%B8%89/"},{"categories":["程序设计"],"content":"R39 明智而审慎地使用private继承 “明智而审慎”的意思是👉当考虑了其他方案对比后，仍然觉得private继承是最合适的，才使用它。 首先明确private继承的2个特性： 编译器不会自动将一个derived-class对象隐式转换为base-class对象(函数入参时)； 继承而来的成员，在derived-class中都会变成private属性； private继承的意义：意味着implemented-in-terms-of，在类关系设计上没有太大意义，只看重软件实现。 考虑以下使用private的2个应用场景： derived-class想继承base-class的某public接口实现，但又想隐藏此接口 考虑如下应用场景：对于一个已知的类Widget，想用另一个已知的计时类Timer辅助性能分析，在尽量小改动已有代码的情况下，如何启用Timer？ private继承做法：让Widget类private继承于Timer，重写父类Timer的onTick函数。 具体代码如下： class Timer{ public: explicit Timer(int tickFrequency); virtual void onTick() const;//定时器滴答一次，自动被调用一次 }; class Widget:private Timer{ private: //😋 private继承而来的所有成员都是private属性 virtual void onTick() const;//查看并记录Widget数据，资源等 }; 该问题除了上方的private继承，能不能用其他方案替代private继承呢？ 👉 👉“public继承+复合”替代private继承：在Widget内部嵌套定义private属性的新类WidgetTimer:private Timer，即可同样启用Timer且隐藏了Timer。代码如下： class Widget{ private: class WidgetTimer:public Timer{// 类内嵌套定义 public: virtual void onTick() const; }; WidgetTimer wTimer_; }; ⭐⭐ WidgetTimer也可以不定义在Widget类内,类内只放WidgetTimer* 和WidgetTimer的前置声明，完全解耦合，降低编译依赖性。而这样的设计自由度是单纯的private继承不具备的。 空白基类最优化(EBO,empty base optimization) ⚡值得一提：空类(Empty Class)是指不含non-static数据成员和virtual-func的类。 空类的size会被C++强制要求至少为1，通常是用1个char占位。如果让Empty-Class作为数据成员，因为内存对齐而导致Derived-Class浪费内存。 示例代码 👇： class Empty { // 空类，1字节. 不含non-static数据，不含virtual void privteFoo() { std::cout \u003c\u003c \"private non-virtual.\"; } public: typedef char* pChar; typedef void(*pFuncReadData)(std::string url); enum class clolr { red,green,blue }; void foo() { std::cout \u003c\u003c \"public non-virtual!\"; } static int count ;//static 数据也不属于class实体 }; class HoldsIntsAndEmpty { //内存对齐后12字节 int x_; // 4字节 Empty e_; // 1字节 int y_; // 4字节 }; class HoldsInts:private Empty {//使用EBO,类大小8字节 int x_;//4字节 int y_;//4字节 }; EBO优化可以减少Derived-Class的内存大小，注意EBO只适用于单继承。 ","date":"2022-02-14","objectID":"/2022/02/14_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E4%B8%89/:14:0","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(三)","uri":"/2022/02/14_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E4%B8%89/"},{"categories":["程序设计"],"content":"R40 明智而审慎地使用多重继承 多重继承(multiple inheritance)是指继承一个以上的父类。但是这些父类应该避免拥有共同的祖父类，会形成比较麻烦的“菱形继承”(或者叫钻石继承)。 多重继承的成本以及副作用 上面说“菱形继承”比较麻烦，主要原因是如果祖父类如果拥有某个成员变量x，那么2个父类分别public形式继承了x，到了目标子类就有了2份x。 解决问题的办法是虚继承(virtual inheritance)，如此，上述子类只有一份x。为保证虚继承的正确性，编译器在背后需要付出更多代价，可能造成子类内存更大或运行速度更慢。 👉如果存在菱形继承，那么祖父类尽量不要持有数据成员。 虚继承示例代码如下： class File{...}; //祖父类最好不要持有non-static数据成员 class InputFile: virtual public File{...}; class OutputFile: virtual public File{...}; class IOFile:public InputFile,public OutputFile{...}; 应用场景：public继承接口+private继承实现 思考这样的应用场景，PersonBase类是虚基类，RealPerson是目标子类（需要继承接口），但是获取name和birthDate信息的函数在另一个PersonInfo类都有了现成的实现（只需要简单修改该实现）。 两者结合后，即让RealPerson类public继承于PersonBase，private继承于PersonInfo。 class PersonBase { public: virtual ~PersonBase(){} virtual std::string name() const = 0; virtual std::string birthDate() const = 0; }; class PersonInfo { public: virtual ~PersonInfo() {} explicit PersonInfo(int pID):id_(pID) {} virtual const char* theName() const{ static char value[1024]; static const char* exampleName = \"Luka\";// 计算过程略,用固定字符串替代 std::strcpy(value, valueDelimLeft()); // 获取左界定符 std::strcat(value, exampleName); std::strcat(value, valueDelimRight());// 获取右界定符 return value; } virtual const char* theBirthDate() const { return \"1990-1-1\"; } virtual const char* valueDelimLeft() const { return \"[\"; }; virtual const char* valueDelimRight() const { return \"]\"; }; private: int id_ = 0; }; 多重继承的代码为👇: class RealPerson :public PersonBase, private PersonInfo {//多重继承 public: explicit RealPerson(int pID) :PersonInfo(pID) {} // 委托构造 virtual std::string name() const{ //实现必要的虚基类Person的pure-virtual成员函数 return PersonInfo::theName(); } virtual std::string birthDate() const { return PersonInfo::theBirthDate(); } private: virtual const char* valueDelimLeft() const { return \"\"; };//重写界定符函数 virtual const char* valueDelimRight() const { return \"\"; }; }; 最后应用端代码： RealPerson rPerson(613); std::cout \u003c\u003c rPerson.name(); //输出Luka ,而不是[Luka] 可以看到，多重继承体系完美解决该问题。 回到本节开头，明智和审慎的意思是👉即使多重继承可以用单继承方案替代解决，思考后，如果多重继承依然是最简洁、最易维护、最合理的做法，那就选择它。 ","date":"2022-02-14","objectID":"/2022/02/14_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E4%B8%89/:15:0","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(三)","uri":"/2022/02/14_effective-c-%E4%B9%8B%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93%E4%B8%89/"},{"categories":["程序设计"],"content":"摘要：Effective C++(第三版)内容第三、第四章的总结","date":"2022-01-27","objectID":"/2022/01/11_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%BA%8C/","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(二)","uri":"/2022/01/11_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%BA%8C/"},{"categories":["程序设计"],"content":"前言 这本C++经典著作，本人看的是中文版，侯捷老师翻译的，精读分析并实践推敲后，整理成博客记录下来，非常适合有一定开发经验的朋友们阅读。 Effective-C++总结系列分为四部分，本文为第二部分，涉及原书第3~4章，内容范围Rule13~25。为方便书写，Rule13简写为R13。 Effective-C++系列List 本博客站点系列内容如下： 💡 Effective C++(第3版)精读总结(一) 💡 Effective C++(第3版)精读总结(二) 💡 Effective C++(第3版)精读总结(三) 💡 Effective C++(第3版)精读总结(四) 由于原书在C++11之前写成，有些现代C++特性不会提及，所以会根据本人开发经验新增一些个人感悟👉By the way环节。 CH3.资源管理 ","date":"2022-01-27","objectID":"/2022/01/11_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%BA%8C/:0:0","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(二)","uri":"/2022/01/11_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%BA%8C/"},{"categories":["程序设计"],"content":"R13 以对象管理资源 为防止资源泄露，尽量使用RAII对象(资源获取即初始化，Resource Acquisition Is Initialization) 如果用老式的new-delete组合手动管理资源，可能会遇到这样的场景，处理代码中有多处return/break之类的分支语句，每处都手动添加delete回收资源难免会有遗漏风险。 auto_ptr 本书提及的智能指针对象 std::auto_ptr可以在资源A初始化化时接管对象A，对象脱离作用域，析构时释放接管的A。 为避免重复删除资源， std::auto_ptr特性：通过copy构造函数或copy-assignment操作符，操作它们，它们自身会失去资源所有权，变成NULL ！ shared_ptr 为解决上述问题，后来推出了引用计数管理资源，即RCSP(Reference-counting smart poiner)，std::shared_ptr 。(书中当时还是tr1::shared_ptr)特点是shared_ptr在使用copy构造函数或copy-assignment操作符时，不会失去资源所有权，而是自身引用计数加1。 By the way auto_ptr目前已经被弃用，转而使用 std::unique_ptr来指涉独占资源的智能指针，不可被复制和赋值。 shared_ptr存在的问题是环形循环应用，互相持有对方，则无法释放，针对这一问题，需要引入std::weak_ptr来破局。 这些智能指针的头文件支持：#include \u003cmemory\u003e 常用的RAII方式存在的问题 上述的shared_ptr是不支持数组资源的释放的，在析构时默认调用delete，而不是delete[] 。如果要能释放，需要手动传入析构函数。 std::shared_ptr\u003cInvestment\u003e instSpMan(new Investment[5], [](Investment* p) {delete[] p; }); // 使用lamda函数，还可以传入普通函数指针 std::shared_ptr\u003cInvestment[]\u003e instSp(new Investment[5]);// shared_ptr重载了[] std::unique_ptr\u003cint[]\u003e intUp(new int[5]); // unique_ptr重载了[] PS: 通常情况下，如果能用vector代替的场景，就不需要这样使用对象数组。 ","date":"2022-01-27","objectID":"/2022/01/11_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%BA%8C/:1:0","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(二)","uri":"/2022/01/11_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%BA%8C/"},{"categories":["程序设计"],"content":"R14 在资源管理类中小心coping行为 并非所有资源都是堆上管理(heap-based)，所以也有智能指针不适合的场景，这时需要自己实现一个资源管理类。 比如有个类CMutex ，只有2个函数lock和unlock，可以新建一个管理类CLock，来管理Mutex类，代码如下： class CMutex {/*省略类实现*/}; void lock(CMutex *mtx) { std::cout \u003c\u003c \"has lock...\\n\";/*other operation...*/ } void unlock(CMutex *mtx) { std::cout \u003c\u003c \"release lock...\\n\";/*other operation...*/ } class CLock { public: explicit CLock(CMutex *mtx) :mtx_(mtx) { lock(mtx_); } ~CLock() { unlock(mtx_); } private: CMutex *mtx_; }; 如果涉及CLock的coping相关函数，那么有以下几种选择： 禁止复制 参考本书Part1-Rule06，禁止coping函数的生成。 对底层资源使用“引用计数法” 以shared_ptr\u003cCMutex\u003e代替裸指针，并且传入unlock函数作为该指针的“删除器”。 复制底部资源 即“深度拷贝”，复制资源管理对象时，同时复制其包裹的资源。 转移底部资源所有权 即浅复制，不拷贝包裹的资源，而是转移所有权，和前文提到的auto_ptr非常契合。 ","date":"2022-01-27","objectID":"/2022/01/11_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%BA%8C/:2:0","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(二)","uri":"/2022/01/11_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%BA%8C/"},{"categories":["程序设计"],"content":"R15 在资源管理类中提供对原始资源的访问 智能指针auto_ptr, unique_ptr, shared_ptr都提供了接口访问原始资源，方法名称为get()，对类A资源得到裸指针A*。 智能指针也重载了操作符operator -\u003e 和 operator * ，访问类成员函数都可以像普通指针那样使用。 如果自行设计资源管理类，也要像上述的智能指针那样，做到能够轻松访问原始资源。 某些情况，也可以不使用get成员函数显式转换，转而使用隐式类型转换，方便客户调用: class Font{ public: // 隐式转换 operator FontHandle() const{ return f;} // 显式转换 FontHandle get() const { return f;} private: FontHandle f; } ","date":"2022-01-27","objectID":"/2022/01/11_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%BA%8C/:3:0","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(二)","uri":"/2022/01/11_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%BA%8C/"},{"categories":["程序设计"],"content":"R16 成对使用new和delete时要采取相同形式 先看一段错误代码： std::string *stringArray = new std::string[100]; delete stringArray;// undefined behavior,未定义行为；有可能只删除了第一个元素 警示 new 和 delete对应 new[] 和 delete[]对应 不可遗漏或者交叉错配！ 简单探究 delete[]的原理：实际上，在编译器的实现中，对象数组的起始内存会存放“数组长度”这一变量，以便告知delete[]应该调用多少次析构，删除多少资源。 👉 谨慎对数组使用typedef，容易产生new-delete的匹配误解，示例如下： typedef std::string AddressLines[4]; std::string *pal = new AddressLines;//注意：这里其实就是 new string[4] delete pal; // 行为未定义！！ delete [] pal; // 正解！ // 这里建议的替代方法：vector\u003cstring\u003e ","date":"2022-01-27","objectID":"/2022/01/11_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%BA%8C/:4:0","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(二)","uri":"/2022/01/11_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%BA%8C/"},{"categories":["程序设计"],"content":"R17 以独立语句将newed对象置入智能指针 不要将申请资源的new语句直接当作函数入参，而是应该先以单独语句申请后传入。 考虑下述问题代码： int priority(); void processWidget(std::shared_ptr\u003cWidget\u003e pw,int pri); //函数调用 processWidget(std::shared_ptr\u003cWidget\u003e(new Widget),priority()); 上述代码第4行，在processWidget函数体执行之前，至少有3个步骤(并非严格次序)： 执行\"new Widget\" 调用std::shared_ptr的构造函数 调用priority函数 C++编译器能保证1-\u003e2的次序(2需要1做入参)，但是无法保证3的次序不在1，2之间，如果步骤3抛出异常，将会直接导致内存泄漏。正确示例如下： std::shared_ptr\u003cWidget\u003e pw(new Widget); processWidget(pw,priority()); CH4.设计与声明 ","date":"2022-01-27","objectID":"/2022/01/11_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%BA%8C/:5:0","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(二)","uri":"/2022/01/11_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%BA%8C/"},{"categories":["程序设计"],"content":"R18 让接口容易被正确使用，不易被误用 要想设计一个不容易误用的接口，就要先考虑使用者可能犯什么错误。 避免“接口误用”，可以导入新类型进行限制 比如设计一个Date类，参数传递就可能出错，如下所示： class Date{ public: Date(int month,int day,int year); }; 实际使用时，使用者可能写出Date date(30,4,2021);这样的错误代码，如何防范呢？ 方法之一：封装出Month,Day,Year这3个Struct/Class，作为参数入参，并添加月份限制，代码： class Month{ public: static Month Jan() { return Month(1);} // ...省略其他11个月份 private: int val; explicit Month(int m):val(m){} //可被class-static调用，不能被外部调用 }; struct Day {explicit Day(int d) :day(d){} int day; }; //省略 struct Year定义，和Day类似 class Date{ public: Date(const Month\u0026 month,const Day\u0026 day,const Year\u0026 year){} }; 最终客户代码使用的情况如下： Date date(Month::Jan(),Day(13),Year(2022)); By the way C++11 支持对枚举的强化，即类型安全的enum class，它不能隐式地转换为整数；也无法与整数数值做比较。此处可以考虑定义一个MonthEm来代替Month： enum class MonthEm { Jan = 1, Feb = 2, //... 省略其它的月份定义 }; // 修改Date的构造函数，MonthEm来代替Month Date(const MonthEm\u0026 monthEm, const Day\u0026 day, const Year\u0026 year) {} // 构造对象 Date date2(MonthEm::Feb, Day(23), Year(2021)); 限制类型内什么事是可不可做的 常见操作是加上const限制，比如“以const 修饰operator * 的返回类型 ”可以阻止这个错误： //本意是想做比较，写成了赋值，但是赋给const，报错！ if (a * b = c) 智能指针传入删除器可避免\"Cross-dll-problem\" std::shared_ptr管理资源时，传入删除器，可避免在A-Dll中new，结果在另一个B-Dll中delete的情况，这会导致Runtime-Error。 ","date":"2022-01-27","objectID":"/2022/01/11_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%BA%8C/:6:0","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(二)","uri":"/2022/01/11_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%BA%8C/"},{"categories":["程序设计"],"content":"R19 设计Class犹如设计Type 设计一个优秀的Class并不容易，很多C++书籍都像本书一样提到“Check-Table”，设计Class/Type前，问自己一些重要问题： 新type的对象应该如何被创建和销毁？ 对象的初始化和赋值该有什么差别？ 新type的对象如果值传递(pass-by-value)，意味着什么？ copy构造函数用来定义一个type的值传递具体实现。 什么是新type的“合法值”？ 想清楚约束条件，特别是构造函数、赋值操作符以及setter函数，涉及的错误检查与非法值拦截。 新type需要配合某个继承图谱吗？ 如果继承自某Base类，那么就会收到virtual,non-virtual函数的约束；如果要做后续类的基类，则该type就要注意虚析构的设计。 新type涉及什么样的转换？ 与其他type之间如有转换需求，则需要自行实现相关函数，可参考Rule15。 新type需要怎样的操作符和函数？ 确定哪些是member函数，哪些不是。参考Rule23，Rule24，Rule26。 是否有需要立即驳回的标准函数？ 比如是否禁止copy构造，copy-assignment操作符等函数，可以声明为private；或者使用C++新特性\"=delete\"。参考Rule6。 新type成员的访问属性控制？ 成员变量都应为private，考虑其他member函数该为private/public/protected。以及启用友元friend的考虑。 什么是新type的“未声明接口”? 参考Rule29。 新type有多么一般化？ 如果是一般化的问题处理，该考虑是否该定义Class-Template。 真的需要一个新type吗？ ","date":"2022-01-27","objectID":"/2022/01/11_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%BA%8C/:7:0","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(二)","uri":"/2022/01/11_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%BA%8C/"},{"categories":["程序设计"],"content":"R20 以pass-by-reference-to-const代替pass-by-value 尽量以pass-by-reference-to-const代替pass-by-value 前者通常更高效，并可避免“对象切割”问题。 如果对象入参以值传递，就会在入参时创建临时对象，函数完成后临时对象析构，涉及构造函数和析构函数的调用，这些都可能是不小的开销！ 如果是以const reference形式，则不会有任何构造/析构的开销。const的作用是让使用者放心，不会改变入参的值。 “对象切割\"问题： 如果是值传递，Derived-Obj传递给Base-Param，会丢失Derived独有的特性，只保留Base的那部分。 对于C++内置类型，值传递往往更高效 从C++编译器的底层实现角度来看，references引用往往是以指针的形式实现。所以如果是内置数据类型，比如int类型 ，直接值传递反而效率更高。 此规则还适用于STL迭代器和函数对象。 ","date":"2022-01-27","objectID":"/2022/01/11_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%BA%8C/:8:0","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(二)","uri":"/2022/01/11_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%BA%8C/"},{"categories":["程序设计"],"content":"R21 必须返回对象时，不要随意返回reference 不要返回指针或引用指向以下对象： 局部栈对象(local stack) 函数内部新建的栈变量对象，出了函数就面临消亡，仍持有它的引用/指针，是典型的未定义行为。 堆分配对象(heap allocated) 内部new，然后return出去使用，一来会增加外部delete的负担，二来可能delete的机会都没有。代码如下： const Rational\u0026 operator*(const Rational\u0026 lhs,const Rational\u0026 rhs){ Rational *result = new Rational(lhs.n * rhs.n,lhs.d * rhs.d); return *result; } // 如下使用连乘，则没有delete的机会 Rational w,x,y,z; w = x * y * z; // 内存泄漏！！！ 上述代码返回的是引用，返回指针也是一样的负作用。 局部static对象(local static) 函数内部的static对象，只初始化一次，且只有一份，有记忆功能，可以被更新。那么下述代码就会出现问题： const Rational\u0026 operator*(const Rational\u0026 lhs,const Rational\u0026 rhs){ static Rational result; result = Rational(lhs.n * rhs.n,lhs.d * rhs.d) return result; //在调用者看来，因为是引用，永远只看到独一份的result的“最新值 ” } // 下方的比较永远都是true，永远走if分支 ！！ Rational a,b,c,d; if((a*b) == (c*d)){ //乘积相等，走if分支 }else{ //乘积不相等，走else分支 } 那是不是永远不能以reference作为返回值呢 ？ 当然不是，*this可以返回其引用，参考Rule10；或者类成员作为返回值时，可以返回其引用，但最好是const。 ","date":"2022-01-27","objectID":"/2022/01/11_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%BA%8C/:9:0","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(二)","uri":"/2022/01/11_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%BA%8C/"},{"categories":["程序设计"],"content":"R22 将成员变量声明为private 成员变量为private获得的好处 客户访问数据的一致性。都是用getter函数（需要加括号），而不是混用函数获取和直接访问； 细化成员变量的访问权限。根据是否有getter、setter函数可以精准控制read/write/none这样的细化。 保持实现弹性。比如获取某系统指标，可以在getter函数中修改各种灵活的策略和算法，而调用者感知不到。 封装性。封装性是指☞ 越多函数可以访问该数据，封装性越低。 客户调用端感知不到class内部的实现，这些确实也是不必暴露的。并且，如果是要修改某个变量，使用setter函数也更方便调试，不至于被随意修改。 protected和public差不多，都不具备封装性 如果某个public/protected变量权限被取消（比如改为private），将会导致大面积的编译错误，能访问的变成unaccessible，需要对应修改许多代码。 ","date":"2022-01-27","objectID":"/2022/01/11_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%BA%8C/:10:0","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(二)","uri":"/2022/01/11_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%BA%8C/"},{"categories":["程序设计"],"content":"R23 宁可用non-member,non-friend代替member函数 实际上，non-member/non-friend函数具有更大的封装性 考虑下述一个类WebBrowser，member函数和non-member函数，实际上，member函数WebBrowser::clearEverything具有其他private数据的访问权限，封装性是更差的！ class WebBrowser { public: void clearCache() {/*to clear cache*/} void clearHistory() {/*to clear history*/} void removeCookies() {/*to clear cookies*/} void clearEverything() { clearCache(); clearHistory(); removeCookies();} }; void clearBrowser(WebBrowser \u0026wb) { wb.clearCache(); wb.clearHistory(); wb.removeCookies(); } 工程结构安排 对于上述WebBrowser的例子，non-member函数放哪里呢，除了可以是其他class的member函数，更适用自然的答案是用namespace包裹起来。代码如下： namespace WebBrowserStuff{ class WebBrowser {}; void clearBrowser(WebBrowser \u0026wb); } 注意：namespace可以跨越多个源码文件，而class不能。 通常的组织方式：多个.h头文件都使用同一个namespace，管理不同的功能模块。除了让模块更清晰，还能降低不必要的编译依赖关系。 对于private数据，member和friend函数具有相同的访问权限 基于此，这里讨论的封装性不在于member与否，而是member和non-member ，non-friend函数之间。 ","date":"2022-01-27","objectID":"/2022/01/11_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%BA%8C/:11:0","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(二)","uri":"/2022/01/11_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%BA%8C/"},{"categories":["程序设计"],"content":"R24 若所有参数皆需类型转换，请采用non-member 标题需明晰：所有参数，是指包含了被this指针所指向的那个隐含参数（non-explicit构造函数调用隐式类型转换时）。 应对具体场景：构造函数允许隐式类型转换，且需要这个构造好的对象立即调用某member函数foo(比如operator函数)，此时这个foo函数应该改为non-member的foo函数。 考虑一个有理数类Rational，允许隐式类型转换构造（即non-explicit），如果operator*是member函数则会出现问题。Rational类实现代码示例如下： class Rational { public: Rational(int numerator = 0, int denominator = 1) :numerator_(numerator), denominator_(denominator) {} const Rational operator* (const Rational\u0026 rhs)const { return Rational(numerator_*rhs.numerator_, denominator_*rhs.denominator_); } int numerator()const { return numerator_; } int denominator()const { return denominator_; } private: int numerator_ = 0; int denominator_ = 1; }; 上述代码存在一个问题，就是不能混合运算，举例如下： Rational rat(2, 5); Rational rat3Tm = rat * 3; //能成功调用member-operator* Rational rat3Tm2 = 3 * rat; //编译报错！！！ 本节的场景就在于此. 如果要让这种混合运算无障碍，把operator*函数 改成non-member即可，注意要删掉原来member内的operator*，不能同时存在这2个operator*。 class Rational { //... 注意，要删除类内的member函数operator* }; const Rational operator* (const Rational\u0026 lhs, const Rational\u0026 rhs) { return Rational(lhs.numerator() * rhs.numerator(), lhs.denominator() * rhs.denominator()); } ","date":"2022-01-27","objectID":"/2022/01/11_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%BA%8C/:12:0","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(二)","uri":"/2022/01/11_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%BA%8C/"},{"categories":["程序设计"],"content":"R25 考虑写一个不抛异常的swap函数 当 std::swap对某个类型效率不高时，提供一个swap成员函数，且该swap不抛异常 先看一下效率不高的std::swap实现： namespace std{ template\u003ctypename T\u003e //std::swap的典型实现 void swap(T\u0026 a,T\u0026 b){ //置换 a 和 b 的值 T temp(a); //若T是class，此处调用copy构造函数 a = b; //若T是class，此处调用copy assignment操作符 b = temp; } } 考虑这样的使用场景：需要swap一个\"pimpl手法”(pointer to implementation)实现的类，这种传统的std::swap必然是效率不高(深复制impl类的数据耗时较长)。 class WidgetSwImpl { private: int a, b, c; std::vector\u003cdouble\u003e v; //很大的vector,意味着复制时间很长 }; class WidgetSw { public: WidgetSw(WidgetSwImpl* pImpl) :pImpl_(pImpl) {} WidgetSw(const WidgetSw\u0026 rhs) {/*其他copy\u0026initial操作*/} WidgetSw\u0026 operator=(const WidgetSw\u0026 rhs) { *pImpl_ = *(rhs.pImpl_); } void swap(WidgetSw\u0026 other) { //public-member函数swap using std::swap; //令std::swap在此函数可用 swap(pImpl_,other.pImpl_); } private: WidgetSwImpl* pImpl_ = nullptr; }; 调用时代码如下： WidgetSw wSw1(new WidgetSwImpl); WidgetSw wSw2(new WidgetSwImpl); wSw1.swap(wSw2); //成功运行 如果提供了member swap，需提供一个non-member的swap调用前者 注意，其实上述swap成员函数使用起来不算直观和统一，可以全特化std::swap让使用更直观方便，代码如下： namespace std { template\u003c\u003e void swap\u003cWidgetSw\u003e(WidgetSw\u0026 a, WidgetSw\u0026 b) { a.swap(b); } } // 客户端应用代码可以如下调用 // 注意，不应该，也没必要加 std::，会限制编译器只使用std命名空间的swap swap(wSw1,wSw2);//编译器会优先挑中全特化版本的std::swap 如果是Class-Template，则不要特化std命名空间的swap，而是移到其它命名空间 namespace WidgetStuff{ template\u003ctypename T\u003e class WidgetSw{ /*省略类定义*/} // 类内含有swap成员函数 template\u003ctypename T\u003e void swap(WidgetSw\u003cT\u003e\u0026 a, WidgetSw\u003cT\u003e\u0026 b){ a.swap(b); } } 注意： std命名空间的函数不要尝试重载，也不要增加任何新东西 C++只允许对Class-Template直接偏特化，不能对Function-Template偏特化(函数模板可以通过重载间接实现“偏特化”的作用) 成员版swap绝对不要抛出异常，非成员swap可以(因为成员swap的一个最好应用就是提供异常安全性) ","date":"2022-01-27","objectID":"/2022/01/11_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%BA%8C/:13:0","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(二)","uri":"/2022/01/11_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%BA%8C/"},{"categories":["脚本"],"content":"摘要：对常用的markdown语法(基本语法+扩展语法)做个总结概述，备忘查询","date":"2022-01-11","objectID":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/","tags":["markdown","工具"],"title":"Markdown语法总结","uri":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/"},{"categories":["脚本"],"content":"前言 Markdown是一种轻量级标记语言，于2004年由创始人John Gruber发布，采用并不复杂的语法，可以书写简洁美观带有格式的文本。 基本语法 关于符号 重要的事情提前说：Markdown中的所有标记符号都是英氏符号，也就是输入法为输入英文状态下的时候。(尤其警惕竖向分隔线|，感叹号!，括号()，等等…中英文的这几个有点像) ","date":"2022-01-11","objectID":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/:0:0","tags":["markdown","工具"],"title":"Markdown语法总结","uri":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/"},{"categories":["脚本"],"content":"段落与换行 空行可以用来段落分割，输入回车Enter换行即可； 段落内换行可以使用\u003cbr\u003e来换行，通常可以用在markdown表格内换行; 某些markdown编辑器在写完上一行文本后输入Enter换行依然未能换行生效，那就再Enter一个空行，或者在上一行末尾加2个连续空格； 如果不是在列表内的段落，不鼓励行首缩进； ","date":"2022-01-11","objectID":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/:1:0","tags":["markdown","工具"],"title":"Markdown语法总结","uri":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/"},{"categories":["脚本"],"content":"标题层级 Markdown使用符号 # 来表示标题的层级，几个 # 号就是几级标题，通常用到4级就足够内容排布了。 输入内容 渲染效果 # 一级标题 ## 二级标题 ### 三级标题 一级标题 二级标题 三级标题 标题细节 #号和标题内容之间有空格 顺便一提,标题层级x其实转化为html等同于\u003chx\u003e 标题内容 \u003c/hx\u003e，x为数字(😏上述表格内右边内容我其实用的html标签，表格内的#号形式没法渲染) ","date":"2022-01-11","objectID":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/:2:0","tags":["markdown","工具"],"title":"Markdown语法总结","uri":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/"},{"categories":["脚本"],"content":"字体强调 字体加粗：加粗的内容使用前后2个连续的星号* 包围起来,例如： 输入内容 渲染效果 这是**加粗**的内容 这是加粗的内容 ⚠️ 如果加粗的内容有*,#,-,这一类markdown语法有关的字符，可以用英式反斜杠\\加在前面转义(实际上想让任何markdown的某个标记符号失效，都可以用反斜杠\\转义从而escape); 某些Markdown编译器对*号解析有点问题，如果渲染效果未生效，外侧的*号前后加空格即可,和未加粗的内容分隔开👉假如\"前文**加粗内容**后文\"不生效，修改成\"前文 **加粗内容** 后文\"即可。 字体斜体：斜体的内容使用前后1个星号*包围或者前后1个下划线_包围起来,例如： 输入内容 渲染效果 这是*斜体*的内容 这是斜体 的内容 这也是 _斜体_ 的内容 这也是 斜体 的内容 代码字体：行内代码的内容使用前后1个英式反引号包围起来(反引号`在键盘左上角,数字1左边)，一般来说，代码语法渲染后有轻度高亮的效果，例如: 输入内容 渲染效果 这是`代码`的内容 这是代码的内容 字体删除线：对删除线的内容前后2个连续的英式波浪号 ~包围起来，例如： 输入内容 渲染效果 ~~这是删除线的内容~~ 这是删除线的内容 字体的组合:以上的效果可以组合起来使用： 输入内容 渲染效果 ***加粗和斜体*** 加粗和斜体 ~~**删除线和加粗~~** 删除线和加粗 ~~*删除线和斜体*~~ 删除线和斜体 ~~***加粗, 斜体和删除线***~~ 加粗, 斜体和删除线 **`加粗和高亮`** 加粗和高亮 ","date":"2022-01-11","objectID":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/:3:0","tags":["markdown","工具"],"title":"Markdown语法总结","uri":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/"},{"categories":["脚本"],"content":"列表 列表分为无序列表和有序列表：无序列表用英式符号短横-、加号+、或星号* 后接空格来表示；有序列表使用数字加点接空格(例如\"1. “)来表示。 输入内容 渲染效果 - 短横无序列表 - 短横无序列表 短横无序列表 短横无序列表 + 加号无序列表 + 加号无序列表 加号无序列表 加号无序列表 * 星号无序列表 * 星号无序列表 星号无序列表 星号无序列表 1. 数字有序列表 2. 数字有序列表 数字有序列表 数字有序列表 提示： 列表一般会自动缩进，而且写完一条列表内容后，按下Enter换行，markdown会自动新建下一个列表 列表可以嵌套使用 ","date":"2022-01-11","objectID":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/:4:0","tags":["markdown","工具"],"title":"Markdown语法总结","uri":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/"},{"categories":["脚本"],"content":"引用 使用英式大于号 \u003e 来标识一段引用内容，支持多行引用，也支持引用内列表。引用很有用，渲染效果一般是一段加了浅色阴影的文本，可以用于文首/文末的声明，参考链接等内容，有时可以用来做注意事项的声明。 输入内容： \u003e 注意：这是引用内容 \u003e - 引用细节1 \u003e - 引用细节2 渲染效果： 注意：这是引用内容 引用细节1 引用细节2 ","date":"2022-01-11","objectID":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/:5:0","tags":["markdown","工具"],"title":"Markdown语法总结","uri":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/"},{"categories":["脚本"],"content":"插入图片 markdown使用 ![图片描述](图片链接) 的形式来展示一张图片。 这个链接可以是本地链接，也可以是网络链接。 如果是只在本地看，可以使用本地链接，分为本地全路径和本地相对路径： 本地全路径：有一张图在D:\\Cat.png,那么可以在markdown中引入图片![小猫](D:\\Cat.png) ; 本地相对路径：本md文档同目录有个Pic目录，里面有张Cat.png,那么可以在markdown中引入图片![小猫](./Pic/Cat.png) ; 如果是需要发布到网络博客，那么就需要使用图片的网络链接了 想引用网页的某张图，鼠标右键复制图片链接地址, 就是我们需要的图片链接了。举例，去 菜鸟教程C++ 的主页，主页Logo复制到链接后，输入如下内容插入图片： ![C++ programming](https://www.runoob.com/wp-content/uploads/2015/01/cpp-mini-logo.png) 渲染后，图片则自动显示如下： 那么，如果我们自己的制作的图片想要上传到网络呢？ 最常见的是写博客和云笔记，除了某些云笔记软件自带图床，更通常的做法是自己备份在Gitee或Github，更简便的办法是采用 图床 ,推荐个好用的开源工具PicGo，奉上👉 PicGO-Github-Release链接。 图片排版 首先，markdown插入图片都是左对齐的，有时想要图片居中，只能动用html排版了，具体用法如下(图片显示尺寸width字段可以省略不写 )： 输入内容: \u003cdiv align =center\u003e \u003cimg src=\"https://www.runoob.com/wp-content/uploads/2015/01/cpp-mini-logo.png\" width = \"120\"/\u003e \u003c/div\u003e 渲染效果： ","date":"2022-01-11","objectID":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/:6:0","tags":["markdown","工具"],"title":"Markdown语法总结","uri":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/"},{"categories":["脚本"],"content":"插入URL超链接 markdown 使用 [超链接描述](链接地址) ，适用场景：比如想给出某链接的地址，浏览者鼠标点击即可浏览器跳转。 比如输入内容： [访问一个高Star的免费中文书籍仓库](https://github.com/justjavac/free-programming-books-zh_CN) 渲染效果： 访问一个高Star的免费中文书籍仓库 ","date":"2022-01-11","objectID":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/:7:0","tags":["markdown","工具"],"title":"Markdown语法总结","uri":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/"},{"categories":["脚本"],"content":"水平分隔线 在一个大段落之后，想和后续内容在视觉上有分隔效果，这时候就需要用到水平分隔线了。markdown中的水平分隔线使用方法：单行使用3个及以上的星号*(***),或短横线-(—),或下划线_(___)，且上下为空行，和正文分开。 输入内容(只演示*号，另外2种一样的): 段落1 ***** 段落2 渲染效果: 段落1 段落2 扩展语法 在基础语法发布后，人们发现不够用，于是有了扩展语法。扩展语法的特性包括表格、代码段控制、脚注、标题ID(Heading ID,我更愿称之为标题锚点)、任务列表、Emoji表情、高亮语法等语法。 因为markdown是兼容html的，所以某些扩展语法需要借助html的各类标签。 提示 扩展语法不是所有Markdown编辑器都全盘支持，具体情况以该编辑器的支持情况为准； 代码段和表格基本都支持，其他的特性就很依赖编辑器的具体实现了； ","date":"2022-01-11","objectID":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/:8:0","tags":["markdown","工具"],"title":"Markdown语法总结","uri":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/"},{"categories":["脚本"],"content":"表格 表格基本用法 表格使用英式竖向分隔线|和短横-来构建，举例如下： 输入内容(第一行表头,第二行表格分割线,第3~n行都是主体内容)： |设备|iPhone11| macBookPro| 小米10|华为mate40Pro| |---| ---|---|---|---| |系统|iOS | macOS|Android|Android/Harmony| |供应商|Apple|Apple|小米|华为 | 渲染效果如下： 设备 iPhone11 macBookPro 小米10 华为mate40Pro 系统 iOS macOS Android Android/Harmony 供应商 Apple Apple 小米 华为 提示💡 : 表格内如果想显示竖线分隔符|，需要使用\\转义。 表格对齐 表格内容是可以做对齐的，只要将上述第二行的三条短横线改成 “:–\"(左对齐)、\"–:\"(右对齐)、\":-:\"(居中对齐)，每列都能单独控制对齐方式。 单元格内多行 表格内多行需要借助html，比如某行内容太长或者想分行叙述两三项内容，就可以用换行符 \u003cbr\u003e 实现单元格内换行。 表格单元格合并 markdown表格没有相关的语法，但是可以借助html标签，只要使用的编辑器支持html标签就可以渲染出来。 需要用到的标签： colspan：规定单元格可纵深的列数 rowspan：规定单元格可横跨的行数 \u003ctable\u003e的基本规则: 整体表格描述用\u003ctable\u003e和\u003c/table\u003e包裹起来； “绘制表格”的顺序从左到右，类似扫描，一行(几行)的描述，然后再从上到下； 每一行表格使用\u003ctr\u003e和\u003c/tr\u003e包裹起来； 每个单元格的实际文本内容使用\u003ctd\u003e和\u003c/td\u003e包裹起来，行列伸展的rowspan/colspan在td内声明； 单元格可以设置对齐方式，在\u003ctd\u003e范围内使用align=“left”(或right,center,justify,char)； 例如，如下描绘了“表格列合并”： 输入内容: \u003ctable\u003e \u003ctr\u003e \u003ctd\u003e东方\u003c/td\u003e \u003ctd align = \"right\"\u003e西门\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd colspan=\"2\" align = \"center\"\u003e姓氏\u003c/td\u003e \u003c/tr\u003e \u003c/table\u003e 渲染效果： 东方 西门 姓氏 如下描绘了稍微复杂的“表格行合并”： 输入内容如下(Code可展开): \u003ctable\u003e \u003ctr\u003e \u003ctd align=\"center\"\u003e类别\u003c/td\u003e \u003ctd\u003e名称\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd rowspan=\"2\" align=\"center\"\u003e颜色\u003c/td\u003e \u003ctd\u003e红色\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e黄色\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e距离\u003c/td\u003e \u003ctd rowspan=\"2\"\u003e物理单位\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e时间\u003c/td\u003e \u003c/tr\u003e \u003c/table\u003e 渲染效果： 类别 名称 颜色 红色 黄色 距离 物理单位 时间 ","date":"2022-01-11","objectID":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/:9:0","tags":["markdown","工具"],"title":"Markdown语法总结","uri":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/"},{"categories":["脚本"],"content":"代码段 代码段的高亮使用3个连续的反引号 ` 来标识代码段，并后接语言类型(针对语法高亮)，结尾处用3个反引号包围代码段。如果不接语言类型，也是可以的，不做任何语法的高亮。如下是C++的代码例子： 输入以下内容 ```c++ #include \u003ciostream\u003e int main(){ std::cout \u003c\u003c \"hello world!\\n\"; return 0; } ``` 渲染效果： #include \u003ciostream\u003e int main(){ std::cout \u003c\u003c \"hello world!\\n\"; return 0; } 提示 如果想要引述的代码块本身包含了3个连续的反引号```，那么就用连续的4个反引号````把它包围起来(上方C++的原文内容输入就是这么做的)。 markdown支持的代码段语言非常丰富 ，包括了几乎所有主流编程语言，参照比较通用的Github风格(GFM,Github Flavored Markdown)所支持的语法高亮，语言类型支持列表(参考Languages Supported by Github Flavored Markdown)如下列表(Code可展开)： actionscript3 apache applescript asp brainfuck c cfm clojure cmake coffee-script, coffeescript, coffee cpp cs csharp css csv bash diff elixir erb - HTML + Embedded Ruby go haml http java javascript json jsx less lolcode make - Makefile markdown matlab nginx objectivec pascal PHP Perl python profile - python profiler output rust salt, saltstate - Salt shell, sh, zsh, bash - Shell scripting scss sql svg swift rb, jruby, ruby - Ruby smalltalk vim, viml - Vim Script volt vhdl vue xml - XML and also used for HTML with inline CSS and Javascript yaml ","date":"2022-01-11","objectID":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/:10:0","tags":["markdown","工具"],"title":"Markdown语法总结","uri":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/"},{"categories":["脚本"],"content":"目录树 markdown可以自动生成目录，一般在文档的开头位置，单独一行输入[TOC]，如果编辑器支持，是可以自动生成目录树的，支持点击跳转。 ","date":"2022-01-11","objectID":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/:11:0","tags":["markdown","工具"],"title":"Markdown语法总结","uri":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/"},{"categories":["脚本"],"content":"任务列表 任务列表特别适合记录TODO-List，复盘每天/每周的工作哪些做了，哪些没做。具体语法为“短横+空格+中括号[ ]”中括号内为空格表示不勾选，写入字母x则表示选中☑️,如下: 输入内容: - [x] 基础功能Api完成 - [x] 各项功能单元测试 - [x] 测试部提测 - [ ] 提测反馈修复与迭代 - [ ] 正式发版 渲染效果: 基础功能Api完成 各项功能单元测试 测试部提测 提测反馈修复与迭代 正式发版 ","date":"2022-01-11","objectID":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/:12:0","tags":["markdown","工具"],"title":"Markdown语法总结","uri":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/"},{"categories":["脚本"],"content":"标题ID 标题ID(heading IDs)这个功能其实是用来给某级标题做个自定义的id标记，方便阅读者在另外一个位置通过这个指定的id跳转的。举例，本文的扩展语法下的代码段那一节的标题给他添加Heading-id，id标记名为\"code-block”，则那一行的标题后要追加该id，写作： ## 代码段 {#code-block} “代码段”这个标题渲染后看起来没什么不同。但是，我在本节，这个位置新增[转到代码段](#code-block),显示效果像链接，点这个跳转👉 转到代码段。就成功的跳转到了那一节的标题处。 其他用法：还可以用于给出远端链接时，那篇文章本身带有Heading-id，这样访问链接时直接跳转到指定的章节，而不是从头读起。 给出带有标题Id的链接格式为: [链接描述](链接地址/#heading-id名)，举例如下： [markdown-guide的heading-id章节](https://www.markdownguide.org/extended-syntax/#linking-to-heading-ids) 渲染效果(点击后可根据heading-id直接跳转到指定章节)： markdown-guide的heading-id章节 ","date":"2022-01-11","objectID":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/:13:0","tags":["markdown","工具"],"title":"Markdown语法总结","uri":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/"},{"categories":["脚本"],"content":"高亮背景色 这个功能用的相对比较少，但是如果使用的markdown编辑器支持html的，渲染效果也不错。 用法： 使用\u003cmark\u003e高亮背景内容\u003c/mark\u003e来实现突出重要内容，渲染效果： 高亮背景内容 ","date":"2022-01-11","objectID":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/:14:0","tags":["markdown","工具"],"title":"Markdown语法总结","uri":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/"},{"categories":["脚本"],"content":"上标下标 同样地，使用html标签语法来实现该功能： 上标用法：使用\u003csup\u003e上标内容\u003c/sup\u003e来实现上标效果，比如输入 国际认证商标\u003csup\u003eTM\u003c/sup\u003e，渲染效果：国际认证商标TM 下标用法：使用\u003csub\u003e下标内容\u003c/sub\u003e来实现下标效果，比如输入 水的分子式为H\u003csub\u003e2\u003c/sub\u003eO，渲染效果：水的分子式为H2O 提示：如果是要写数学公式，单就这2个是完全不够的，直接在Markdown编辑里找到math公式支持的设置，打开即可(或者是安装其对应的数学插件)，较为通用的有 mathJax , Katex 等。 ","date":"2022-01-11","objectID":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/:15:0","tags":["markdown","工具"],"title":"Markdown语法总结","uri":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/"},{"categories":["脚本"],"content":"Emoji表情 某些编辑器是支持使用Emoji表情的，具体用法：使用2个英式冒号包围表情短码,短码(short-code，可以理解为代号)的。举例如下： 输入内容 渲染效果 :roll_eyes: 🙄 :rofl: 🤣 :man_shrugging: 🤷‍♂️ :thinking: 🤔 :snail: 🐌 :house_with_garden: 🏡 :cn: 🇨🇳 这只是其中的几个表情，还有大量的Emoji表情，如官方列举👉：list of emoji short-codes. 参考链接 Markdown Guide - Basic Syntax Markdown Guide - Extended Syntax Markdown官方教程中文版 Toast-lab - Markdown Syntax ","date":"2022-01-11","objectID":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/:16:0","tags":["markdown","工具"],"title":"Markdown语法总结","uri":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/"},{"categories":["计算机图形学"],"content":"摘要：Fundamentals of Computer Graphics第四版，原书第3章Raster Image的总结","date":"2022-01-10","objectID":"/2022/01/09_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93_%E7%AC%AC3%E7%AB%A0%E5%85%89%E6%A0%85%E5%8C%96/","tags":["图形渲染","英文原本"],"title":"Fundamentals of Computer Graphics第3章总结_(光栅化)","uri":"/2022/01/09_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93_%E7%AC%AC3%E7%AB%A0%E5%85%89%E6%A0%85%E5%8C%96/"},{"categories":["计算机图形学"],"content":"0. 前言 原书第四版pdf下载链接：Github: t4world/Computer-Graphics 本文为原书第3章总结，主要讲述光栅化的一些基本概念，对光栅化设备和一些光栅化流程有个基本的认知。 光栅这个单词“Raster”在德语/英语中就是“屏幕，栅格”的意思，故名思义，就是将图像显示在屏幕上。现代的通用平板显示器是以红色，绿色，蓝色这三种原色以特定的配比，辅以矩阵式的数量庞大的像素(pixel,其实来源于picture element的缩写)，显示我们最终需要的图像。 其实光栅化设备的意义比较宽泛，激光打印机(laser printer)、喷墨式打印机(ink-jet printer)其实也在范畴内，它们是基于扫描原理，没有行列式的栅格。 大多数图像是有固定的pixel级别尺寸的，比如1920x1080，这就是图像的width*height的尺寸。也有不被pixel-size约束的图，就是有向图(vector image)，是没有分辨率而言的，颜色的区域划分取决于线条和形状，不特指到像素级别，缩放也不会改变清晰度，通常用于文本、流程图、机械图等。 关于有向图，除了网页的svg图标被广泛应用外，流程图也是极力推荐的。 diagrams软件画出来的draw.io流程图可以导出svg有向图，完美保留了清晰度和节约了内存。 1. 光栅化设备 光栅化设备(Raster Devices)可以简单的分为2类： 输出设备 用于显示：包含透射式的液晶显示器LCD(liquid crystal display)、和自发光式的LED显示器(light-emitting diode) 用于硬拷贝：二进制的输出，即喷墨式打印机；或者是连续色域输出的热染料升华打印机(dye sublimation printer) 输入设备 2维阵列式：数码相机 1维线性式：平台扫描仪(flatbed scanner) ","date":"2022-01-10","objectID":"/2022/01/09_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93_%E7%AC%AC3%E7%AB%A0%E5%85%89%E6%A0%85%E5%8C%96/:0:0","tags":["图形渲染","英文原本"],"title":"Fundamentals of Computer Graphics第3章总结_(光栅化)","uri":"/2022/01/09_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93_%E7%AC%AC3%E7%AB%A0%E5%85%89%E6%A0%85%E5%8C%96/"},{"categories":["计算机图形学"],"content":"1.1 显示 自发光式的LED二极管显示器，通过控制阳极、阴极的电流强度来控制是否发光，以及发光的强度。 每个像素，都由若干个子像素组成，子像素通常是由RGB这3原色构成，示意图如下： 而透射式的LCD液晶显示器则需要其他的光源照亮它，也就是俗称的“背光”。 具体原理是当光透过偏光片1--\u003e液晶板--\u003e偏光片2这样的结构时，中间的液晶块是可以旋转光的偏振方向的(也叫极化方向 )。加载的电压不同，旋转的角度不同，最后通过偏光片2的光量就可控了（偏振方向平行于偏光片可全部通过，垂直则全部不通过）。下方示意图是旋转了90度，全部通过的情况： 不论是LED还是LCD，成型后，都是由固定尺寸的像素阵列组成的，也就有了固定的分辨率。比如形容一块显示器为1920*1080，是指宽度方向有1920个像素点，高度方向有1080个像素点。 ","date":"2022-01-10","objectID":"/2022/01/09_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93_%E7%AC%AC3%E7%AB%A0%E5%85%89%E6%A0%85%E5%8C%96/:1:0","tags":["图形渲染","英文原本"],"title":"Fundamentals of Computer Graphics第3章总结_(光栅化)","uri":"/2022/01/09_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93_%E7%AC%AC3%E7%AB%A0%E5%85%89%E6%A0%85%E5%8C%96/"},{"categories":["计算机图形学"],"content":"1.2 硬拷贝 常见的喷墨式打印机如下图，打印喷头来回扫描移动，在特定的位置喷洒颜料，只能打印二值图像（all-or-nothing，某个点着色与否，没有中间态）。分辨率（清晰度）取决于喷墨的颜料颗粒大小和纸张移动的精细程度。 常见的热染料打印机如下图，打印头加热燃料升华，附着在打印纸上，因为打印喷头输出的热量是线性连续的，打印的图像可以有颜色深浅区分了（即continuous tone）。打印的分辨率取决于\"加热-升华-附着 “这一过程和打印纸移动速度的比值。 关于打印机的分辨率，理解2个概念： ppi : 即每英寸有多少个像素(pixels per inch)，一般用于描述连续色调的热染料打印机，比如300ppi； dpi : 即每英寸有多少个点(dot per inch)，一般用于描述二值打印的喷墨式打印机，比如1200dpi. ","date":"2022-01-10","objectID":"/2022/01/09_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93_%E7%AC%AC3%E7%AB%A0%E5%85%89%E6%A0%85%E5%8C%96/:2:0","tags":["图形渲染","英文原本"],"title":"Fundamentals of Computer Graphics第3章总结_(光栅化)","uri":"/2022/01/09_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93_%E7%AC%AC3%E7%AB%A0%E5%85%89%E6%A0%85%E5%8C%96/"},{"categories":["计算机图形学"],"content":"1.3 输入设备 图像的输入设备主要为照相机和扫描仪。 数码相机原理为通过镜头投影光线，透过颜色滤波片，投射到2D阵列式的传感器(CCD或CMOS)，记录每个像素的着色情况（每个像素只着色RGB三者之一）。 拍照像素的光学分辨率 也是固定尺寸的，比如3000x2000，那么相乘后得到6000000,即6百万像素(6MP, megapixel)。 这里的megapixel，是$10^6$，而不是计算机的兆字节(MB, megabytes = $2 ^{10}$ Bytes)。 2. 图像,像素与几何 人们采样像素这一概念对存储于计算机的图像，进行描述和细致的计算。从图像矩形阵列到像素值的映射表示： $$ I(x,y): R \\rightarrow V , $$ 其中$R$描述了矩形区域，$V$表示像素的RGB值。 一个像素，反映的其实是这个点附近一小块区域的RGB颜色平均值。 如果一张图的尺寸为$n_x$列和$n_y$行，那么起始点坐标为 $(0,0)$，比如左下角为起始点（不同的API的纹理起始点不同，可能是左上角/左下角），右上角坐标为$(n_x -1,n_y -1)$。例如下图为$n_x = 4,n_y = 3$ : 图像区域内的点坐标的定义域 x 值域为： $$ R = [-0.5 , n_x - 0.5] × [-0.5, n_y - 0.5]$$ ","date":"2022-01-10","objectID":"/2022/01/09_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93_%E7%AC%AC3%E7%AB%A0%E5%85%89%E6%A0%85%E5%8C%96/:3:0","tags":["图形渲染","英文原本"],"title":"Fundamentals of Computer Graphics第3章总结_(光栅化)","uri":"/2022/01/09_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93_%E7%AC%AC3%E7%AB%A0%E5%85%89%E6%A0%85%E5%8C%96/"},{"categories":["计算机图形学"],"content":"2.1 像素值 像素值的存储格式直接影响内存大小，比如32bit的浮点值和8bit的整型值就是4倍差距。所以像素值的存储格式结合使用场景分成了许多种类，以下是一些经典像素格式和应用类型： 像素格式/bit 应用场景 1 0/1二值图，文本显示或是高分辨率的灰度图 8 整型RGB图，共24bits：浏览器、邮件、用户照片 8 ~ 10 整型RGB图，共24~30bits：计算机显示器的数字接口 12 ~ 14 整型RGB图，共36~42bits：专业相机的原始图 16 整型RGB图，共48bits：专业摄影与打印，图像处理的中间结果 16 整型灰度图，共16bits：X光与医学影像 16 浮点值RGB图，共48bits(half-float)：HDR图像，或实时渲染的中间结果 32 浮点值RGB图，共96bits：HDR图像，或软件渲染的中间结果 Ps：上述整形RGB图在原书中为\"fixed-range RGB”，其实固定范围是指RGB值处于min~max(比如0~255的unsigned char类型)，一般就是相对浮点值来说的。另外，这里暂不考虑RGBA的Alpha通道。 像素格式的转变比较常见，如果是像素bit缩减可能有2方面副作用： 整型RGB图像编码时，超出max范围的会被截断为max； 有限的精度会带来量化误差，色彩体现就是像色彩带一样颜色跳变，对静止图像无影响，对动画或者视频影响比较明显； ","date":"2022-01-10","objectID":"/2022/01/09_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93_%E7%AC%AC3%E7%AB%A0%E5%85%89%E6%A0%85%E5%8C%96/:4:0","tags":["图形渲染","英文原本"],"title":"Fundamentals of Computer Graphics第3章总结_(光栅化)","uri":"/2022/01/09_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93_%E7%AC%AC3%E7%AB%A0%E5%85%89%E6%A0%85%E5%8C%96/"},{"categories":["计算机图形学"],"content":"2.2 显示器强度与Gamma校正 由于显示器的物理特性，“输入pixel-value –\u003e 输出亮度intensity-level”这一过程并非线性的。 而且像素值取值范围$[0,1]$，于是人为地映射“pixel-0” $\\rightarrow$ “min-intensity” ，以及“pixel-1” $\\rightarrow$ “min-intensity”。 使用以下公式可以近似地表述这种关系： $$displayed \\_intensity = (maximum \\_intensity)\\alpha ^ \\gamma$$ 其中$\\alpha$是像素值，范围$[0,1]$，$\\gamma$(读作gamma)是与显示器有关的属性值，作为这种非线性关系映射的近似值。 那么这个$\\gamma$值如何测量呢，一般是通过“半灰度测试”得来：调节像素值$\\alpha$，使得发光强度为一半。 此时$displayed \\_intensity = 0.5(maximum \\_intensity)$， 即$0.5=\\alpha^{\\gamma}$，那么根据计算：$$\\gamma = \\frac{\\ln 0.5}{\\alpha}$$ 即可求得$\\gamma$值。 下方就是“半灰度测试”，左图为黑白棋盘格，其实就是0.5亮度参考，右图pixel-value，直到和左图发出的光强基本一致(这个观察通常要距离远一点，棋盘格看起来是全灰图)，记录此时的像素值$\\alpha$。 得到了$\\gamma$值后，就需要\"gamma校正“了，要让“输入pixel –\u003e 显示强度”之间看起来是线性的。 只要令: $${\\alpha}^{'} = {\\alpha}^{\\frac{1}{\\gamma}} $$ 代替输入的像素值$\\alpha$，即可得到： $$displayed \\_intensity = (maximum \\_intensity)\\alpha$$ 3. RGB颜色 现代计算机图形学的光学三原色定为“红-绿-蓝”，即RGB，这是典型的增色系(additive color)。 资料拓展💡 相对地，也有减色系(subtractive color)的三原色，颜料的原色（也是彩色印刷的原色） ，CMYK，青(cyan)-品(magenta)-黄(yellow)。其实就是针对RGB三者的反色：(1，1，1) -(r,g,b)(假设像素值范围$[0,1]$)。 相减是因为人们看到物体的颜色是反射出来的，被吸收的部分看不见。多出来的K是黑色，是为了减少颜料使用，纯黑更容易调出来。 常见的RGB颜色以及基本调配有： 颜色 RGB值 备注 红色(red) $(1,0,0)$ 绿色(green) $(0,1,0)$ 蓝色(blue) $(0,0,1)$ 青色(cyan) $(0,1,1)$ 蓝+绿，也叫blue-green 品红(magenta) $(1,0,1)$ 红+蓝，也叫purple 黄色(yellow) $(1,1,0)$ 红+绿 黑色(black) $(0,0,0)$ 白色(white) $(1,1,1)$ 理论上不同的$(r,g,b)$取值组合可以得到所有的RGB颜色，也一定处于下方RGB颜色立方内的某一点（右图为RGB立方的六面展开图）： 4. 透明度混合 许多场景下，我们不需要完全覆盖像素内容，只需要覆盖一部分，比如全透明、半透明材质、树叶缝隙透光等情况。基于此，建立了“前景-背景-混合mask”这样的模式。假设前景色彩为$C_f$，背景色彩为$C_b$，前景覆盖的比例为$\\alpha$（取值范围$[0,1]$），则最终的色彩$C$计算方式： $$C = \\alpha C_f + (1 - \\alpha) C_b$$ 上述的$\\alpha$其实就是透明度通道，对于一张图，每个像素都有这个$\\alpha$值，存储时可以另外寸一张灰度图作为mask，更常用的是紧跟RGB数据，形成RGBA数据。 一般而言，RGBA数据是默认$\\alpha$通道为1，有透明度混合需求才会对其赋值和运算。 ","date":"2022-01-10","objectID":"/2022/01/09_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93_%E7%AC%AC3%E7%AB%A0%E5%85%89%E6%A0%85%E5%8C%96/:5:0","tags":["图形渲染","英文原本"],"title":"Fundamentals of Computer Graphics第3章总结_(光栅化)","uri":"/2022/01/09_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93_%E7%AC%AC3%E7%AB%A0%E5%85%89%E6%A0%85%E5%8C%96/"},{"categories":["计算机图形学"],"content":"4.1 图像存储 未经压缩的原始图像的内存占用会非常大，考虑一张$1900 \\times 1080$ 的RGB-8Bit图，需要内存$1920 \\times 1080 \\times 3 =6220800 Bytes \\approx 6.2MB$ ，如果再考虑8Bit以上或者Alpha通道数据，耗费内存更大，所以突出图片压缩的重要性。 保留图片所有信息或者解压缩时可还原信息的压缩叫无损压缩(lossless compression)，压缩过程中丢失信息且不可恢复的叫有损压缩(lossy compression)。 常用的图片压缩格式列举一部分如下： 图片格式 压缩类型 备注 jpeg 有损 基于人类视觉系统压缩，去除那些人眼不铭感的信息 tiff 无损 保存二进制数据或8bit，16bit的无损图 ppm 无压缩 格式非常简单，通常保存8-bit的RGB图 png 无损 分为PNG-8，和PNG-24，前者更常用，后者图像质量更高 $$\\text{——————– Chapter3(完结) @2022-2-21 ——————–}$$ ","date":"2022-01-10","objectID":"/2022/01/09_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93_%E7%AC%AC3%E7%AB%A0%E5%85%89%E6%A0%85%E5%8C%96/:6:0","tags":["图形渲染","英文原本"],"title":"Fundamentals of Computer Graphics第3章总结_(光栅化)","uri":"/2022/01/09_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93_%E7%AC%AC3%E7%AB%A0%E5%85%89%E6%A0%85%E5%8C%96/"},{"categories":["脚本"],"content":"摘要：针对工作中比较常用的一些Git命令做记录，希望能自己备忘的同时能帮到你","date":"2022-01-02","objectID":"/2022/01/08_git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%80%BB%E7%BB%93/","tags":["git","工具链"],"title":"常用Git命令行总结","uri":"/2022/01/08_git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%80%BB%E7%BB%93/"},{"categories":["脚本"],"content":"forward 众所周知，Git 是程序员们重度使用的工具，以下对开发过程中常用命令做个总结备忘，也会谈一些简单的技巧使Git更好用。 以下所有命令行不区分平台，windows建议使用GitBash，Linux/MacOS建议使用原生Terminal或第三方终端(item2)。 Git不同版本之间，某些指令支持可能会有差异，尽量用新版本吧。本文撰写时使用的版本为 windows-gitbash的 git-2.31.1 ，和 mac-terminal 的 git-2.32.0。 git config 使用git config命令尽心git的配置，常用命令如下： 命令 作用 git config --list 打印出当前环境的git配置信息， 接--global可以打印全局配置 git config user.name benjamin git配置username为benjamin,可后接--global git config user.email xxx@gxx.com git配置email为xxx@gxx.com,可后接--global git config --global core.autocrlf false windows总提示CR/LF的警告，设置后可去除 git config --global credential.helper store 终端环境保存https的密钥，避免每次都要密码 git config --global core.quotepath false 用来解决git status 显示中文乱码的问题 git-bash需要鼠标右键,找到选项-\u003e文本-\u003e本地Locale，设置为zh_CN，而旁边的字符集选框选为UTF-8 当然，除了命令行配置，还可以直接编辑文件~/.gitconfig文件，但是请清楚修改的具体含义，避免出现git后续使用的不必要的错误。 git init 如果不依赖任何远端仓库，而是自行本地新建仓库并初始化，使用git init即可。 示例如下，创建一个名为 MyGitRepo的仓库： cd ~/Documents mkdir MyGitRepo cd MyGitRepo git init 在git init 执行后，执行ls -a可以看到多了一个 .git 文件夹，这就是git的主干文件了。 接下来就可以新建文件，然后添加了，以及后续上传到远端。 git clone 然而大多数时候，我们并不需要自己新建，而是需要从远端Git仓库获取已经有的仓库。 不论是Github,还是Gitlab，拿到一个远程git仓库地址后，第一件事就是克隆(下载)到本地主机，git clone命令的作用正在于此，假如现在想克隆Facebook的C++开源库 folly ，仓库地址为：https://github.com/facebook/folly.git,在一个本地目录打开命令行，执行： cd ~/Downloads git clone https://github.com/facebook/folly.git 命令执行完成后即可(如果因为网络失败，则可能需要git加速，或者代理加速了)。 By the way 如果因为网络的原因，clone的速度太慢，或者报错。有2种方法可以尝试: Github的镜像站进行加速 只需要把https://github.com替换成https://hub.fastgit.org即可。 上述命令变为： git clone https://hub.fastgit.org/facebook/folly.git Git加速工具 Dev-SideCar工具，Gitee地址：Gitee dev-sidecar git add/restore Git操作一个新文件的流程为：工作区(也就是本地文件)–\u003e 暂存区(staged) –\u003e 仓库，如下图所示： 直接基于已有的仓库操作，上文的Folly仓库，新增一个文件，假如是我们学习Folly的笔记。 cd cd ~/Downloads/folly touch Learn.md echo \"# MultiThread Content\" \u003e\u003e Learn.md #手动写点内容 git status #Git提示：Learn.md 是\"Untracked files\",颜色是红色 git add Learn.md #add到暂寸区 git status #Git提示：Learn.md 是\"Changes to be committed\",颜色是绿色 git commit -m \"new lesson note\" # Git提示：1 file changed, 1 insertion(+),进入仓库 git status #没有文件提示，会说明当前分支和远端分支的关系 git log -3 #可以看到刚才的一笔提交，处于最前面 有时候，git add想要排除一些文件，除了add之后restore，还可以在添加的时候就排除。示例： git add --all ':!filename1' ':!*.txt' git add . ':!submoduleNamexx' 说了添加，接下来说下几种程度的撤回，以前都是用checkout，但是后来引入了新词 restore，更能准确体现含义。 命令 作用 git restore \u003cfile/dir\u003e 回退掉还没有add的untracked file； 后接文件或目录,一个点表示当前目录所有，慎用 git restore --staged \u003cfile/dir\u003e 回退掉已经add,但还没有commit的tracked file；后接文件或目录,一个点表示当前目录所有 git reset git reset承担着节点回退的功能，命令示范如下： 命令 命令 git rest HEAD~n 回退掉当前n个节点，回到没有add 的untracked状态(红色); 注意，其实是隐藏了--mixed的参数了，默认就是它; n一般取1，HEAD~n也可以换成一个具体的commit-ID git rest --soft HEAD~n 和–mixed的区别是，是回到已经add，但是没有commit的状态(绿色) git rest --hard HEAD~n 回退的最彻底，连untracked的本地修改也没了，慎用; 如果误用，可以使用git reflog show出历史，然后找回 注意：回退的过程最容易丢代码，虽然 reflog 是一大利器，但是不是永久保存，只有90天的记录。 git branch/switch git branch,git checkout,以及git switch承担着分支管理的一部分作用，命令示范如下： 命令 作用 git branch 查看本地所有分支，(当前所处分支会绿色高亮) git branch -va 查看仓库所有分支(包括本地和远端) git branch -vv 查看当前分支关联的远程分支 git branch --set-upstream=origin/main 设置当前分支与远端的origin/main分支关联 git branch my1.1 V1.1 基于名为V1.1的tag创建一个本地分支my1.1 git branch -D my1.0 删掉名为my1.0的分支 git checkout -b tmpMain origin/main 基于origin/main，创建一个名为tmp的本地分支 origin/main可以不写，则默认基于本地当前分支 git switch feature2 切换到名为feature2 的分支 git fetch/pull git fetch为获取，目的为拿到远端的改动，存在仓库，不对本地文件和分支做任何改动。 git pull为拉取，实际动作为git fetch + git merge,会拉取到远端改动并合并到当前本地分支。如果有冲突，需要解决冲突。 git commit git commit即为提交，作用为将已经add到暂存区的文件进行提交，使用方式为git commit -m \"commit信息描述\"，这里要说的是commit的其他参数： 命令 作用 git commit --amend 针对最新的这笔commit，追加内容，形成新的commit git commit --author=\"user\u003cemail-addr\u003e\" 这个是针对某笔commit，可以修改作者; 多个账号提交错误时可以挽救 git commit -am \"commit信息描述\" 针对还没add的文件，相当于 add+commit 一步到位 git log git log的参数实在是多，这里简单的列出常用的几条： 命令 作用 git log -n \u003cbranch_name\u003e 查看指定分支log，最新n条修改 不接分支名，都是默认当前本地分支 git log -n --oneline 每条commit只打印一行信息，方便查看，查看前n条 git log -n --author=\u003cauthor_name\u003e 查看指定作者, 查看满足条件的前n条 git log -n -- \u003cpath_or_file\u003e 查看某个指定的文件/文件夹, 查看前n条 git log -n --grep=\"your_key_words\" 搜索指定的commit信息关键词, 查看满足条件的前n条 git log -n --graph --abbrev-commit 查看最新n条提交，以树形图列出，且commit-id为前几位 git log ","date":"2022-01-02","objectID":"/2022/01/08_git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%80%BB%E7%BB%93/:0:0","tags":["git","工具链"],"title":"常用Git命令行总结","uri":"/2022/01/08_git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%80%BB%E7%BB%93/"},{"categories":["脚本"],"content":"add submodule 执行git submodule add \u003cremote-URL\u003e \u003clocal_path\u003e可以添加一个子模块到本仓库，local_path 如果省略，则是添加到当前目录。 🎈注意： local_path的结尾最好是和子模块的仓库名同名，不然仍旧会创建一个子仓库同名的目录。 还是针对上述的folly库，给他手动新增一个第三方图像库作为子模块，添加后自动克隆。 cd ~/Downloads/folly git submodule add https://github.com/nothings/stb.git 3rdImg/stb 根目录下.gitmodules文件的内容自动发生改动： $ cat .gitmodules [submodule \"3rdImg/stb\"] path = 3rdImg/stb url = https://github.com/nothings/stb.git ","date":"2022-01-02","objectID":"/2022/01/08_git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%80%BB%E7%BB%93/:1:0","tags":["git","工具链"],"title":"常用Git命令行总结","uri":"/2022/01/08_git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%80%BB%E7%BB%93/"},{"categories":["脚本"],"content":"update submodule 有时候，子模块是远程仓库自带的，第一次克隆下来后需要手动 初始化+同步 ，执行： rm -rf 3rdImg/stb/ #试验一下，将已有的先删除 git submodule update --init --recursive #这时发现文件又全都回来了 如果不是第一次同步子模块，可以不需要--init参数。 子模块其实和文件类似，只是在仓库中，它的修改，是它的commit节点来记录和判别的。 如果子模块向前更新了，主仓库要添加这笔改动的话，像普通文件一样，git add --\u003e git commit --\u003e git push，一套流程带走子模块。 ","date":"2022-01-02","objectID":"/2022/01/08_git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%80%BB%E7%BB%93/:2:0","tags":["git","工具链"],"title":"常用Git命令行总结","uri":"/2022/01/08_git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%80%BB%E7%BB%93/"},{"categories":["脚本"],"content":"remove submodule 子模块的删除并非像添加时那么简单轻松，注意按下述顺序操作： 回退.gitmodules文件的修改,git restore回退之后git add暂存； 删除目录树和索引文件，执行: git rm --cached path_to_submodule,(path_to_submodule替换成实际路径); 删除.git目录的文件记录，执行：rm -rf .git/modules/path_to_submodule; 删除本地文件：rm -rf path_to_submodule，最后git commit上述修改即可完全删除子模块 。 other commands 命令 作用 git remote -v 查看仓库的远端地址 git name-rev \u003ccommit-id\u003e 根据一个commit-ID确定该节点来自于哪个分支，ID可取前9位 git merge-base --fork-point br1 br2 打印出分支br1和分支br2的最新共同祖先节点SHA值（共同节点：形状上类似2条单链表的共同节点） 参考链接： Git Rebase的原理详解 ","date":"2022-01-02","objectID":"/2022/01/08_git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%80%BB%E7%BB%93/:3:0","tags":["git","工具链"],"title":"常用Git命令行总结","uri":"/2022/01/08_git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%80%BB%E7%BB%93/"},{"categories":["计算机图形学"],"content":"摘要：Fundamentals of Computer Graphics第四版，原书第2章Miscellaneous Math的总结","date":"2021-12-27","objectID":"/2021/12/07_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/","tags":["图形渲染","英文原本"],"title":"Fundamentals of Computer Graphics第2章总结_(杂项数学)","uri":"/2021/12/07_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":" 序言：看原书第二章后做的笔记，关键术语留有英文注解, 有些内容补充了自己的理解，并非直接翻译原文。 本人水平有限，若有不当之处，欢迎交流与指正，谢谢。 原书第四版pdf下载链接：Github: t4world/Computer-Graphics Markdown 数学公式语法参考: Cmd Markdown 公式指导手册 1 集合与映射 通常，我们所指的函数是映射(mapping)的一种特殊情况。映射是集合A到集合B的一种对应关系。 笛卡尔积(Cartesian product)$A$x$B$是2个集合的元素的所有可能组合，即a$\\epsilon$A, b$\\epsilon$B,对所有可能的有序组合(a,b)。$A$ x $A$简写为$A^2$,以下常用符号： 符号 意义 $R$ 实数 $R^+$ 非负实数 $R^2$ 2维实数平面 $R^n$ n维实数笛卡尔空间 $Z$ 整数 $S^2$ 3D单位球面上的点 映射的表示方法 使用冒号和箭头,举例: $f: R \\rightarrow Z$ 其中前者为定义域(domain),后者为值域(target). 从编程语言的角度来看，也可以认为是 参数为$R$，返回值为$Z$。 ","date":"2021-12-27","objectID":"/2021/12/07_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:0:0","tags":["图形渲染","英文原本"],"title":"Fundamentals of Computer Graphics第2章总结_(杂项数学)","uri":"/2021/12/07_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"1.1 逆映射 通常所说的反函数是一种逆映射。 对于一个映射 $f: A \\rightarrow B$,那么可能存在逆映射 $f^{-1} : B \\rightarrow A$. 即 对于 $b = f(a)$,有$f^{-1}(b)=a$. 存在逆映射的条件是： 对每一个b$\\epsilon$B,存在唯一确定的$a\\epsilon A$满足$f(a)=b$. 若在满足逆映射的条件下，此时f是函数，(即 对每一个a$\\epsilon$A,有唯一确定的b=f(a)),此时这种特殊的映射关系称为双射(bijection), $f$和$f^{-1}$互为反函数，值域和定义域对调。 反函数例子: f: R $\\rightarrow$ R,函数f(x)=$x^3$ ,反函数$f^{-1}(x)=\\sqrt[3]x$ ","date":"2021-12-27","objectID":"/2021/12/07_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:1:0","tags":["图形渲染","英文原本"],"title":"Fundamentals of Computer Graphics第2章总结_(杂项数学)","uri":"/2021/12/07_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"1.2 区间 关于是否包含区间边界值，分为开区间和闭区间以及半开区间。 涉及到图形的表示，注意，例如表示一个单位立方体的3D区间，立方体内的点$x$可以表示为$x \\epsilon [0,1]^3$. 区间还有个方便之处，区间运算，并集(union,符号$\\cup$)，交集(intersection,符号$\\cap$)，差集(difference,符号-)等。 ","date":"2021-12-27","objectID":"/2021/12/07_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:2:0","tags":["图形渲染","英文原本"],"title":"Fundamentals of Computer Graphics第2章总结_(杂项数学)","uri":"/2021/12/07_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"1.3 对数 对数是相对于指数关系而生的，针对一个底数a，求它的多少次方为x. 表现形式如下： $$y = \\log_a x \\iff a^y = x $$ 复习几个常用的公式： $a^{\\log_a (x )} = x$ $\\log_a {(a^x)} = x$ $\\log_a (xy) = \\log_a x +\\log_a y$ $\\log_a (x /y) = \\log_a x - \\log_a y$ $\\log_a x = \\log_a b \\cdot \\log_b x$ 有个特殊的底数为$e=2.718…$,用它作底数，那么对数形式则会简写为： $$\\ln x \\equiv \\log_e x$$ 它和指数函数的导数形式分别如下： $\\frac {d}{dx} \\log_a{x}=\\frac{1}{x\\ln a}$ $\\frac {d}{dx} a^{x} =a^x \\ln a$ $\\text{上述公式当a = e 时}, \\ln a = 1.$ 2 求解二次方程 复习一下初中数学知识, 一元二次方程的一般形式： $$Ax^2 + Bx + C = 0,$$ 求根判别式(discriminant)为 $\\Delta = B^2 - 4 \\cdot A \\cdot C$，有三种情况: $\\Delta\u003c0:$ 方程没有根 $\\Delta=0:$ 方程只有一个根, $x_0 =x_1 =\\frac{-B}{2A}$ $\\Delta\u003e0:$ 方程有2个根, $x_0= \\frac{-B+\\sqrt{\\Delta}}{2 \\cdot A} , x_1= \\frac{-B-\\sqrt{\\Delta}}{2 \\cdot A}$ 个人经验：注意, 开方和除法开销昂贵，图形学中为了简化运算，提倡对$x_0,x_1$ ,做简化： $\\text{令 }\\Delta _2 = {(\\frac{B}{2})}^2- A \\cdot C$ , 则 $x_0= \\frac{-(\\frac{B}{2})+\\sqrt{\\Delta _2}}{A} , x_1= \\frac{-(\\frac{B}{2})-\\sqrt{\\Delta _2}}{A}$ 3 三角学 ","date":"2021-12-27","objectID":"/2021/12/07_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:3:0","tags":["图形渲染","英文原本"],"title":"Fundamentals of Computer Graphics第2章总结_(杂项数学)","uri":"/2021/12/07_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"3.1 角度 如下图所示，角度由2条射线(half-line)组成,射线将圆分成了2段弧(arc)，弧线长度即为角度大小,角度有正负之分,逆时针方向为正(counterclockwise)，图中的角度 $\\Phi$ 即为短的那段弧。按照这样的定义，角度值的取值范围为$[-\\pi , \\pi]$ 角度制(degrees)和弧度制(radians)的转换，因为整圆是$360^\\circ$,也是弧度制的$2\\pi$, 所以角度转换如下： $$degrees = \\frac{180}{\\pi} \\cdot radians$$ ","date":"2021-12-27","objectID":"/2021/12/07_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:4:0","tags":["图形渲染","英文原本"],"title":"Fundamentals of Computer Graphics第2章总结_(杂项数学)","uri":"/2021/12/07_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"3.2 三角函数 说起三角函数，先复习勾股定理(也叫毕达哥拉斯定理，$Pythagorean-theorem$),如下图所示，简单的证明了斜边(hypotenuse)平方为2条直角边的平方和。 $$a^2 + o^2 = h^2,$$ 由此定义了正弦(sine),反正弦(arc sine),余弦(cosine),反余弦(arc cosine),正切(tangent),反正切(arc tangent). 函数 $\\sin \\Phi $ $\\csc \\Phi $ $\\cos \\Phi $ $\\sec \\Phi $ $\\tan \\Phi $ $\\cot \\Phi $ 值 $ o/ h$ $ h/ o$ $ a/h$ $ h/a$ $ o/a$ $ a/o$ 涉及到图形学中的方位角(直角坐标和极坐标的映射)，有个实用的函数$atan2$,它比$atan$的数值更稳定,且值域更广，对于一个笛卡尔(Cartesian)直角坐标$(x,y)$如下所示： $$ atan2(y,x)= \\begin{cases} arctan(\\frac {y}{x}), \u0026 \\text { x \u003e 0} \\\\ arctan(\\frac {y}{x}) + \\pi, \u0026 \\text{ $y \\geq 0$,x\u003c0} \\\\ arctan(\\frac {y}{x}) - \\pi, \u0026 \\text{ y \u003c 0,x\u003c0} \\\\ +\\frac{ \\pi}{2}, \u0026 \\text{ y \u003e 0,x=0} \\\\ -\\frac{ \\pi}{2}, \u0026 \\text{ y \u003c 0,x=0} \\\\ undefined, \u0026 \\text{ y = 0,x=0} \\end{cases} $$ 以上的函数定义域和值域如下： $asin : [-1,1] \\mapsto[- \\pi / 2, \\pi /2];$ $acos: [-1,1] \\mapsto[0,\\pi];$ $atan:R \\mapsto[-\\pi/2,\\pi/2];$ $atan2: R^2 \\mapsto [-\\pi, \\pi]$ ","date":"2021-12-27","objectID":"/2021/12/07_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:5:0","tags":["图形渲染","英文原本"],"title":"Fundamentals of Computer Graphics第2章总结_(杂项数学)","uri":"/2021/12/07_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"3.3 一些有用的特性 角度平移特性(高中数学老师说过,\"奇变偶不变，符号看象限\") $\\sin(-A) = - \\sin A$ $\\cos(-A) = \\cos A$ $\\tan(-A) = - \\tan A$ $\\sin(\\frac {\\pi} {2} - A) =\\cos A$ $\\cos(\\frac {\\pi} {2} -A) = \\sin A$ $\\tan(\\frac {\\pi} {2} -A) = \\cot A$ 勾股定理推导特性 ${\\sin}^2 A +{\\cos}^2 A=1$ ${\\sec}^2 A -{\\tan}^2 A=1$ ${\\csc}^2 A -{\\cot}^2 A=1$ 加减特性 $\\sin(A +B )=\\sin A \\cos B + \\sin B \\cos A$ $\\sin(A -B )=\\sin A \\cos B - \\sin B \\cos A$ $\\cos(A +B )=\\cos A \\cos B - \\sin A \\sin B$ $\\cos(A -B )=\\cos A \\cos B + \\sin A \\sin B$ $\\tan (A+B) =\\frac{\\tan A + \\tan B}{1- \\tan A \\tan B}$ $\\tan (A-B) =\\frac{\\tan A - \\tan B}{1+ \\tan A \\tan B}$ $\\sin (2A) = 2 \\sin A \\cos A$ $\\cos (2A) = \\cos ^2 A -\\sin ^2 A$ $\\tan (2A) =\\frac {2 \\tan A}{1 -\\tan ^2 A}$ 半角特性 $\\sin ^2 (\\frac{A}{2})=(1- \\cos A)/2$ $\\cos ^2 (\\frac{A}{2}) =(1+\\cos A)/2$ 积化和差 $\\sin A \\sin B = -\\frac {\\cos (A+B) -\\cos (A-B)}{2}$ $\\sin A \\cos B = \\frac {\\sin (A+B) +\\sin (A-B)}{2}$ $\\cos A \\cos B = \\frac {\\cos (A+B)+\\cos (A-B)}{2}$ 三角形特性 对于任意三角形，假设边长为$a,b,c$,三条边的对角分别为$A,B,C$，那么有以下等式： $$\\frac{\\sin A}{a} =\\frac{\\sin B}{b} =\\frac{\\sin C}{c} \\text{ (正弦定理)}$$ $$c^2 = a^2 + b^2 - 2 \\cdot a \\cdot b \\cdot \\cos C \\text{ (余弦定理)}$$ $$\\frac{a+b}{a-b} = \\frac{\\tan(\\frac{A+B}{2})}{\\tan(\\frac{A-B}{2})} \\text{ (正切定理)}$$ $$S_ \\Delta = \\frac {1}{4} \\sqrt {(a+b+c)(-a+b+c)(a-b+c)(a-b+c)(a+b-c)} \\text{ (海伦－秦九韶面积公式)}$$ $$\\text{或者，令} p = \\frac{a+b+c}{2} , S_ \\Delta = \\sqrt {p(p-a)(p-b)(p-c)}$$ 4 向量 向量，也称为矢量，通常表示为一段特定长度和特定方向的箭头$\\rightarrow$。通常，不会用来表示坐标或位置，而是偏移(offset)或者位移(displacement). ","date":"2021-12-27","objectID":"/2021/12/07_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:6:0","tags":["图形渲染","英文原本"],"title":"Fundamentals of Computer Graphics第2章总结_(杂项数学)","uri":"/2021/12/07_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"4.1 向量运算 向量加减运算符合平行四边形原则(parallelogram rule),向量加减满足交换律(commutative property),即 $\\vec {a} + \\vec {b} = \\vec {b} + \\vec {a}$ . 向量乘法有多种形式，其中，如果$\\vec {a}$与数字$k$相乘，$k$为正数则方向不变，$k$为负数则方向相反，长度则乘以$k$的绝对值.例如 $3.5 \\vec{a}$,表示方向不变，长度变为原来的3.5倍. ","date":"2021-12-27","objectID":"/2021/12/07_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:7:0","tags":["图形渲染","英文原本"],"title":"Fundamentals of Computer Graphics第2章总结_(杂项数学)","uri":"/2021/12/07_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"4.2 直角坐标下的向量 对于一个二维向量$\\vec {c}$，可以由任意2个不平行的基础向量组合而成： $$\\vec {c} = w_a \\vec{a} + w_b \\vec{b} ,\\text{($w_a$,$w_b$是唯一一组常数解)}$$ 那么，如果让这2个基础向量为直角坐标系的横轴$x$和纵轴$y$两个方向上的单位向量,则向量$\\vec{a}$表示为： $$\\vec a =x_a \\vec{x} + y_a \\vec{y}$$ 通常为了方便，也会直接用直角坐标$(x_a,y_a)$表示这个向量，或者使用一个列矩阵，$\\vec a =\\begin{bmatrix} x_a \\\\ y_a \\end{bmatrix}$, 为了书写和印刷方便，也会直接写为它的转置形式 ${\\vec a} ^ T=\\begin{bmatrix} x_a \u0026 y_a \\end{bmatrix}$ . ","date":"2021-12-27","objectID":"/2021/12/07_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:8:0","tags":["图形渲染","英文原本"],"title":"Fundamentals of Computer Graphics第2章总结_(杂项数学)","uri":"/2021/12/07_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"4.3 点乘 向量点乘得到的为标量积,向量$\\vec{a}$和$\\vec{b}$的点乘为两个向量的长度相乘，再乘以夹角$\\Phi$的余弦值。表示为： $$\\vec{a} \\cdot \\vec{b} =\\lVert a \\rVert \\cdot \\lVert b \\rVert \\cdot \\cos \\Phi$$ 常用：用于计算2个向量的夹角余弦值，进而推算夹角大小。 向量点乘遵守结合律(associative property)和分配律(distributive property): $$\\vec {a} \\cdot \\vec {b} =\\vec{b} \\cdot \\vec{a}$$ $$\\vec {a} \\cdot (\\vec {b} + \\vec {c})=\\vec {a} \\cdot \\vec {b} +\\vec {a} \\cdot \\vec {c}$$ $$(k \\vec{a})\\cdot \\vec{b}=\\vec{a}\\cdot (k\\vec{b})=k\\vec{a}\\cdot \\vec{b}$$ 在直角坐标系下，假设有二维向量$\\vec{a}=(x_a,y_a)$和$\\vec{b}=(x_b,y_b)$，那么两者点乘结果为 $\\vec {a} \\cdot \\vec {b}=x_a x_b + y_a y_b$ . 类似地，如果是三维向量，那么: $\\vec {a} \\cdot \\vec {b}=x_a x_b + y_a y_b +z_a z_b$ ","date":"2021-12-27","objectID":"/2021/12/07_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:9:0","tags":["图形渲染","英文原本"],"title":"Fundamentals of Computer Graphics第2章总结_(杂项数学)","uri":"/2021/12/07_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"4.4 叉乘 向量叉乘得到的为向量积，通常用于三维向量。 $\\vec{a} ,\\vec{b}$叉乘向量积的模长为这两个向量的模长相乘，再乘以夹角的正弦值,数值正好等于$\\vec{a} ,\\vec{b}$围成的平行四边形面积。 $$\\lVert \\vec{a} \\times \\vec{b} \\rVert=\\lVert \\vec{a} \\rVert \\lVert \\vec{b} \\rVert \\sin \\Phi ,\\text{(且方向同时垂直于$\\vec{a} ,\\vec{b}$)}$$ 下图为一个右手坐标系 定义$x,y,z$三轴的单位向量分别为： $$\\vec{x} =(1,0,0)$$ $$\\vec{y} =(0,1,0)$$ $$\\vec{z} =(0,0,1)$$ 那么$\\vec{x} \\times \\vec{y}$叉乘结果可以为人为规定为$+\\vec{z}$或$-\\vec{z}$,这里我们采用$+\\vec{z}$，则有： $$\\vec{x} \\times \\vec{y}=+\\vec{z}$$ $$\\vec{y} \\times \\vec{x}=-\\vec{z}$$ $$\\vec{y} \\times \\vec{z}=+\\vec{x}$$ $$\\vec{z} \\times \\vec{y}=-\\vec{x}$$ $$\\vec{z} \\times \\vec{x}=+\\vec{y}$$ $$\\vec{x} \\times \\vec{z}=-\\vec{y}$$ 对右手坐标系的解释：对于$\\vec {a} \\times \\vec{b}$,右手手掌与$\\vec{a}$平行，且四指向$\\vec{b}$弯曲，此时大拇指所指方向就是叉乘结果$\\vec {a} \\times \\vec{b}$的方向。 注意：常用的$x-y-z$直角坐标系为右手坐标系，即$\\vec{x} \\times \\vec{y}=+\\vec{z}$。 叉乘运算满足分配律，结合律(与常数)，但不满足交换律： $$\\vec{a} \\times (\\vec{b} + \\vec{c} ) = \\vec{a} \\times \\vec{b} + \\vec{a} \\times \\vec{c}$$ $$\\vec{a} \\times (k\\vec{b})=k(\\vec{a} \\times \\vec{b}) , \\text{ (常数可以提取出来)}$$ $$\\vec{a} \\times \\vec{b} = -(\\vec{b} \\times \\vec{a}), \\text{ (一交换则反向)}$$ 现在有向量$\\vec{a}=(x_a,y_a,z_a)$,或者表示为$\\vec{a}=x_a \\vec{x} + y_a \\vec{y} + z_a \\vec{z}$, 另一个向量 $\\vec{b} =(x_b, y_b, z_b)$, 那么： $$\\vec{a} \\times \\vec{b} =(x_a \\vec{x} + y_a \\vec{y} + z_a \\vec{z}) \\times( x_b \\vec{x} + y_b \\vec{y} + z_b \\vec{z})$$ $$=(y_a z_b - z_a y_b)\\vec{x} + (z_a x_b -x_a z_b)\\vec{y} +(x_a y_b - y_a x_b)\\vec{z}$$ 最终结果也可写作 $\\vec{a} \\times \\vec{b} =(y_a z_b - z_a y_b, z_a x_b -x_a z_b , x_a y_b - y_a x_b )$ . ","date":"2021-12-27","objectID":"/2021/12/07_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:10:0","tags":["图形渲染","英文原本"],"title":"Fundamentals of Computer Graphics第2章总结_(杂项数学)","uri":"/2021/12/07_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"4.5 标准正交基与坐标系 标准正交基：在2D平面，有互相垂直的一组向量基 $\\vec{u} ,\\vec{v}$，且都为单位向量，即： $$\\lVert \\vec{u} \\rVert =\\lVert \\vec{v} \\rVert =1, \\text{and, }\\vec{u} \\cdot \\vec{v} =0$$ 如果是3D空间，则这组标准正交基$\\vec{u}, \\vec{v}, \\vec{w}$满足： $\\text{(1)} \\lVert \\vec{u} \\rVert =\\lVert \\vec{v} \\rVert =\\lVert \\vec{w} \\rVert =1$ $\\text{(2)} \\vec{u} \\cdot \\vec{v} =\\vec{v} \\cdot \\vec{w} =\\vec{w} \\cdot \\vec{u} =0$ $\\text{(3)} \\vec{w}=\\vec{u} \\times \\vec{v} \\text{ (右手坐标系)}$ 像这样的正交基 $\\vec{u} ,\\vec{v} , \\vec{w}$有无数组，我们通常默认选用直角坐标轴的单位向量$\\vec{x}, \\vec{y}, \\vec{z}$作为正交基，且原点为$O(0,0,0)$,这样的正则坐标系我们称为世界坐标系(world coordinate system)或全局坐标系(global coordinate system). 有一个物体坐标系$u-v-w$ ,该坐标系中有个向量$\\vec{a}$,如果要转换为在世界坐标系下的坐标,使用简单的点乘 即可得到，为 $u_a\\vec{u} +v_a\\vec{v} +w_a \\vec{w}$. ","date":"2021-12-27","objectID":"/2021/12/07_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:11:0","tags":["图形渲染","英文原本"],"title":"Fundamentals of Computer Graphics第2章总结_(杂项数学)","uri":"/2021/12/07_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"4.6 单个向量构造向量基 设想较为常见的一种情形：给定一个向量$\\vec{a}$,我们希望能给出3个互相垂直的正交基$\\vec{u},\\vec{v},\\vec{w}$，要求$\\vec{w}$和$\\vec{a}$同向,并且不关注$\\vec{u},\\vec{v}$的具体指向。 分为3步： 取$\\vec{a}$的单位向量为$\\vec{w}$ ，即: $\\vec{w} =\\frac{\\vec{a}}{\\lVert \\vec{a} \\rVert}$ 任意取一个与$\\vec{w}$不共线的向量$\\vec{t}$, 两者叉乘后单位化得到$\\vec{u}$，即 : $\\vec{u}=\\frac{\\vec{t} \\times \\vec{w}}{\\lVert \\vec{t} \\times \\vec{w} \\rVert}$ 将上述得到的$\\vec{w} ,\\vec{u}$叉乘得到$\\vec{v}$ ，即: $\\vec{v} =\\vec{w} \\times \\vec{u}$ 书中提到这一场景适用于表面着色，因为法线方向很重要(垂直于表面),着色过程垂直于法线的表面向量无关紧要。 ","date":"2021-12-27","objectID":"/2021/12/07_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:12:0","tags":["图形渲染","英文原本"],"title":"Fundamentals of Computer Graphics第2章总结_(杂项数学)","uri":"/2021/12/07_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"4.7 由两个向量构建向量基 在某些场景需要用2个不共线向量来构建坐标系，比如给定2个互相垂直(perpendicular)的向量$\\vec{a}$(指定$\\vec{w}$) ,$\\vec{b}$(指定$\\vec{v}$),则直接叉乘得到第三个向量基$\\vec{u}=\\vec{b} \\times \\vec{a}.$ 或者，给定的$\\vec{a},\\vec{b}$并不是完全垂直，而是近似垂直,比如成$80^\\circ$角，采用上一节的方法也可以得到最接近的解： $\\vec{w} =\\frac{\\vec{a}}{\\lVert \\vec{a} \\rVert}$, $\\vec{u}=\\frac{\\vec{b} \\times \\vec{w}}{\\lVert \\vec{b} \\times \\vec{w} \\rVert}$, $\\vec{v} =\\vec{w} \\times \\vec{u} \\text{ ,(向量} \\vec{v} \\text{ 很接近} \\vec{b})$ . 获得图形学中相机的Look-At 矩阵/向量也可以采用这一方法，向量$\\overrightarrow {direction}$是确定的$from$点到$to$点的向量，而$up$向量和$right$向量就看自己选择了(可以指定Right向量，再来确定Up向量)，这一点在LearnOpenGL-CN中的Camera章节有相关内容。 ","date":"2021-12-27","objectID":"/2021/12/07_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:13:0","tags":["图形渲染","英文原本"],"title":"Fundamentals of Computer Graphics第2章总结_(杂项数学)","uri":"/2021/12/07_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"4.8 摆正向量基 某些场景下可能遇到这样的问题，由于浮点计算精度或者数据保存读取等原因，造成向量基精度丢失，向量基之间不再那么垂直，如何修正是个问题： 可以这样做：基于已有的$\\vec{w}, \\vec{v}$得到新的$\\vec{u}$,然后再计算$\\vec{u}$. 虽然得到了精确垂直的新向量基，但是，这并非最好的办法，因为新的向量基$\\vec{w}, \\vec{v},\\vec{u}$和原向量基之间，这3者的误差是不对等的, $\\vec{w}$误差最小，$\\vec{u}$误差最大。 在本书的第五章第5.4.1 节的奇异值分解可以很好的解决这一问题。 5 曲线与面 ","date":"2021-12-27","objectID":"/2021/12/07_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:14:0","tags":["图形渲染","英文原本"],"title":"Fundamentals of Computer Graphics第2章总结_(杂项数学)","uri":"/2021/12/07_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"5.1 2D隐式曲线 先理解一下“隐式”:在我看来，隐式曲线就是隐函数来表示的曲线。隐函数，就是没法用$y=f(x)$来干净清晰的表示函数关系，而是转而使用类似方程$f(x,y)=0$的形式(例如开普勒方程$y-x-\\epsilon \\sin y=0$,$\\epsilon$为常熟)。 为人所熟知的隐式曲线必然是圆了，圆方程$f(x,y)=(x-x_c)^2 + (y-y_c)^2 -r^2$描绘了以$(x_c,y_c)$为圆心，$r$为半径的圆. 对任意的点$(x,y)$值，都可以计算出$f(x,y)$的值，则有： 点在圆内：$f(x,y)\u003c0$; 点在圆曲线上：$f(x,y)=0$; 点在圆外：$f(x,y)\u003e0$; 从向量的角度理解，可以认为圆心$c$,圆上的点为$p$, 则向量$\\overrightarrow{cp}$模长正好为圆半径$r$，即:$\\lVert \\overrightarrow{cp} \\rVert =r$。 从向量的角度来表示，比原来$x,y,z$之类的坐标表示更易懂，更能体现几何关系，也更不容易在写代码时犯错，尽可能用向量的形式来表示隐式关系。 ","date":"2021-12-27","objectID":"/2021/12/07_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:15:0","tags":["图形渲染","英文原本"],"title":"Fundamentals of Computer Graphics第2章总结_(杂项数学)","uri":"/2021/12/07_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"5.2 2D梯度 假设函数$f(x,y)$是高度场的函数$height=f(x,y)$,那么梯度向量所指的方向就是指向上坡最陡的方向,或者说函数值增长最快的方向。一般是以偏微分的形式 $\\nabla f(x,y)$ 给出： $$\\nabla f(x,y)=(\\frac {\\partial f} {\\partial x} \\text{ ，} \\frac {\\partial f} {\\partial y} ) .$$ so，偏微分复习：$\\frac {\\partial f} {\\partial x} = lim_{\\Delta x \\to 0} \\frac{f(x+\\Delta x , y) - f(x,y)}{\\Delta x}$ 原文图注解：A surface height = f(x,y) is locally planar near(x,y) = (a,b). The gradient is a projection of the uphill direction onto the height = 0 plane. 如上图，对于二维曲线$f(x,y)=0$的点$p(x,y)$,则此时梯度向量垂直于该点的切向量，梯度向量此时为法线向量。 换句话说，把二维曲线$f(x,y)=0$看作是三维曲面$f(x,y)=h$ 被$xoy$水平面截出的等高线，这样上山的最陡路径投影在平面上，正好就是二维曲线的法向方向. 关于这一点，有位知乎答主做了很好的图文并茂的解释，深入理解可以移步$\\implies$ 知乎: 形象理解“梯度”与“法向量”的关系 另外，因为梯度指向了上坡方向(uphill),所以指向的是$f(x,y)\u003e0$的区域。 那么，为什么梯度和偏微分有关系呢？下图中，假设在很微小的一个区域，$height=f(x,y)$是一块平面，且向量$\\vec{a}$在这个$f$不变的区域移动了一小段距离，即$\\vec{a}=(\\Delta x,\\Delta y)$.因为上坡方向(uphill)垂直于向量$\\vec{a}$,即点积为0： $$(\\nabla f)\\cdot \\vec{a} \\equiv (x_\\nabla,y_\\nabla)\\cdot(x_a,y_a)=x_\\nabla \\Delta x + y_\\nabla \\Delta y=0 \\text{, (式2.5.2-a) }$$ 同样地，我们知道$f$的值没有改变，即$\\Delta f=0$: $$\\Delta f = \\frac {\\partial f} {\\partial x} \\Delta x + \\frac {\\partial f} {\\partial y} \\Delta y= \\frac {\\partial f} {\\partial x} x_a + \\frac {\\partial f} {\\partial y} y_a =0$$ 回顾向量知识，如果$(x,y)$ 和 $(x',y')$垂直，则$xx'+yy'=0$，(x',y')可以取值$(y,-x)$. 那么: $$(x_a,y_a)=k(\\frac{\\partial f}{\\partial y} , - \\frac{\\partial f}{\\partial x}) \\text{, (式2.5.2-b) }$$ 根据式子2.5.2-a和2.5.2-b，可以得出: $$(x_\\nabla, y_\\nabla) = m(\\frac{\\partial f}{\\partial x} , \\frac{\\partial f}{\\partial y}) \\text{, (式2.5.2-c) }$$ 通常取k\u003e0,且m=1. 隐式2D直线(implicit 2D lines) 考虑使用隐函数形式表达一条直线：$Ax+By+C=0$,这种一般形式包含了垂直于$x$轴没有斜率的情况。假设直线上存在两个不同的点$(x_0,y_0), (x_1,y_1)$，则: $$\\begin{cases} Ax_0 + By_0+C =0 \\\\ Ax_1 + By_1+C =0\\\\ \\end{cases}$$ 很明显，这是个不定方程。 梯度为$\\nabla f=(A,B)$, 又因为 $\\nabla f$垂直于$(\\Delta x, \\Delta y)$, 则与 (式2.5.2-c)同理，可以令$\\nabla f=(y_0 -y_1,x_1-x_0)$. 替换A，B，则有： $$(y_0 - y_1)x + (x_1 - x_0)y +C =0 \\text{, (式2.5.2-d)}$$ 对于(式2.5.2-d)，代入$(x_0,y_0)$，则有$C=x_0y_1 - x_1y_0$: $$(y_0 - y_1)x + (x_1 - x_0)y + x_0y_1 - x_1y_0=0$$ 那么写成\"斜率-截距式\"(slope-intercept): $$y =\\frac{y_1 -y_0}{x_1-x_0}x + \\frac{x_1y_0 - x_0y_1}{x_1-x_0}$$ 关于隐式表达式的另外一个有趣的属性是可以用来推算点到直线的有向距离，如下图，平行于直线的$f(x,y)$分布于$\\pm$两侧。 直线之间的距离为梯度的长度，而梯度为k(A,B)，距离则为： $$distance =k \\sqrt{A^2 + B^2}\\text{, (式2.5.2-e)}$$ $Ax + By+C =0$直线上的点$(x_0,y_0)$,则该点的梯度方向有某点$(a,b)=(x_0,y_0)+k(A,B)$,带入计算： $$f(a,b)=f(x_0+kA,y_0+kB)=k(A^2 +B^2)\\text{, (式2.5.2-f)}$$ 综合 (式2.5.2-e), (式2.5.2-f)可知，点$(a,b)$到直线$Ax + By+C =0$的距离： $$distance=\\frac{f(a,b)}{\\sqrt{A^2 + B^2}}$$ 隐式二次曲线(implicit quadric curves) 对于隐式的2D二次曲线，一般形式可以写作如下： $$Ax^2 + Bxy + Cy^2 +Dx + Ey +F =0$$ 该形式包含了椭圆(ellipse)，双曲线(hyperbola)，抛物线(parabola). ","date":"2021-12-27","objectID":"/2021/12/07_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:16:0","tags":["图形渲染","英文原本"],"title":"Fundamentals of Computer Graphics第2章总结_(杂项数学)","uri":"/2021/12/07_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"5.3 3D隐式曲面 和2D隐式曲线类似，3D隐式曲面的表达式记作： $$f(x,y,z)=0.$$ 对曲面上任意点$p(x,y,z)$，有$f(p)=0$. ","date":"2021-12-27","objectID":"/2021/12/07_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:17:0","tags":["图形渲染","英文原本"],"title":"Fundamentals of Computer Graphics第2章总结_(杂项数学)","uri":"/2021/12/07_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"5.4 隐式曲面的表面法线 和2D隐式曲线类似，3D隐式曲面上某点$p(x,y,z)$的法线正好就是该点的梯度: $$\\vec{n}=\\nabla f(p)=(\\frac {\\partial f(p)}{\\partial x}, \\frac {\\partial f(p)}{\\partial y} ,\\frac {\\partial f(p)}{\\partial z})$$ 并且法线$\\vec n$指向的方向为$f(q)\u003e0$的方向(点$q$不在曲面上). 需要注意的是，$f(p)=0$和$-f(p)=0$虽然描述的是同一个曲面，但是法线/梯度方向正好相反：$-\\nabla f(p) =\\nabla(-f(p))$. ","date":"2021-12-27","objectID":"/2021/12/07_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:18:0","tags":["图形渲染","英文原本"],"title":"Fundamentals of Computer Graphics第2章总结_(杂项数学)","uri":"/2021/12/07_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"5.5 隐式平面 平面可以由一个已知的点$a$和已知的法线$\\vec n$来描述 对于平面上任意点$p$： $$(p-a) \\cdot \\vec n=0$$ 平面也可以由3个已知的点$a,b,c$来确定 法线可以通过叉乘得到$\\vec n=(b-a)\\times (c-a)$，对于平面上任意点$p$： $$(p-a)\\cdot ((b-a)\\times (c-a))=0$$ 写成行列式(determinant)则如下： $$\\begin{vmatrix} { x-x_a} \u0026 {y-y_a} \u0026 {z-z_a} \\\\ {x_b-x_a} \u0026 {y_b-y_a} \u0026 {z_b-z_a} \\\\ { x_c-x_a} \u0026 {y_c-y_a} \u0026 {z_c-z_a} \\\\ \\end{vmatrix}=0$$ 3D二次曲面(3D quadric surfaces) 2D曲线可以用二元二次多项式$(x,y)$来表示，类似地，3D曲面可以用三元二次多项式$(x,y,z)$来表示。 对于一个球面： $$f(p)=(p-c)^2-r^2 =0$$ 对于一个椭球面(ellipsoid)： $$f(p)= \\frac{(x-x_c)^2}{a^2} + \\frac{(y-y_c)^2}{b^2} +\\frac{(z-z_c)^2}{c^2} -1=0$$ 由曲面构建曲线(3D curves from implicit surfaces) 如果2个曲面相交，则得到了相交位置的曲线，该曲线的点$p$同时满足： $$ \\begin{cases} f(p)=0 ,\\\\ g(p)=0 .\\\\ \\end{cases}$$ ","date":"2021-12-27","objectID":"/2021/12/07_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:19:0","tags":["图形渲染","英文原本"],"title":"Fundamentals of Computer Graphics第2章总结_(杂项数学)","uri":"/2021/12/07_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"5.6 带参数的2D曲线 带参数的函数：是指自变量$x$和因变量$y$都采用参数$t$表达，点$(x,y)$的位置由$t$来决定，即： $$\\begin{bmatrix} x \\\\ y \\end{bmatrix} =\\begin{bmatrix} g(t) \\\\ h(t) \\end{bmatrix}.$$ 当$t$在连续的改变时，连续函数$g(t),h(t)$也在改变,即点$p(x,y)$在曲线上\"移动\"了,$t$可以看作是时间，不同$t$区间的(x,y)变化幅度不同，点移动时就会有\"速度\"的概念。 带参数函数只看变量$t$的这一特性，给相关的程序编写也带来了很大的便利，只有一个函数入参，Cool. 带参数的2D直线(2D parametric lines) 2D直线上有2个已知的点$p_0(x_0,y_0),p_1(x_1,y_1)$,那么该直线可表示为： $$\\begin{bmatrix} x \\\\ y \\end{bmatrix} =\\begin{bmatrix} x_0+t(x_1-x_0) \\\\ y_0+t(y_1-y_0) \\end{bmatrix}.$$ 或者采用向量的概念：$p(t)=p_0+t(p_1-p_0)$ 如上图，从几何角度理解为“从p0出发前往p1,具体位置由参数t决定”,且$p(0)=p_0,p(1)=p_1$。所以基于这一点，直线可以表示为从一个定点$origin$出发,移动$t$个单位向量$\\vec u$，即： $$p(t)=origin + t \\cdot \\vec u$$ 而这种表示方法，在光线追踪计算时是表示一条光线的绝佳形式。 带参数的2D圆(2D parametric circles) 一个以$(x_c,y_c)$为圆心,$r$为半径的圆，带参数形式可以写作： $$\\begin{bmatrix} x \\\\ y \\end{bmatrix} =\\begin{bmatrix} x_c+ r \\cos \\Phi \\\\ y_c+ r \\sin \\Phi \\end{bmatrix}. \\text{ (其中$\\Phi \\in [0,2 \\pi)$)}$$ 而一个以$(x_c,y_c)$为椭圆中心,$a,b$为长轴、短轴的椭圆，带参数形式可以写作： $$\\begin{bmatrix} x \\\\ y \\end{bmatrix} =\\begin{bmatrix} x_c+ a \\cos \\Phi \\\\ y_c+ b \\sin \\Phi \\end{bmatrix}. \\text{ (其中$\\Phi \\in [0,2 \\pi)$)}$$ ","date":"2021-12-27","objectID":"/2021/12/07_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:20:0","tags":["图形渲染","英文原本"],"title":"Fundamentals of Computer Graphics第2章总结_(杂项数学)","uri":"/2021/12/07_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"5.7 带参数的3D曲线 带参数的3D曲线形式如下： $$\\begin{cases} x=f(t) \\\\ y=g(t) \\\\ z=h(t) \\\\ \\end{cases}$$ 例如，绕$z$轴的螺旋线如下： $$\\begin{cases} x= \\cos t \\\\ y= \\sin t \\\\ z= t \\\\ \\end{cases}$$ 本章只阐述3D直线，不详细阐述3D曲线，而是在本书的第15章(Chapter15.Curves)详细阐述。 带参数的3D直线(3D parametric lines) 带参数的3D直线可以记作向量的形式，举例如下： $$\\begin{cases} x= 2+7t \\\\ y= 1+2 t \\\\ z= 3-5t\\\\ \\end{cases} \\quad \\text{向量形式$\\implies$} \\begin{cases} origin=(2,1,3)\\\\ \\overrightarrow {dircetion}= (7,2,-5) \\\\ position = origin + t \\cdot \\overrightarrow {dircetion} \\\\ \\end{cases}$$ ","date":"2021-12-27","objectID":"/2021/12/07_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:21:0","tags":["图形渲染","英文原本"],"title":"Fundamentals of Computer Graphics第2章总结_(杂项数学)","uri":"/2021/12/07_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"5.8 带参数的3D曲面 不同于2D曲面，只有一个参数$t$,3D曲面需要2个参数$u,v$，$x,y,z$都可以表示为$(u,v)$有关的带参数形式： $$\\begin{cases} x= f(u,v) \\\\ z= h(u,v) \\\\ \\end{cases} \\quad \\text{向量形式$\\implies$} \\begin{bmatrix} x \\\\ y \\\\ z \\end{bmatrix}=p(u,v)$$ 举例：对于一个球面，给定的已知半径$r$，由经度角$\\phi$，纬度角$\\theta$这2个角度变化确认球面任意点： $$\\begin{cases} x= r \\cos \\phi \\sin \\theta \\\\ y= r \\sin \\phi \\sin \\theta \\\\ z= r \\cos \\theta \\\\ \\end{cases} \\quad \\text {可以反推} \\begin{cases} \\theta= arccos(z / \\sqrt{x^2 + y^2 +z^2}) \\\\ \\phi = atan2(y,x) \\\\ \\end{cases}$$ 考虑一下曲面的法线呢？ 首先定义函数$q(t)=p(t,v_0)$，此函数u自由变化且v值固定为$v_0$,这就定义了在曲面上的一条曲线，也叫“等参曲线”。(下图采用自AutoDesk工具ALIAS介绍，意义相近) 则q的导数$q'$和曲面相切，$q'$为P的偏微分$P_u$，同样地，还可以得到第二条切线$P_v$，那么该点的法线$\\vec n$指向曲面外，且同时垂直于这2条曲面切线： $$\\vec n = \\overrightarrow P_u \\times \\overrightarrow P_v$$ 6 线性插值 线性插值可能是图形学中最为常见的思想和计算操作了，回顾我们之前的带参数的2D直线，$p(t)=p_0+t(p_1-p_0)$，即$p(t)=(1-t)\\cdot p_0+t \\cdot p_1$,其实可以认为是在点$p_0,p_1$之间线性插值，权重为$t$. 更通用的一种情形，有$n+1$个散点，对应的$x$坐标$x_0,x_1 … x_{n-1},x_n$,对应的y值为$y_0,y_1 … y_{n-1},y_n$,此时想得到一条连续的函数$f(x)$,就可以通过在相邻的散点插值得到： $$f(x)=y_i+\\frac{x-x_i}{x_{i+1}-x_i}(y_{i+1}-y_i) \\text {,(此时的$t=\\frac{x-x_i}{x_{i+1}-x_i}$)}$$ 7 三角形 无论是2D三角形还是3D三角形，都是各种图形学程序中的基础模型图元(modeling primitive)。比如三角形的Color图元，只有3个顶点(Vertex)有Color值，三角形内的其他值则通过插值方法得到，通常直接采用重心坐标插值(barycentric coordinates)。 本节将分别讨论2D和3D三角形。 ","date":"2021-12-27","objectID":"/2021/12/07_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:22:0","tags":["图形渲染","英文原本"],"title":"Fundamentals of Computer Graphics第2章总结_(杂项数学)","uri":"/2021/12/07_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"7.1 2D三角形 对于一个2D三角形，三个顶点为$a,b,c$，则可以立马通过向量叉乘($S=\\frac {1}{2} \\vec{ab} \\times \\vec{ac}$)得到它的面积： $$S = \\frac {1}{2} \\left | \\begin{array}{ccc} x_b-x_a \u0026 x_c-x_a\\\\ y_b-y_a \u0026 y_c-y_a \\\\ \\end{array} \\right |= \\frac {1}{2}(x_a y_b+x_b y_c+x_c y_c-x_a y_c-x_b y_a-x_c y_b)$$ (该公式的推导可以参考本书章节$Chapter5.Linear Algebra-5.3$.注意,考虑到叉乘的方向性，$a,b,c$三个点要成逆时针排列，否则得到面积的相反数.) 三角形的坐标插值，基本原理还是来自于平行四边形规则的向量合成，即使2个向量不平行，同样可以作为向量基。 首先，对于三角形所在平面内的任意点$p$,满足： $$p=a+\\beta \\vec{ab} + \\gamma \\vec{ac}=a+\\beta (b-a) + \\gamma (c-a)=(1-\\beta -\\gamma)a+\\beta b+\\gamma c$$ 为方便计算书写，令$\\alpha \\equiv 1-\\beta -\\gamma$,则$p(\\alpha,\\beta,\\gamma)=\\alpha a + \\beta b +\\gamma c.$ 注意，点$p$位于三角形内部的充要条件为: $\\alpha, \\beta,\\gamma \\in (0,1)$. 回顾2.5.2节隐式2D直线的内容，平行于直线$f(x,y)=0$的其他直线的函数值$f(x,y)$大于或小于0，分布于$f(x,y)=0$的两侧。如下图所示，我们规定$f_{ac}(x,y)=0$,且点b所在平行线$f_{ac}(x,y)_{\\beta}=1$. 那么在线段$ab$上的点$(x,y)$，$\\beta$值为： $$\\beta=\\frac{f_{ac}(x,y)}{f_{ac}(x_b,y_b)}$$ 基于隐式2D直线章节的内容，ab直线可表示为： $f_{ab}(x,y)\\equiv (y_a -y_b)x +(x_b-x_a)y + x_a y_b -x_b y_a=0$. 则相对应的$\\gamma$值为： $$\\gamma =\\frac {(y_a -y_b)x +(x_b-x_a)y + x_a y_b -x_b y_a}{(y_a -y_b)x_c +(x_b-x_a)y_c + x_a y_b -x_b y_a}$$ 同理，可计算得到点b对应的$\\beta$值,最后$\\alpha=1-\\beta -\\gamma$. 值得注意的是，$\\alpha,\\beta,\\gamma$值表征的是$f(x,y)的值，隐式地表征$点p到各条边的距离，所以，点p和三个顶点行成的3个小三角形和大三角形的比值其实就是$\\alpha,\\beta,\\gamma$,即如下图所示： ","date":"2021-12-27","objectID":"/2021/12/07_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:23:0","tags":["图形渲染","英文原本"],"title":"Fundamentals of Computer Graphics第2章总结_(杂项数学)","uri":"/2021/12/07_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"7.2 3D三角形 对于上一节得到的2D三角形插值公式完全适用于3D三角形$abc$,同样有： $$p=(1-\\beta -\\gamma)a+\\beta b+\\gamma c$$ 三角形$abc$，三条边对应3个比例$\\alpha,\\beta,\\gamma$,则对于三角形内任意点$p$: $$\\alpha =\\frac{Area_{pbc}}{Area_{abc}}=\\frac{\\lVert (c-b)\\times(p-b) \\rVert} {\\lVert (b-a)\\times(c-a) \\rVert}$$ 令$\\vec n=(b-a)\\times(c-a)$,$\\vec n_a =(c-b)\\times(p-b)$，因为两者平行且同向($\\vec n \\cdot \\vec n_a=||\\vec n|| \\cdot ||\\vec n_a||$),则上式可化简： $$\\alpha =\\frac{\\lVert \\vec n_a \\rVert}{\\lVert \\vec n \\rVert }= \\frac{\\lVert \\vec n_a \\rVert \\cdot \\lVert \\vec n \\rVert }{\\lVert \\vec n \\rVert \\cdot \\lVert \\vec n \\rVert } =\\frac{\\vec n \\cdot \\vec n_a }{ { \\lVert \\vec n \\rVert }^2 }$$ 同理可得$\\beta, \\gamma$的值： $$\\beta =\\frac{\\vec n \\cdot \\vec n_b}{ {\\lVert \\vec n \\rVert }^2}$$ $$\\gamma =\\frac{\\vec n \\cdot \\vec n_c}{ {\\lVert \\vec n \\rVert }^2}$$ 其中，$n_b =(a-c)\\times(p-c)$，$n_c =(b-a)\\times(p-a)$. $$\\text{——————– Chapter2(完结) @2021-12-19 ——————–}$$ ","date":"2021-12-27","objectID":"/2021/12/07_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:24:0","tags":["图形渲染","英文原本"],"title":"Fundamentals of Computer Graphics第2章总结_(杂项数学)","uri":"/2021/12/07_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"摘要：Metal官方文档MetalGuide系列第三部分 -\u003e Metal有关的Shader着色器程序,以及MetalLib库文件的生成与使用","date":"2021-12-26","objectID":"/2021/12/04_metalguide-3-%E7%9D%80%E8%89%B2%E5%99%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%BA%93/","tags":["Metal","图形渲染"],"title":"MetalGuide(3)着色器程序与库","uri":"/2021/12/04_metalguide-3-%E7%9D%80%E8%89%B2%E5%99%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%BA%93/"},{"categories":["计算机图形学"],"content":"1 如何创建Metal库(MTLLibrary) Case A. 从已编译的代码中创建Library 为了提升性能，可以利用xcode工具在app的创建过程中就把Metal-Shader源代码编译打包到一个库文件中，如此避免了在app的运行时编译着色程序代码的开销。 从已编译的二进制库中创建一个MTLLibrary对象，可以使用如下的MTLDevice方法 ： newDefaultLibrary : 会return一个MTLLibrary，包含了渲染shader和app所需的并行计算程序； newLibraryWithFile:error : 它将返回一个MTLLibrary对象，从指定的库文件路径加载这个库文 件中的所有shader程序； newLibraryWithData:error :它将返回一一个MTLLibrary对象，从指定的二进制数据块对象加载数据块中的所有shader程序. Case B. 从源代码中创建Library 从包含有Metal-Shader代码编写的多个着色程序的字符串中创建MTLLibrary对象，这些方法将在MTLLibrary对象创建时编译源代码，具体的可以参考如下 MTLDevice方法 ： newLibraryWithSource:options:error: 属于同步阻塞调用 ,它编译输入字符串里的源代码创建多个 MTLFunction对象，最后返回一个包含这些MTLFunction对象的MTLLibrary对象； newLibraryWithSource:options:completionHandler: 属于异步调用，和上一个方法不同的是多了参数代码block块—completionHandler，block将在MTLLibrary对象创建完成后被调用 . 2 MTLFunction细节探究 ​ 如何从Library中获取Function ，可以用下述方法进行获取： ​ newFunctionWithName: 属于MTLLibrary的方法, 返回一个名字为输入参数的MTLFunction对象。如果在library中没有 找到一个方法其修饰名字匹配输入参数，那么该函数返回nil。 ","date":"2021-12-26","objectID":"/2021/12/04_metalguide-3-%E7%9D%80%E8%89%B2%E5%99%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%BA%93/:0:0","tags":["Metal","图形渲染"],"title":"MetalGuide(3)着色器程序与库","uri":"/2021/12/04_metalguide-3-%E7%9D%80%E8%89%B2%E5%99%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%BA%93/"},{"categories":["计算机图形学"],"content":"2.1 在运行时决定Function的细节 ​ 一个MTLFunction对象被定义为图形shader程序或是并行计算程序，它的实质内容在这个对象被创建前 就编译好了，而且shader程序的源代码不能直接被app使用.不过，可以在运行时查询下面的MTLFunction属性： ","date":"2021-12-26","objectID":"/2021/12/04_metalguide-3-%E7%9D%80%E8%89%B2%E5%99%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%BA%93/:1:0","tags":["Metal","图形渲染"],"title":"MetalGuide(3)着色器程序与库","uri":"/2021/12/04_metalguide-3-%E7%9D%80%E8%89%B2%E5%99%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%BA%93/"},{"categories":["计算机图形学"],"content":"2.2 相关的Reflection对象 ​ MTLFunction不提供访问shader程序参数的方法。但在pipeline state创建过程中，可以获得用于展示shader程序参数细节reflection对象(根据command encoder的类型不同， reflection对象分为MTLRenderPipelineReflection类型或 MTLComputePipelineReflection类型 )。 ​ 一个reflection对象包含了一个MTLArgument数组，视其关联的Encoder不同而不同： MTLRenderPipelineReflection：关联MTLRenderCommandEncoder ,包含的Arguments数组有vertexArguments和fragmentArguments 这2个属性； MTLComputePipelineReflection ：关联MTLComputeCommandEncoder ，包含的Argument数组表征并行计算程序的参数。 ​ 不是所有的shader程序的参数都在reflection对象中表示，一个reflection对象仅包含那些引用了相应资源的参数，通 过shader修饰符[[stage_in]]、 [[vertex_id]]、 [[attribute_id]]修饰的参数不会被包含在reflection对象中。 ","date":"2021-12-26","objectID":"/2021/12/04_metalguide-3-%E7%9D%80%E8%89%B2%E5%99%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%BA%93/:2:0","tags":["Metal","图形渲染"],"title":"MetalGuide(3)着色器程序与库","uri":"/2021/12/04_metalguide-3-%E7%9D%80%E8%89%B2%E5%99%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%BA%93/"},{"categories":["计算机图形学"],"content":"2.3 MTLArgument对象 ​ MTLArgument类型对象表示一个shader程序方法的入参细节： ​ 上述的属性type还决定了哪些其他MTLArgument属性是相关的，type类型不同，相关的属性也有所区别： MTLArgumentTypeTexture : textureType属性表征纹理类型(可能为texture1d_array， texture2d_ms， texturecube); textureDataType 属性表征其分量数据类型(可能为half， float， int， uint）; MTLArgumentTypeThreadgroupMemory : 说明threadgroupMemoryAlignment和 threadgroupMemoryDataSize这两个属性相关； MTLArgumentTypeBuffer : 说明bufferAlignment, bufferDataSize, bufferDataType, bufferStructType这几个属性相关 。 ​ 例如：如果bufferDataType的值是MTLDataTypeStruct ，那么bufferStructType属性含有一个MTLStructType类型的值 ,同时bufferDataSize属性表示这个结构体的长度 (bytes数量); 如果缓存Argument是数组，那么bufferDataType属性则表征的是数组元素的类型，同时bufferDataSize属性表示的也只是数组中一个元素的长度。 参考链接: Apple-Metal-Programming-Guide Metal’s Best Practice ","date":"2021-12-26","objectID":"/2021/12/04_metalguide-3-%E7%9D%80%E8%89%B2%E5%99%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%BA%93/:3:0","tags":["Metal","图形渲染"],"title":"MetalGuide(3)着色器程序与库","uri":"/2021/12/04_metalguide-3-%E7%9D%80%E8%89%B2%E5%99%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%BA%93/"},{"categories":null,"content":"关于本站 基于 GithubPage $+$ Hugo框架 建立本博客站点，博客主题为 LoveIt。 版权协议采用 CC By-NC 4.0 ，参考或转载站内文章请注明出处。 关于我 Experience 😉焊过板子，写过嵌入式C和Qt桌面应用，也调过一些CV算法API，现从事于图形学C++相关的开发工作。 欢迎评论👨‍👩‍👧‍👦，并且 博客主页 头像下方的Email📧与 Github👩‍💻可戳😋 Friends 本站友链信息： name=\"Benjamin旅记\" url=\"https://kissingfire123.github.io\" logo=\"https://s2.loli.net/2022/06/12/I5LzEte8TuOPhYX.webp\" word=\"人生如逆旅，不妨以求知为伴。\" group=\"C/C++\" 希望遇到志同道合的朋友多多交流，欢迎互相友链（留言或邮箱联系），共同进步！ 建站节点记 Records 2021-12-01：基于GithubPage+Hugo建立博客 2021-12-12：博客主题从 clean-white 切换为LoveIt 2022-02-18：博客内图片全部切换到 gitee 图床 2022-04-05：SEO优化，站点被 Bing搜索 收录 2022-04-10：添加友链墙页面与功能 2022-04-20：美化博客，支持Github-Corner、文章可选加密访问、文章归档数量统计等功能 ","date":"2021-12-25","objectID":"/about/:0:0","tags":null,"title":"关于我和我的博客","uri":"/about/"},{"categories":["计算机图形学"],"content":"摘要：Metal官方文档MetalGuide系列第二部分 -\u003e Metal资源与对象，即纹理Texture和Buffer","date":"2021-12-25","objectID":"/2021/12/03_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/","tags":["Metal","图形渲染"],"title":"MetalGuide(2)资源与对象","uri":"/2021/12/03_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/"},{"categories":["计算机图形学"],"content":"0.资源对象 资源对象，主要包含为缓存Buffers和纹理Textures。 ​ MTLBuffer它表示一块非格式化的内存可以存放任何类型的数据。它通常用于存放顶点数据、着色程序和计算状态数据。 ​ MTLTexture，它表示一块有格式的图像数据，有特定的纹理类型和像素格式。它通常被用作顶点着色程序、片元着色程序、或是并行计算函数的纹理源，它也可以存放图形渲染的结果输出。通常MTLTexture结构为这几种：1维、2维、或3维的图像，或是1维、2维的图像数组，或是拥有6个2维图像的立方体。 ​ MTLSamplerState，虽然采样器不是资源，但它总是用于纹理对象的查找计算。 1. 有关Buffer对象 ","date":"2021-12-25","objectID":"/2021/12/03_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/:0:0","tags":["Metal","图形渲染"],"title":"MetalGuide(2)资源与对象","uri":"/2021/12/03_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/"},{"categories":["计算机图形学"],"content":"1.1 创建Buffer对象 ​ 一个MTLBuffer对象表示了一个可以装载任何类型数据的内存片段。 ​ 下面的MTLDevice方法可以用于创建并返回类型MTLBuffer对象: ","date":"2021-12-25","objectID":"/2021/12/03_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/:1:0","tags":["Metal","图形渲染"],"title":"MetalGuide(2)资源与对象","uri":"/2021/12/03_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/"},{"categories":["计算机图形学"],"content":"1.2 Buffer的对象方法 ​ Buffer缓存对象有2种方法： contents: 返回缓存对象对应内存的CPU地址; newTextureWithDescriptor:offset:bytesPerRow: 创建某种特定类型的纹理。 2.Texture对象 ","date":"2021-12-25","objectID":"/2021/12/03_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/:2:0","tags":["Metal","图形渲染"],"title":"MetalGuide(2)资源与对象","uri":"/2021/12/03_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/"},{"categories":["计算机图形学"],"content":"2.1 创建Texture对象 ​ 下列的方法用于创建并返回一个MTLTexture对象： newTextureWithDescriptor ：新分配内存并创建一个MTLTexture对象，创建时需要传入的MTLTextureDescriptor参数描述了纹理的属性； ⚠️它隶属于MTLDevice方法； newTextureViewWithPixelFormat ： 该方法创建出来的 MTLTexture新对象和调用源对象共享存储，并重新解释了源纹理对象对应内存的图像格式；调用入参的MTLPixelFormat参数类型必须兼容源纹理对象的图像格式；⚠️它隶属于MTLTexture方法; newTextureWithDescriptor:offset:bytesPerRow ：创建一个MTLTexture对 象，共享调用源对象的内存，作为它自己的图像数据；⚠️它隶属于MTLBuffer方法。 ","date":"2021-12-25","objectID":"/2021/12/03_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/:3:0","tags":["Metal","图形渲染"],"title":"MetalGuide(2)资源与对象","uri":"/2021/12/03_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/"},{"categories":["计算机图形学"],"content":"2.2 纹理描述符 ​ MTLTextureDescriptor(纹理描述符)描述用于创建一个MTLTexture对象的各属性。包括图形尺寸(宽，高，深)，像素格式，组合模式(数组或是立方体)还有mipmaps的数量。 这些属性都只用在MTLTexture对象的创建过程中。当纹理对象创建完毕，descritor中的值后续再改变也不会影响纹理之前由它创建的对象。指定纹理的维度与组合模式(数组或立方) ​ Texture Descriptor内容组成以及含义如下图： ","date":"2021-12-25","objectID":"/2021/12/03_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/:4:0","tags":["Metal","图形渲染"],"title":"MetalGuide(2)资源与对象","uri":"/2021/12/03_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/"},{"categories":["计算机图形学"],"content":"2.3 创建纹理描述符 ​ 对一个2D纹理或是立方纹理来说，下面的快捷方法可以创建MTLTextureDescriptor对象并且自动设置多个值： texture2DDescriptorWithPixelFormat:width:height:mipmapped: 创建一个描述2D纹理的MTLTextureDescriptor对象，入参width和height定义2D纹理的尺寸， descriptor的type属性自动设置为MTLTextureType2D，属性depth和属性arrayLength自动设置为1； textureCubeDescriptorWithPixelFormat:size:mipmapped: 创建一个描述立方纹理的MTLTextureDescriptor对象, 入参size被设置给width和height， type属性自动设置为MTLTextureTypeCube，属性depth和属性arrayLength自动设置为1 。 上面两个快捷方法都接受一个入参pixelFormat，它定义了纹理的像素格式。这两个方法都接受一个入参mipmapped(值为YES/NO)，它指定纹理是否支持mipmap ； ","date":"2021-12-25","objectID":"/2021/12/03_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/:5:0","tags":["Metal","图形渲染"],"title":"MetalGuide(2)资源与对象","uri":"/2021/12/03_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/"},{"categories":["计算机图形学"],"content":"2.4 纹理分片(slice) ​ 纹理分片是一个单独纹理数据(可能是1维、 2维或是3维)以及所有和它关联的mipmap。 具有以下特点： 其基层的mipmap尺寸由MTLTextureDescriptor对象的width , height , depth属性设定； mipmap的第 i 层的尺寸是基层的1/2i ; 立方cube(6个2维分片)和数组array(每个数组元素对应1个分片)类型的纹理可以有多个分片；一个单独纹理数据(可能是1维、 2维或是3维)只能有1个分片； ","date":"2021-12-25","objectID":"/2021/12/03_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/:6:0","tags":["Metal","图形渲染"],"title":"MetalGuide(2)资源与对象","uri":"/2021/12/03_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/"},{"categories":["计算机图形学"],"content":"2.5 Copy图像数据进出纹理对象 ​ 以同步阻塞式拷贝图像数据进出纹理对象的内存，可以使用如下方法： replaceRegion:mipmapLevel:slice:withBytes:bytesPerRow:bytesPerImage: 从withBytes参数表示的资源对象中拷贝指定区域的像素数据到一个指定的纹理切片的指定内存区域； replaceRegion:mipmapLevel:withBytes:bytesPerRow: 和前一个方法类似，只是slice和bytesPerImage设置为0; getBytes:bytesPerRow:bytesPerImage:fromRegion:mipmapLevel:slice: 获取指定切片的指定区域的像素数据 ; getBytes:bytesPerRow:fromRegion:mipmapLevel: 和前一个方法类似，只是slice和bytesPerImage设置为0; ","date":"2021-12-25","objectID":"/2021/12/03_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/:7:0","tags":["Metal","图形渲染"],"title":"MetalGuide(2)资源与对象","uri":"/2021/12/03_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/"},{"categories":["计算机图形学"],"content":"2.6 纹理MTLTexture像素格式 ​ MTLTexture对象的MTLPixelFormat属性指定颜色、深度或是模板缓存数据中每一个像素如何组织。有3种像素格式：原生格式(ordinary), 紧密填充格式 (packed)和 压缩格式 (compressed): 原生格式 ：只有8、16或是32位颜色值，每个分量以升序内存地址排列，第一个分量处于最低的内存地址处 ；例如MTLPixelFormatRGBA8Unorm是一个32位格式颜色值 ，RGBA都各自占8bit; 紧密填充格式 ：把多个颜色分量结合起来从最低位LSB到最高位MSB存放在一个16位或是32位的值中 ；例如 MTLPixelFormatRGB10A2Uint是一个32位的填充格式色值,RGB都各自占8bit, A占2bit； 压缩格式 ：用于排列像素块的，每个块的布局被设定为这种像素格式；只能被用于2D、 2D数组或是立方类型的纹理; 其他格式：MTLPixelFormatGBGR422和MTLPixelFormatBGRG422是两种特殊的像素格式，用于存储 YUV颜色 空间的像素数据，只支持不含mipmap且width为偶数的2D类型的纹理。 还有几种支持sRGB颜色空间的格式，比如MTLPixelFormatRGBA8Unorm_sRGB和 MTLPixelFormatETC2_RGB8_sRGB ，sRGB颜色空间和线性颜色空间可以相互转换。 ","date":"2021-12-25","objectID":"/2021/12/03_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/:8:0","tags":["Metal","图形渲染"],"title":"MetalGuide(2)资源与对象","uri":"/2021/12/03_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/"},{"categories":["计算机图形学"],"content":"2.7 采样器状态(Sampler States)与纹理 ​ MTLSamplerState对象(采样器状态)包含了用于纹理查找 的属性。 ​ MTLSamplerState定义了寻址、过滤还有其他属性，用于一个图形着⾊色程序或是并行计算着色程序对一个MTLTexture对象实施采样操作。创建一个采样器state对象的步骤如下图： ​ ⚠️注意：descriptor的属性值仅在创建MTLSamplerState对象时生效，state对象创建完成后，改变descriptor的属性值不会影响已经创建的state对象。 3. CPU/GPU内存一致性 ​ CPU和GPU都可以访问同一个MTLResource类型的对象管理的存储数据。但是GPU和CPU的操作是异步进行的，为保持一致性，注意该事项： ​ 当MTLDevice对象执行一个MTLCommandBuffer对象时，它只有在command buffer被提交之前才能观察到由CPU引起的Command-Buffer内存变化，一旦被提交即状态为MTLCommandBufferStatusCommitted ，MTLDevice对象就观察不到这些资源的变化情况了。 参考链接: Apple-Metal-Programming-Guide Metal’s Best Practice ","date":"2021-12-25","objectID":"/2021/12/03_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/:9:0","tags":["Metal","图形渲染"],"title":"MetalGuide(2)资源与对象","uri":"/2021/12/03_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/"},{"categories":["折腾"],"content":"摘要：基于Hugo框架和Github-Page搭建个人博客","date":"2021-12-19","objectID":"/2021/12/05_%E5%9F%BA%E4%BA%8Ehugo%E5%92%8Cgithub-page%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","tags":["Hugo","Github Page"],"title":"利用Hugo和Github-Pages搭建免费的个人博客","uri":"/2021/12/05_%E5%9F%BA%E4%BA%8Ehugo%E5%92%8Cgithub-page%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["折腾"],"content":"0.为什么选Hugo+Github-Page 说起博客，除了用个人vps+wordPress这种麻烦但diy程度高的方式，比较流行的应该就是CSDN，博客园和简书，以及GithubPage(同类还有GiteePage)。因为可以对自己博客的完全掌控性，以及管理便利性，大多数博主各方面权衡后，选择了GitHubPage搭建静态网页的形式，与之配合的静态博客框架有jekyll、hexo和hugo。 有博主对3种框架进行过简单的测试对比，编译速度应该是Hugo\u003eHexo\u003eJekyll。 Jekyll由Ruby开发，是Github Page默认原生支持的框架，本人了解不多。 Hexo由Node.js开发，应该是使用人数最多的，主题齐全美观，功能稳定，部署和配置比Hugo稍微麻烦些。 而Hugo，由GO语言开发，号称是最快的静态网站部署框架(200篇博文编译大概1秒)，现在也有不少人从Hexo迁移到Hugo，所以还是选Hugo吧。 简述过程： Github Page，可以用来免费部署静态网站，使用效果也很直接，创建一个代码仓库，然后将上述的静态网站框架包含的文件拖进去，选择主题配置好，然后本地编译后得到静态网页内容，一起Push到远端仓库，Github Page会帮你部署好网站，假设usernamexxx是你的Github账号，那么进入域名https://usernamexxx.github.io 就可以打开你的博客了(当然这个域名可以后续自己折腾换成其他，这是后话了)。 1.准备工作 拥有一个Github账号，参考腾讯云：一步一步教你注册GitHub账号及简单使用. (邮箱建议不要用qq邮箱，虽然用了后面也有办法换，但在后续CDN加速的时候qq邮箱可能有问题) 电脑安装Git，下载安装地址：安装 Git. 电脑安装Hugo 最简单的办法，就是直接下载二进制免安装包，安装包下载地址Hugo-Release,选择最新的安装包，解压到本地某目录，并添加一下环境变量PATH即可。 如果坚持用命令行: 如果是mac系统，相信你已经有了brew程序，直接执行 brew install hugo 即可完成安装。 如果是Windows系统想要命令行安装，则管理员身份证运行终端，执行: # 如果有chocolatey，就直接执行 choco install hugo -confirm # 如果没有chocolatey，就先安装一下 powershell -NoProfile -ExecutionPolicy unrestricted -Command \"iex ((new-object net.webclient).DownloadString('https://chocolatey.org/install.ps1'))\" # 设置环境变量 SET PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin 安装成功后，命令行执行 hugo version 检查hugo版本，能正确打印版本信息即表示正常安装。 2.开通Github-Page 不太熟悉Github的朋友，官方写了很好的Quick Start，图文并茂的，直接贴链接吧，Github Page:Websites for you and your projects. 熟悉Github的朋友，直接新建一个public的仓库，如果用户名为usernamexxx仓库名为usernamexxx.github.io。 成功之后，请立即克隆到本地，并测试第一个网页，比克隆到D盘路径\"/d/Files\",执行如下命令： #假设用户名是usernamexxx cd /d/Files git clone https://github.com/usernamexxx/usernamexxx.github.io.git cd usernamexxx.github.io #测试第一个网页 echo \"Hello World\" \u003e index.html git add --all git commit -m \"Initial commit\" git push -u origin main 注意⚠ 上述Git-Push时可能会遇到填写账号密码的问题，密码注意是需要填写Access Token，可以直接访问Github-Developer-Setting,生成一个token，当作本次密码填入(Github从2021年8月份开始就需要这样通过https推代码了))。 Git简单设置避免后续麻烦： #windows平台需要执行这个，避免行尾\\r\\n,CRLF的提示，挺烦的 git config --global core.autocrlf false #终端环境保存https的token密码，避免每次都输入密码 git config --global credential.helper store 虽然这个免费的服务有一些限制：项目大小最大为1GB，每月带宽使用不超过100GB，每小时最多构建10个版本。对于个人博客网站，是绰绰有余了，所以不用担心。 3.新建hugo site站点 对于Windows系统，以下命令行都建议在Git-Bash中运行。 如上一节所述，我们的仓库在路径\"/d/Files/usernamexxx.github.io\". #cd到git仓库的目录 cd /d/Files/usernamexxx.github.io #确认关联到了远端仓库https://github.com/usernamexxx/usernamexxx.github.io.git git branch -v # 新建hugo站点,起个英文site名，比如MyHugoBlog hugo new site MyHugoBlog ##文件夹下会生成如下 # MyHugoBlog # ├─archetypes # ├─content (markdown内容存放处,一般是content/post/hello.md) # ├─data # ├─layouts # ├─static (站点静态资源存放处,比如image,js,css) # ├─themes # └─config.toml (站点最重要的配置文件) #cd到站点目录的原因：所有hugo命令都要在hugo根目录下执行 cd MyHugoBlog 4.设置主题 Hugo支持非常多简洁又美观的主题，可以在Hugo中文站的主题列表里或者Hugo官方站的主题列表挑选，看个人喜好了。这里可以不用太纠结，可以先随便选一个，让站点运行起来先，可以很方便就换掉的(配置文件里的theme选项)。 举例，看中了Even主题,Github地址为：https://github.com/olOwOlo/hugo-theme-even ，不要直接下载或直接clone，考虑到后续可能想有自定义修改，去Github界面fork到你自己仓库，然后再添加为子模块： cd /d/Files/usernamexxx.github.io git submodule add https://github.com/usernamexxx/hugo-theme-even MyHugoBlog/theme/even 5.创建hugo新文章 hugo的新文章在content/post目录，或者content/posts目录，看个人习惯而定，试用了几个主题，不同主题默认位置可能是二者其一。例如，执行下述hugo命令： cd /d/Files/usernamexxx.github.io/MyHugoBlog #会新建文件content/post/MyFirst.md hugo new post/MyFirst.md 新生成的markdown文档默认如下(三个短横---之间是配置选项，正文内容从短横之后开始)，可以手动添加一下正文内容 ： --- title: \"First\" date: 2022-01-03T15:19:14+08:00 draft: true --- # 正文内容在这里 - Hello world,first post! 其中draft的含义是草稿的意思，在正式发布的时候不会被包含和编译，那时要改为false。 所有文章的通用设置在根目录的config.toml进行配置，需要关注的有如下选项，更多选项请参考hugo-configuration baseURL = 'https://usernamexxx.github.io' languageCode = 'zh-cn' title = \"my blog\" theme = \"even\" publishDir=\"../docs\" 上述publishDir也可以不配置，默认是根目录下的public目录，意思是后续编译出的静态网页文件存放的目录，不和hugo的内容文件混在一起的话，方便后续查看Git-Log以及其他部署工作。 至此，Hugo新站点的骨架都搭建完了，可以本地调试看看效果了，在命令行运行： cd /d/Files/usernamexxx.github.io/MyHugoBlog hugo server -w 终端提示\"Web Server is available at http://localhost:1313/ (bind address 127.0.0.1)\"，访问localHost本地URL： http://localhost:1313 ，即可看到上述添加的MyFirst.md里的内容，并且保持终端site运行的情况下，手动修改markdown内容，保存","date":"2021-12-19","objectID":"/2021/12/05_%E5%9F%BA%E4%BA%8Ehugo%E5%92%8Cgithub-page%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:0:0","tags":["Hugo","Github Page"],"title":"利用Hugo和Github-Pages搭建免费的个人博客","uri":"/2021/12/05_%E5%9F%BA%E4%BA%8Ehugo%E5%92%8Cgithub-page%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["脚本"],"content":"摘要：10个简单好用的Linux命令","date":"2021-12-18","objectID":"/2021/12/01_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/","tags":["shell脚本","linux"],"title":"10个容易遗忘但好用的Linux命令","uri":"/2021/12/01_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["脚本"],"content":"1) pgrep ​ pgrep名字前有个p，我们可以猜到这是进程相关的grep命令。不过，这个命令主要是用来列举进程ID的。 $ pgrep -u username_xx ​ 这个命令相当于： ##效果待定,awk命令不熟悉(逃 ps -ef | egrep '^username_xx' | awk '{print $2}' ","date":"2021-12-18","objectID":"/2021/12/01_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/:0:1","tags":["shell脚本","linux"],"title":"10个容易遗忘但好用的Linux命令","uri":"/2021/12/01_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["脚本"],"content":"2）pstree ​ 这个命令可以用树形的方式列出进程。 ","date":"2021-12-18","objectID":"/2021/12/01_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/:0:2","tags":["shell脚本","linux"],"title":"10个容易遗忘但好用的Linux命令","uri":"/2021/12/01_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["脚本"],"content":"3）bc ​ 这个命令主要是做一个精度比较高的数学运算的。比如开平方根等。下面是一个我们利用bc命令写的一个脚本（文件名：square.sh） #!/bin/bash if [ $# == 0 ] then echo 'Usage: sqrt number' exit 1 else echo -e \"sqrt($1)\\nquit\\n\" | bc -q -i fi #运行方式：./squar.sh 或者 ./square.sh 10.00 ","date":"2021-12-18","objectID":"/2021/12/01_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/:0:3","tags":["shell脚本","linux"],"title":"10个容易遗忘但好用的Linux命令","uri":"/2021/12/01_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["脚本"],"content":"4）split ​ 把一个很大的文件分割成一些小的文件，注意，split执行后源文件仍然在的。 #例如把上文的square.sh分割成多个文件,先查看大小，发现是124字节 ls -al #sqx_为前缀，会得到3个文件:sqx_aa,sqx_ab,sqx_ac split -b 50 square.sh sqx_ #把文件重新合并，使用cat命令即可 cat sqx_* \u003e square.sh.new ","date":"2021-12-18","objectID":"/2021/12/01_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/:0:4","tags":["shell脚本","linux"],"title":"10个容易遗忘但好用的Linux命令","uri":"/2021/12/01_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["脚本"],"content":"5）nl ​ nl命令其它和cat命令很像，只不过它会打上行号。 #不加后续的head命令也可以 benjamin@ubuntu:~$ nl square.sh | head -n 5 1 #!/bin/bash 2 if [ $# == 0 ] 3 then echo 'Usage: sqrt number' 4 exit 1 5 else ","date":"2021-12-18","objectID":"/2021/12/01_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/:0:5","tags":["shell脚本","linux"],"title":"10个容易遗忘但好用的Linux命令","uri":"/2021/12/01_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["脚本"],"content":"6）mkfifo ​ mkfifo的作用是创建一个有名管道，平时使用的较多的是无名管道，例如“ls | grep txt”. ​ 有名管道创建后可以像文件一样存在文件夹中，像是一个缓存区。 ​ 使用举例如下： #在终端窗口1执行如下命令，ls没有输出内容 mkfifo pipex ls \u003e pipex #打开终端窗口2执行如下命，会看到 ls 命令输出的内容 cat \u003c pipex 拓展：常用的管道命令有==\u003e cut、grep、sort、wc、uniq tee：重定向，既能在屏幕输出，又能保存到文件中 tr、col、join、paste、expand、split ","date":"2021-12-18","objectID":"/2021/12/01_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/:0:6","tags":["shell脚本","linux"],"title":"10个容易遗忘但好用的Linux命令","uri":"/2021/12/01_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["脚本"],"content":"7）ldd ​ 这个命令可以知道你的一个可执行文件所使用了动态链接库 ###假设有个文件calc.so,命令后接文件名即可，具体参数选项可参照命令help内容 ldd calc.so ","date":"2021-12-18","objectID":"/2021/12/01_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/:0:7","tags":["shell脚本","linux"],"title":"10个容易遗忘但好用的Linux命令","uri":"/2021/12/01_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["脚本"],"content":"8）col ​ Linux col命令用于过滤控制字符。 ​ 在许多UNIX说明文件里，都有RLF控制字符。当我们运用shell特殊字符\"\u003e“和”»\"，把说明文件的内容输出成纯文本文件时，控制字符会变成乱码，col指令则能有效滤除这些控制字符。 ​ 下面以 man 命令帮助文档为例，讲解col 命令的使用。 ​ 将man 命令的帮助文档保存为man_help，使用-b 参数过滤所有控制字符。在终端中使用如下命令： #man命令用法，man + linux命令 man man | col -b \u003e man_help ","date":"2021-12-18","objectID":"/2021/12/01_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/:0:8","tags":["shell脚本","linux"],"title":"10个容易遗忘但好用的Linux命令","uri":"/2021/12/01_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["脚本"],"content":"9）xmlwf ​ 这个命令可以让你检查一下一个XML文档是否是所有的tag都是正常的。 ","date":"2021-12-18","objectID":"/2021/12/01_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/:0:9","tags":["shell脚本","linux"],"title":"10个容易遗忘但好用的Linux命令","uri":"/2021/12/01_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["脚本"],"content":"10）lsof ​ 这个命令可以列出打开了的文件，执行lsof | grep TCP。 [benjamin@RHELSVR5 ~]# lsof | grep TCP httpd 548 apache 4u IPv6 14300967 TCP *:http (LISTEN) httpd 548 apache 6u IPv6 14300972 TCP *:https (LISTEN) httpd 561 apache 4u IPv6 14300967 TCP *:http (LISTEN) httpd 561 apache 6u IPv6 14300972 TCP *:https (LISTEN) 还可以代替netstat命令查看本机开放的网络端口，执行lsof -n -P -i TCP -s TCP:LISTEN： [benjamin@Mac-mini]# lsof -n -P -i TCP -s TCP:LISTEN COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME PicGo 4627 benjamin 55u IPv4 0x37a9d32411 0t0 TCP 127.0.0.1:36677 (LISTEN) nginx 40321 benjamin 8u IPv4 0x37a9d32411 0t0 TCP *:1935 (LISTEN) nginx 40321 benjamin 9u IPv4 0x37a9d32411 0t0 TCP *:12306 (LISTEN) nginx 40322 benjamin 8u IPv4 0x37a9d32411 0t0 TCP *:1935 (LISTEN) 杀死占用指定端口的进程： 比如hugo服务的默认预览端口1313被占用了,执行下方指令： sudo lsof -i :1313 # 输出端口相关的进程列表，第一列就是command,比如说是nginx ps -ef | grep hugo # 输出所有nginx的进程,第二列就是PID，找到对应的那个nginx进程PID,比如4366 sudo kill -9 4366 ","date":"2021-12-18","objectID":"/2021/12/01_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/:0:10","tags":["shell脚本","linux"],"title":"10个容易遗忘但好用的Linux命令","uri":"/2021/12/01_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["计算机图形学"],"content":"摘要：Metal官方文档MetalGuide系列第一部分 -\u003e 基本的指令和执行模型","date":"2021-12-18","objectID":"/2021/12/02_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/","tags":["Metal","图形渲染"],"title":"MetalGuide(1)指令组织和执行模型","uri":"/2021/12/02_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/"},{"categories":["计算机图形学"],"content":"1. 基本概念认知 ​ Metal 是一个和 OpenGL ES 类似的面向底层的图形编程接口，通过使用相关的API 可以直接操作 GPU。不过不同的是，Metal不具有跨平台特性，只针对苹果的平台系统使用，并且编程开发语言为Objective - C或Swift。 ​ Metal框架支持GPU加速的3D图形渲染和并⾏数据计算，它提供了一系列的API用于在细粒度和低层次上组织、处理、提交图形渲染指令、并⾏计算指令，并管理和这些指令相关联的数据和资源。使用Metal的一个主要⽬标是减少GPU执⾏这些计算的开销。 2. 指令组织和执行模型 ​ 一个command queue包含了一系列command buffers。command queue用于组织它拥有的各个command buffer按序执行。一个command buffers包含多个被编码的指令，这些指令将在一个特定的设备上执⾏。一个Encoder可以将绘制、计算、位图传输指令推入一个command buffer，最后这些command buffer将被提交到设备执⾏。 ​ 任一时刻，只会有一个Encoder是处于激活状态的，它可以向一个command buffer提交指令。前一个Encoder结束后，另一个Encoder才可以被创建并用于同一个command buffer。 ​ 最终，他们的逻辑模型类似于下图： ","date":"2021-12-18","objectID":"/2021/12/02_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/:0:0","tags":["Metal","图形渲染"],"title":"MetalGuide(1)指令组织和执行模型","uri":"/2021/12/02_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/"},{"categories":["计算机图形学"],"content":"2.1 何为设备 ​ 一个MTLDevice对象代表一个可以执行指令的GPU，该协议包含创建新的command queue的方法、从内存申请缓存的方法、创建纹理对象的方法以及查询设备功能的方法。调用MTLCreateSystemDefaultDevice方法获取系统首选的设备对象。 ","date":"2021-12-18","objectID":"/2021/12/02_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/:1:0","tags":["Metal","图形渲染"],"title":"MetalGuide(1)指令组织和执行模型","uri":"/2021/12/02_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/"},{"categories":["计算机图形学"],"content":"2.2 暂态/非暂态(Non-Transient)对象 ​ 故名思义，两者是按照对象的生命周期来区分的。 在Metal中有些对象被设计成暂态，使用它们⾮常轻量。 另外一些则要昂贵许多，因此它们应该拥有长的生命周期。 非暂态对象在性能相关的代码中应该避免反复创建，尽量重用，Metal的非暂态对象列表如下： 相对地，Metal的暂态对象用于一次性使用,创建和销毁的成本廉价,它们的创建方法都返回autoreleased对象。Metal的暂态对象列表如下： ","date":"2021-12-18","objectID":"/2021/12/02_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/:2:0","tags":["Metal","图形渲染"],"title":"MetalGuide(1)指令组织和执行模型","uri":"/2021/12/02_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/"},{"categories":["计算机图形学"],"content":"2.3 指令队列(Command Queue) ​ 一个command queue管理着一个在GPU上即将执⾏的command buffer有序队列。同一个队列的所有command buffer都会被按照入队的次序执⾏。通常，command queue是线程安全的，允许多个command buffer 同时编码。 ​ 如何创建Command Queue，以下的2个方法都是可行的: newCommandQueue newCommandQueueWithMaxCommandBufferCount ⚠️：Command Queue是非暂态对象，是具有长生命周期的，不要反复地创建和销毁这种对象。 ","date":"2021-12-18","objectID":"/2021/12/02_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/:3:0","tags":["Metal","图形渲染"],"title":"MetalGuide(1)指令组织和执行模型","uri":"/2021/12/02_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/"},{"categories":["计算机图形学"],"content":"2.4 指令缓存(Command Buffer) ","date":"2021-12-18","objectID":"/2021/12/02_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/:4:0","tags":["Metal","图形渲染"],"title":"MetalGuide(1)指令组织和执行模型","uri":"/2021/12/02_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/"},{"categories":["计算机图形学"],"content":"2.4.1 Command Buffer的特点 ​ 一个command buffer在被GPU执行之前会存储多个被编码的指令。一个command buffer可以包含多种类型的编码。 ​ Command Buffer具有以下特点： 一帧渲染即使含有多个RenderPass或多个计算处理程序、多个位图操作，都可以被编码到同一个Command Buffer中； 它是暂态对象，不支持重用；一旦被提交等待执行，即进入队列； 它还代表了app中独立的可被追踪的任务单元。 ","date":"2021-12-18","objectID":"/2021/12/02_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/:4:1","tags":["Metal","图形渲染"],"title":"MetalGuide(1)指令组织和执行模型","uri":"/2021/12/02_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/"},{"categories":["计算机图形学"],"content":"2.4.2 创建Command Buffer ​ 如何创建Command Buffer对象，以下的2个方法都是可行的: commandBuffer：数据是强引用的，一个MTLCommandBuffer对象只能提交给创建它的那个command queue。 commandBufferWithUnretainedReferences：数据不是强引用的，在可以保证和command buffer相关数据在其被执⾏时都有引用计数的情况下，又极端需要提升性能，才会使用该方法。使用时需要格外注意引用计数。 ","date":"2021-12-18","objectID":"/2021/12/02_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/:4:2","tags":["Metal","图形渲染"],"title":"MetalGuide(1)指令组织和执行模型","uri":"/2021/12/02_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/"},{"categories":["计算机图形学"],"content":"2.4.3 执行指令 ​ MTLCommandBuffer协议使用如下的方法来设定其在指令队列中的执⾏顺序： enqueue：为一个command buffer在command queue中预定一个位置，但是不会提交这个command buffer。当这个command buffer最终被提交时，指令队列把它安排在对应的enqueue顺序队列中执行。 commit：使得command buffer尽可能快地被执⾏，但还是得等到所有在command queue中的早前排入队列的 其他command buffer被执行完成后才能执⾏。如果commad queue中没有排在前面的command buffer，该方法隐式执⾏enqueue操作。 ","date":"2021-12-18","objectID":"/2021/12/02_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/:4:3","tags":["Metal","图形渲染"],"title":"MetalGuide(1)指令组织和执行模型","uri":"/2021/12/02_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/"},{"categories":["计算机图形学"],"content":"2.4.4 注册处理程序块(Register Handler Blocks) ​ 下列的MTLCommandBuffer的方法可以监视指令的执⾏。使用了这些方法注册处理程序块，那么在某个线程中，这些处理程序块会按照执⾏顺序被调用。这些处理程序块应该是迅速可被执⾏完成的，如果有开销⼤的造成阻塞的任务，那么应该将它们安排到其他线程执⾏行。 addScheduledHandler : 注册的处理程序块将在command buffer被“排定好”(scheduled)时调用。“排定好”一般是指，MTLCommandBuffer对象或系统API提交的所有任务之间的依赖关系都能被满⾜。 waitUntilScheduled : 调用后就开始等待，return时机为所有command buffer被“排定好”而且addScheduledHandler方法注册的处理程序块都执行完毕。 addCompletedHandler : 注册的处理程序块将在command buffer被执⾏完毕后立即调用；一个command buffer对象可以注册多个这样的处理程序块。 waitUntilCompleted : 调用后就开始等待，return时机为所有command buffer都执行完而且addCompletedHandler注册的处理程序块都执行完毕。 presentDrawable : 较为便捷，它用于当command buffer处于“排定好”时呈现一个可显示资源 (CAMetalDrawable类型对象)的内容。 执行完毕后，需要关注以下2种Command Buffer的属性： status: 只读属性，包含了一个MTLCommandBufferStatus类型的枚举值，它反映了command buffer在其生命周期中处于哪个阶段。 error：如果command buffer成功执⾏，值为nil。如果有异常发生，值为“Command Buffer Error Codes”类型。且status属性被设 置为MTLCommandBufferStatusError。 ","date":"2021-12-18","objectID":"/2021/12/02_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/:4:4","tags":["Metal","图形渲染"],"title":"MetalGuide(1)指令组织和执行模型","uri":"/2021/12/02_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/"},{"categories":["计算机图形学"],"content":"2.5 指令编码(Command Encoder) ","date":"2021-12-18","objectID":"/2021/12/02_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/:5:0","tags":["Metal","图形渲染"],"title":"MetalGuide(1)指令组织和执行模型","uri":"/2021/12/02_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/"},{"categories":["计算机图形学"],"content":"2.5.1 Command Encoder的特点 ​ Command Encoder用来编码渲染和计算指令，然后被推入到一个command buffer并最终在GPU上执行。它具有以下特点： 它有多个对象方法可以往Command Buffer里追加指令； 当一个Encoder是激活状态时，就可以调用endEncoding方法向它所属的command buffer推送指令； 推送完成后要写入更多的指令，就创建一个新的 Encoder。 ","date":"2021-12-18","objectID":"/2021/12/02_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/:5:1","tags":["Metal","图形渲染"],"title":"MetalGuide(1)指令组织和执行模型","uri":"/2021/12/02_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/"},{"categories":["计算机图形学"],"content":"2.5.2 创建Command Encoder ​ MTLCommandBuffer协议中的若干方法都可以创建Command Encoder对象，这些对象可以向对应的command buffer推送指令。具体地，以下的4个方法都是可行的: renderCommandEncoderWithDescriptor ：创建一个MTLRenderCommandEncoder类型的Encoder实现图形渲染，图形绘制用到的attachment附件由那个MTLRenderPassDescriptor类型的入参对象指定； computeCommandEncoder ：创建一个MTLComputeCommandEncoder类型的Encoder来实现并行数据计算； blitCommandEncoder ：创建一个MTLBlitCommandEncoder类型的Encoder来实现内存操作； parallelRenderCommandEncoderWithDescriptor ：创建一个MTLParallelRenderCommandEncoder类型的Encoder，它用于支持多个MTLRenderCommandEncoder类型的⼦Encoder同时在不同的线程中运⾏，依然把所有绘制结果写入同一个attachment中，该attachment由MTLRenderPassDescriptor类型的入参指定。 ","date":"2021-12-18","objectID":"/2021/12/02_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/:5:2","tags":["Metal","图形渲染"],"title":"MetalGuide(1)指令组织和执行模型","uri":"/2021/12/02_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/"},{"categories":["计算机图形学"],"content":"2.5.3 多种用途的Command Encoder ​ a. 用于渲染的Command Encoder ​ 图形渲染可以被描述为一系列的Render Pass，一个MTLRenderCommandEncoder对象表示和一个Render Pass相关联的渲染状态和渲染命令。这个Encoder对象需要一个相关联的MTLRenderPassDescriptor对象，在这个descriptor对象中包含颜⾊、深度、模板等依赖信息。 ​ MTLRenderCommandEncoder拥有各类方法可以完成以下事项： ​ 设定图形资源，比如缓存和纹理对象，这些对象包含着顶点⽚元和纹理数据； ​ 设定固定图形渲染管线状态，包括视口，三角形填充模式，裁剪矩形，深度测试和模板测试等等。 ​ b. 用于并行计算的Command Encoder ​ 使用MTLCommandBuffer的computeCommandEncoder方法可以创建一个并行计算用的Command Encoder。 ​ 对于并⾏数据计算，MTLComputeCommandEncoder协议提供了方法来编码计算指令，以此设定计算程序和参数，调度计算程序执⾏。 ​ c. 用于位图操作的Command Encoder ​ 使用MTLCommandBuffer协议的blitCommandEncoder方法可以创建一个MTLBlitCommandEncoder。 ​ MTLBlitCommandEncoder协议提供了方法用来在缓存(MTLBuffer) 和纹理(MTLTexture)之间进⾏拷贝。 ​ 该协议还提供了用一种颜⾊填充纹理的方法，以及创建mipmap的方法。 ​ ","date":"2021-12-18","objectID":"/2021/12/02_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/:5:3","tags":["Metal","图形渲染"],"title":"MetalGuide(1)指令组织和执行模型","uri":"/2021/12/02_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/"},{"categories":["计算机图形学"],"content":"2.6 多线程与Command Buffer/Command Encoder ​ 很多的应用程序只是用一个线程来编码绘制指令到一个command buffer来绘制一帧画面。在每帧绘制的末尾， 提交commad buffer，如此可以排定和开始指令的执行。 ​ 如果希望并行地让command buffer执⾏指令编码，那么可以同时创建多个command buffer，使用多个线程，每个线程单独为一个command buffer编码指令。 ​ 如果事先知道command buffer应该以什么顺序执⾏，那么 MTLCommandBuffer的enqueue方法可以在command queue中声明执⾏行顺序，⽽不必等待执⾏编码和提交操作。否则只能等到command buffer被提交，这时在command queue中它就被指定了一个位置，顺序位于之前提交的 command buffer后面。 ​ 任一时刻只有一个GPU线程在访问command buffer，多线程的应用可以为每个command buffer准备一个线程，如此实现并⾏创建多个command buffer。 ​ 下图示例了一个3线程应用，每个线程都操作一个command buffer，每个线程中，任一时刻只有一个Encoder在访问它对应的command buffer。当你完成了编码，调用Encoder的endEncoding方法，然后一个新的Encoder才可以为command buffer编码指令。 参考链接: Apple-Metal-Programming-Guide Metal’s Best Practice ","date":"2021-12-18","objectID":"/2021/12/02_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/:6:0","tags":["Metal","图形渲染"],"title":"MetalGuide(1)指令组织和执行模型","uri":"/2021/12/02_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/"},{"categories":["程序设计"],"content":"摘要：Effective C++(第三版)内容第一、第二章的总结","date":"2021-12-12","objectID":"/2021/12/06_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(一)","uri":"/2021/12/06_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/"},{"categories":["程序设计"],"content":"序言 这本C++的经典之作，作者是大佬Scott Meyers👉大佬主页，还写过其他几本影响深远的C++经典，例如《Effective STL》,《More Effective C++》,《Effective Mordern C++》,《Overview of the New C++(C++11/14)》等等。本人看的是中文版，侯捷老师翻译的，精读分析并实践推敲后，整理成博客记录下来。 关于Effective C++，全书55个C++条款，许多人都做了笔记类的博客，大家视角不同可能侧重也不同，各花入各眼了。(PS:本文主干目录和原书一致，另外，由于原书在C++11之前写成，所以会根据本人开发经验新增一些个人感悟👉By the way环节) (Effective-C++总结系列分为四部分，本文为第一部分，涉及原书第1~2章，内容范围Rule01~12。为方便书写，Rule01简写为R01)。 Effective-C++系列List 本博客站点系列内容如下： 💡 Effective C++(第3版)精读总结(一) 💡 Effective C++(第3版)精读总结(二) 💡 Effective C++(第3版)精读总结(三) 💡 Effective C++(第3版)精读总结(四) 废话不多说，直接进入正题。 ","date":"2021-12-12","objectID":"/2021/12/06_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/:1:0","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(一)","uri":"/2021/12/06_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/"},{"categories":["程序设计"],"content":"CH1.让自己习惯C++ ","date":"2021-12-12","objectID":"/2021/12/06_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/:2:0","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(一)","uri":"/2021/12/06_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/"},{"categories":["程序设计"],"content":"R01 视C++为一个语言联邦 如今的C++已经是个多重范式(multiparadigm)语言,同时支持面向过程形式、面向对象形式、函数形式、泛型形式、元编程形式。 要理解这么多特性，可以简单的归结为四种次语言(sublanguage)组成： C语言：C++仍以C为基础。C++是C的超集，区块 、语句、预处理、内置数据类型、数组、指针等全部来自于C语言； Object-Oriented C++: 面向对象特性。构造、析构、封装(encapsulation)、继承(inheritance)、多态(polymorhpism)、virtual函数(动态绑定)等； Template C++:C++的泛型(generic)编程的部分，也带来了黑魔法-模板元编程(TMP,Metaprogramming)； STL：STL(Standard Temlate Library)即标准模板库，它是template程序库。封装了各类容器(container)、配置器(allocator)、迭代器(iterator)、算法以及常用对象。 ","date":"2021-12-12","objectID":"/2021/12/06_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/:2:1","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(一)","uri":"/2021/12/06_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/"},{"categories":["程序设计"],"content":"R02 尽量以const,enum,inline替换#define 对于宏定义的常量，建议用const常量或者枚举enum替换 这样做的好处是方便调试，因为宏报错就是个常数值，没有符号表；并且宏不具有封装性(宏的作用域是在编译时是其定义之事)。 // 举例：MAX_DATA_COUNT在预处理阶段就会被替换，编译器不会见到它，所以一旦有相关报错，给的是100这个值 #define MAX_DATA_COUNT 100 const int MAX_DATA_COUNT = 100 ;//常量只有一份，宏会导致多份常量值 class Buffer{ public://...类其他部分省略 static const double factor_ ;//static常量,类内声明 static const int times_ = 2;// int类型允许类内初始化,规范上还是建议拿到类外 private: static const int ArrLength = 5; int arr[ArrLength]; }; const double Buffer::factor_ = 0.1;//类外初始化,一般写在实现文件*.cpp,*.cc中 如果编译器不允许声明时\"in-class初值设定\",如果是整形常量，可以让枚举值来替代，而且枚举值不能被取地址。 对于宏定义的函数，建议用内联inline函数替换 宏函数没办法单行debug调试，而内联函数可以； 宏的写法即使小心翼翼的加好了括号，也可能造成意想不到的宏函数重复计算的问题。 #define GET_MAX(a,b) ((a)\u003e(b) ? (a) :(b)) int a = 5, b = 0; GET_MAX(++a,b); // a累加二次 GET_MAX(++a,b+10); // a累加一次 // 定义个inline函数就不会有这个问题,(a,b)作为函数入参就只会计算一次 By the way 上述情况，从纯C语言角度，想避免“宏函数重复计算”，其实还有个方法，就是使用GNU C 扩展的 typeof 或 GCC 的 __auto_type 关键字，详细可参考GCC官方文档页面。2者都适用于GCC和Clang，都不适用MSVC），示例如下： #define GET_MAX_ONCE(a,b) \\ ( {typeof(a) _a = (a); \\ typeof(b) _b = (b); \\ (_a) \u003e (_b) ? (_a) : (_b); } ) 测试代码如下： int a = 10,b = 20; int c = GET_MAX(++a, b++); std::cout \u003c\u003c \"a = \" \u003c\u003c a \u003c\u003c \", b = \"\u003c\u003c b \u003c\u003c \", c = \" \u003c\u003c c \u003c\u003c std::endl; a = 10 , b = 20; c = GET_MAX_ONCE(++a, b++); std::cout \u003c\u003c \"a = \" \u003c\u003c a \u003c\u003c \", b = \"\u003c\u003c b \u003c\u003c \", c = \" \u003c\u003c c \u003c\u003c std::endl; 测试代码输出： a = 11, b = 22, c = 21 a = 11, b = 21, c = 20 🤔 使用 __auto_type 来取代时要赋初值，关键的 typeof 那行用法改为 __auto_type _a = (a); 。 __auto_type 比 typeof 的优势之处在于面对变长数组(VLA)，只解析1次；以及面对嵌套宏定义时也是只严格解析一次。 ","date":"2021-12-12","objectID":"/2021/12/06_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/:2:2","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(一)","uri":"/2021/12/06_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/"},{"categories":["程序设计"],"content":"R03 尽可能用const 说起const，先复习个面试高频题😁 //类型char在哪里没关系，关键看const和*的相对位置：const在*左边，指针所指物为常量; const在*右边，指针为常量； const char* p; // 指针p所指的字符串为常量，但是p可以修改 char* const p; // 指针p是常量，指向的字符串可修改 const修饰函数返回值时的防御性 const修饰函数的返回值，可以避免一些错误，如下： const Rational operator* (const Rational\u0026 lhs,const Rational\u0026 rhs); //存在Rational a,b,c; if(a*b = c) //例如手误 \"==\"打成了\"=\"，编译器会直接报错 const成员函数的限制 const成员函数有2个好处：明确理解函数是否修改对象内容；使“操作const对象”成为可能。 可以通过const特性让对象自动调用正确的版本： class TextBlock{//...类其他部分省略 const char\u0026 operator[](std::size_t index) const{ return text[index];} char\u0026 operator[](std::size_t index) { return text[index];} private: std::string text; } void print(const TextBlock\u0026 ctb){ std::cout\u003c\u003cctb[0] ;//根据const特性，调用 const TextBlock::operator[] } 思考：const成员函数不修改成员对象，那么，如果成员对象为指针char *p，仅修改p指向的内容，那它还是const成员函数吗？ 实测：const成员函数是允许p[2]= 'x'这一操作的，但是不允许p++； bitwise-constness(又称为physical constness)理念认为不是，不能更改任何对象内的任何一个bit。这种说法也有纰漏，const函数返回一个引用就失控了,外部可改； logical-constness理念则允许const成员函数修改成员变量的bits，但只有在客户端侦测不出的情况下; const成员函数如果一定要修改成员变量，成员变量使用 mutable 修饰即可. const与non-const的成员函数实现完全相同时 这种情况，如何去除代码冗余是个问题。不要封装出一个private函数然后一起调用，多了层调用。 正确做法👉 使用转型,让non-const调用const成员函数，如下为示例： class Rawdata { public: Rawdata(char *src):p_(src),length_(strlen(src)) {} const int\u0026 GetLength()const{ p_[1] = 'a';//为求简便,不作检查了。p_内容修改编译器是允许的. return length_; } int GetLength() { return const_cast\u003cint\u0026\u003e( (static_cast\u003cconst Rawdata\u0026\u003e(*this)).GetLength()); } private: char *p_ = nullptr; int length_ = 0; }; ","date":"2021-12-12","objectID":"/2021/12/06_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/:2:3","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(一)","uri":"/2021/12/06_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/"},{"categories":["程序设计"],"content":"R04 确定对象使用前先初始化 分清\"赋值\"和\"初始化\"，在类的构造函数体内使用等号\"=“赋值并非\"初始化”。成员变量的初始化是在构造函数的成员初始化列表实现，效率更高。 C++初始化的次序： Base class总是早于Derived Class被初始化； Class内的成员变量总是以声明次序被初始化； 举例：下图中的代码初始化顺序为声明顺序\"age_$\\rightarrow$name_$\\rightarrow$gender_ $\\rightarrow$isVip_\" class Customer { public: //这里只是为了验证，如果是实际工程代码，建议初值列表尽量和声明顺序保持一致 Customer(std::string gender, uint8_t age, std::string name, bool isVip = false) :isVip_(isVip), gender_(gender), name_(name), age_(age) {} private: uint8_t age_; std::string name_; std::string gender_; bool isVip_; }; By the way 💡：任何一个成员变量a的初始化流程：类内声明赋初值(C++11)-\u003e构造函数初始化列表-\u003e构造函数体内赋值. 函数体外static变量称为non-local static变量，这种变量可以在各自的编译单元正常工作，但C++无法保证初始化次序，当编译单元之间需要共享变量时，而该变量依赖non-local static，就可能会出问题。 解决办法是将这样的变量放回函数体内，成为local static，因为C++确保在函数被调用时一定会初始化这个static变量。 ","date":"2021-12-12","objectID":"/2021/12/06_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/:2:4","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(一)","uri":"/2021/12/06_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/"},{"categories":["程序设计"],"content":"CH2.构造/析构/赋值运算 ","date":"2021-12-12","objectID":"/2021/12/06_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/:3:0","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(一)","uri":"/2021/12/06_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/"},{"categories":["程序设计"],"content":"R05 了解C++默认编写并调用哪些函数 编译器可以暗自为Class创建default构造函数，copy构造函数(复制构造)，copy assigment(赋值构造)操作符，以及default析构函数。 class EmptyClass{}; 等价于👇 class EmptyClass { public: EmptyClass() {} // default构造函数 EmptyClass(const EmptyClass\u0026 rhs) {}//copy构造函数 ~EmptyClass() {}//default析构函数，注意是non-virtual EmptyClass\u0026 operator=(const EmptyClass\u0026 rhs) {}//copy assignment操作符 }; 如果一个非空Class自行声明了构造函数，编译器就不再为它创建default构造函数 如果一个Class内有引用变量或const变量，编译器不会为其生成copy-assignment函数，需要自己实现 class NameObject { public: NameObject(std::string\u0026 name, const int value) :nameValue_(name), objectVal_(value) {} private: std::string\u0026 nameValue_; const int objectVal_; };//考虑以下应用代码 std::string name(\"Mike\"), name2(\"Nicky\"); NameObject nObj(name,22), nObj2(name2,33); nObj2 = nObj;//这一句会导致编译失败，因为引用不能指向2个对象，且const不可改 ","date":"2021-12-12","objectID":"/2021/12/06_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/:3:1","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(一)","uri":"/2021/12/06_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/"},{"categories":["程序设计"],"content":"R06 不想编译器的自动生成的函数,明确拒绝 某些场景，类对象本身是认为独一无二的，比如描述人物性格的类Personality(可能不恰当)，不同的人性格不同，肯定是不希望能复制/赋值的。 如果不想编译器自动生成那几个函数，比如不想要复制构造或赋值构造，就明确在代码中禁止，也防止外部用户使用。 技巧1：可以声明为private函数但是不给出实现，让编译器报错； 技巧2：可以设立基类Base，让复制构造和赋值构造都为private函数，让目标类继承于Base类。 By the way C++11针对此类情况，给予了delete关键字一个新功能，在成员函数后面新增\"=delete\"，即可显式地拒绝这个函数的生成和调用.举例如下: class A { public: A(const A\u0026) = delete; A\u0026 operator=(const A\u0026) = delete; }; ","date":"2021-12-12","objectID":"/2021/12/06_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/:3:2","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(一)","uri":"/2021/12/06_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/"},{"categories":["程序设计"],"content":"R07 为多态基类声明virtual析构函数 针对Base* pBase= new DerivedObj()，释放pBase时，如果Base基类的析构函数None-Virtual，则会导致Derived的析构函数不会被调用，造成内存不完全释放，即内存泄漏； Non-Virtual的Class不要做基类； 如果不做基类，就不要声明析构函数为virtual函数，避免虚表为其分配vptr造成浪费； 如果想要抽象类，又暂时没有合适接口，可以让先虚析构成为纯虚函数，例如： class RawData{ public: virtual ~RawData() = 0; }; // 这里特殊的是，需要为这个纯虚函数提供定义 ~RawData::RawData(){} ","date":"2021-12-12","objectID":"/2021/12/06_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/:3:3","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(一)","uri":"/2021/12/06_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/"},{"categories":["程序设计"],"content":"R08 别让异常逃离析构函数 析构函数最好不要吐出异常 对于某个Widget类，如果析构函数抛出异常，那么vector\u003cwidget\u003e析构时可能连续抛出多个异常以至于无法处理，直接导致提前程序结束或者未定义行为。 如果有某个函数可能会抛出异常，并需要对异常做出反应，应该提供一个非析构的函数来处理 注意，在析构中抛异常并吞下(catch后go-on-execute)，会掩盖错误，也不是个好办法;抛异常后catch住并std::abort()反而可以提前终结『未定义行为』。 ","date":"2021-12-12","objectID":"/2021/12/06_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/:3:4","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(一)","uri":"/2021/12/06_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/"},{"categories":["程序设计"],"content":"R09 绝不在构造和析构过程中调用virtual函数 在Derived-Class的Base-Class构造期间，对象的类型是Base-Class，而非Derived，即使dynamic_cast也是这样认为的，因为此时virtual函数不会下降到Derived-Class的阶层；换句话说==\u003e “在Base-Class构造期间，virtual函数不是virtual函数” ； 在析构的时候也是类似道理，也不要在析构函数中调用virtual函数，间接调用也不行(比如non-Virtual-\u003evirtual)； 那么替代方案是？ 如果有这样一种情况，希望在子类构造时能调用父类的foo函数(下方logTransaction函数)，那么将foo改为non-Virtual函数，并且子类构造时调用父类构造函数，有参数时一并传过去； class Transaction { public: explict Transaction(const std::string\u0026 info,int id):id_(id) { logTransaction(info); } void logTransaction(const std::string\u0026 info) { std::cout \u003c\u003c info.c_str(); }//non-Virtual函数 private: int id_; }; class BuyTransaction :public Transaction { public: //将log信息传递给 基类Transaction构造函数； 并初始化了基类成员 BuyTransaction(const std::string\u0026 info, int id) :Transaction(info,id) {/**/} }; By the way 上述代码中，如果有几个Base构造函数，就得写几个Derived构造函数传参。为了简化这一步骤， 在现代C++11，推出了继承构造函数(Inheriting Constructor)，子类可以一个都不用写，直接写一句using声明即可，使用using BaseClass::BaseClass的形式，如下👇 class BuyTransaction :public Transaction { public: using Transaction::Transaction; //其他 }; ","date":"2021-12-12","objectID":"/2021/12/06_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/:3:5","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(一)","uri":"/2021/12/06_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/"},{"categories":["程序设计"],"content":"R10 令operator=返回一个reference to *this 关于赋值操作符operator= ，主流做法是： class Widget { public: Widget\u0026 operator=(const Widget \u0026rhs) { //... do some thing return *this; } }; 上述做法不局限于operator=，还有operator += ,-=,*=,/=等其他赋值运算符。 该主流协议/做法不是强制性的，只是个建议，因为这样可以允许连续赋值($x=y=z$的形式)。 该协议被内置类型，以及STL的类型(如string,vector,complex,shared_ptr)共同遵守。 ","date":"2021-12-12","objectID":"/2021/12/06_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/:3:6","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(一)","uri":"/2021/12/06_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/"},{"categories":["程序设计"],"content":"R11 在operator=中处理\"自我赋值\" 一个对象赋值给自己，这种看起来有点傻的做法，有时候会比较难以发觉。比如：a[i] = a[j]，如果 $i$ 和 $j$ 相等，就是“自我赋值”的经典场景了。 所以，我们需要一个尽量完备的赋值操作符函数🤔。 考虑如下类MapWidget，内有数据裸指针BitMap *pb_，在赋值时同时考虑异常安全和 “自我赋值” 安全(认同测试保障自我赋值安全)，是一个相对不错的实现。但是，认同测试会降低运行效率，根据实际工程实践情况(自我赋值概率极低 )可以酌情去掉。 class BitMap {/*省略类声明\u0026实现*/}; class MapWidget { private: BitMap * pb_ = nullptr; public: explicit MapWidget(BitMap *pb) :pb_(pb) {} MapWidget\u0026 operator=(const MapWidget\u0026 rhs) { if (this == \u0026rhs) return *this; //这一句为认同测试(identity test) BitMap *pOrig = pb_;//不要一上来就delete，而是保存this-\u003epb_ pb_ = new BitMap(*rhs.pb_);//因为这一句可能抛异常 delete pOrig; return *this; } }; Copy and Swap技术 上文中保障异常安全和 “自我赋值” 安全的技术手段，另外一个办法，就是Copy and Swap技术。这个技术的关键在于“修改对象数据的副本，然后在一个不抛异常的函数中将修改的数据和原件置换 ”。 void MapWidget::Swap(MapWidget\u0026 rhs){std::swap(rhs.pb_,pb_);} MapWidget\u0026 MapWidget::operator=(const MapWidget\u0026 rhs) { MapWidget temp(rhs); Swap(temp); return *this; } ","date":"2021-12-12","objectID":"/2021/12/06_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/:3:7","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(一)","uri":"/2021/12/06_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/"},{"categories":["程序设计"],"content":"R12 复制对象时别忘记其每一个成分 编写类的Copying函数时需要做到2点 这里的Copying函数是指有copy属性的特殊函数==\u003e copy构造函数和copy赋值操作符。 复制所有Local成员变量 如果成员复制的时候有遗漏，编译器并不会有怨言，这就埋下了隐患。如果新增了成员，要对应修改Copying函数。 调用所有Base-Class内部的适当的Copy函数 具体代码的推荐实现 如下👇： class Customer { public: Customer(std::string name, float money):name_(name),money_(money) {} private: std::string name_; float money_; }; class VipCustomer :public Customer { public: //注意：派生类要复制基类那部分的成员变量 using Customer::Customer; //参考R09 VipCustomer(const VipCustomer\u0026 rhs) :priority_(rhs.priority_),Customer(rhs){} VipCustomer\u0026 operator=(const VipCustomer\u0026 rhs){ Customer::operator=(rhs); priority_ = rhs.priority_; return *this; } void setPriority(int priority) { priority_ = priority; }; private: int priority_;//子类独有成员可以单独set函数赋值，或者构造函数初始化列表赋值 }; 不要用一个Copying函数去实现另一个 令copy-assignment操作符调用copy构造函数是不合理的；反之，后者调用前者也是无意义的。 如果2者有大量的代码是相同的，可以剥离一个类内private类型的init函数出来，提供给上述2者调用。 ","date":"2021-12-12","objectID":"/2021/12/06_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/:3:8","tags":["C++","程序设计"],"title":"Effective C++(第3版)精读总结(一)","uri":"/2021/12/06_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/"},{"categories":null,"content":"友链墙 ","date":"0001-01-01","objectID":"/friends/:0:0","tags":null,"title":"","uri":"/friends/"},{"categories":null,"content":"主题与配置相关 本博客是由 Hugo静态框架 以及主题 LoveIt 搭建的，并逐步配置优化而得，感谢主题作者！ \rdillonzq / LoveIt\r\"Hugo-LoveIt主题\"\r\r\r\r\rLoveIt官方文档\r\"Hugo-LoveIt主题官方文档\"\r\r\r\r","date":"0001-01-01","objectID":"/friends/:1:0","tags":null,"title":"","uri":"/friends/"},{"categories":null,"content":"【大佬们】 \r雨临Lewis的博客\r\"不想当写手的码农不是好咸鱼_(xз」∠)_\"\r\r\r\r\r我的学习小站\r\"一个野生OI教练的逼逼叨。\"\r\r\r\r\r旭穹の陋室\r\"苔痕上阶绿，草色入帘青\"\r\r\r\r","date":"0001-01-01","objectID":"/friends/:2:0","tags":null,"title":"","uri":"/friends/"},{"categories":null,"content":"本站友链信息 name=\"Benjamin旅记\" url=\"https://kissingfire123.github.io\" logo=\"https://s2.loli.net/2022/06/12/I5LzEte8TuOPhYX.webp\" word=\"人生如逆旅，不妨以求知为伴。\" group=\"图形图像\" ","date":"0001-01-01","objectID":"/friends/:3:0","tags":null,"title":"","uri":"/friends/"},{"categories":null,"content":"如何交换友链 请在本页评论区里（也可以通过邮件）添加如下格式，添加友链成功后，会通过回复评论的邮件通知进行反馈： ","date":"0001-01-01","objectID":"/friends/:4:0","tags":null,"title":"","uri":"/friends/"},{"categories":null,"content":"必填项 name=\"站点名字\" url=\"站点地址\" logo=\"站点图标或个人头像\" word=\"站点描述\" ","date":"0001-01-01","objectID":"/friends/:4:1","tags":null,"title":"","uri":"/friends/"},{"categories":null,"content":"选填项 //默认分组是大佬们 group=\"大佬们\" # 目前想到的是 前端技术,后端开发,网络安全,图形图像,大数据,人工智能,生活博文 //鼠标悬停时的背景颜色，允许设置渐变色 //支持7种：default、red、green、blue、linear-red、linear-green、linear-blue primary-color=\"default\" //边框动画：shadow(阴影，此为默认效果)、borderFlash(边框闪现)、led(多种颜色切换呼吸灯)、bln(主颜色呼吸灯) border-animation=\"shadow\" ","date":"0001-01-01","objectID":"/friends/:4:2","tags":null,"title":"","uri":"/friends/"},{"categories":null,"content":"友链须知 您的博客需以原创为主，内容不违背法律与道德，类型不限，谢绝纯搬运或参考后不注明来源的行为。 若您的头像无法获取时，会自动使用默认头像。 当您的网站存在无法访问、删除本站友链等情况时，本站可能会撤掉贵站链接并邮件告知！ ","date":"0001-01-01","objectID":"/friends/:5:0","tags":null,"title":"","uri":"/friends/"}]