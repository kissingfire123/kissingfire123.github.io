[{"categories":["脚本"],"content":"摘要：对常用的markdown语法(基本语法+扩展语法)做个总结概述，备忘查询","date":"2022-01-11","objectID":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/","tags":["markdown","工具"],"title":"Markdown语法总结","uri":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/"},{"categories":["脚本"],"content":"前言 Markdown是一种轻量级标记语言，于2004年由创始人John Gruber发布，采用并不复杂的语法，可以书写简洁美观带有格式的文本。 基本语法 关于符号 重要的事情提前说：Markdown中的所有标记符号都是英氏符号，也就是输入法为输入英文状态下的时候。(尤其警惕竖向分隔线|，感叹号!，括号()，等等…中英文的这几个有点像) ","date":"2022-01-11","objectID":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/:0:0","tags":["markdown","工具"],"title":"Markdown语法总结","uri":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/"},{"categories":["脚本"],"content":"段落与换行 空行可以用来段落分割，输入回车Enter换行即可； 段落内换行可以使用\u003cbr\u003e来换行，通常可以用在markdown表格内换行; 某些markdown编辑器在写完上一行文本后输入Enter换行依然未能换行生效，那就再Enter一个空行，或者在上一行末尾加2个连续空格； 如果不是在列表内的段落，不鼓励行首缩进； ","date":"2022-01-11","objectID":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/:1:0","tags":["markdown","工具"],"title":"Markdown语法总结","uri":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/"},{"categories":["脚本"],"content":"标题层级 Markdown使用符号 # 来表示标题的层级，几个 # 号就是几级标题，通常用到4级就足够内容排布了。 输入内容 渲染效果 # 一级标题 ## 二级标题 ### 三级标题 一级标题 二级标题 三级标题 标题细节 #号和标题内容之间有空格 顺便一提,标题层级x其实转化为html等同于\u003chx\u003e 标题内容 \u003c/hx\u003e，x为数字(😏上述表格内右边内容我其实用的html标签，表格内的#号形式没法渲染) ","date":"2022-01-11","objectID":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/:2:0","tags":["markdown","工具"],"title":"Markdown语法总结","uri":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/"},{"categories":["脚本"],"content":"字体强调 字体加粗：加粗的内容使用前后2个连续的星号* 包围起来,例如： 输入内容 渲染效果 这是**加粗**的内容 这是加粗的内容 ⚠️ 如果加粗的内容有*,#,-,这一类markdown语法有关的字符，可以用英式反斜杠\\加在前面转义(实际上想让任何markdown的某个标记符号失效，都可以用反斜杠\\转义从而escape); 某些Markdown编译器对*号解析有点问题，如果渲染效果未生效，外侧的*号前后加空格即可,和未加粗的内容分隔开👉假如\"前文**加粗内容**后文\"不生效，修改成\"前文 **加粗内容** 后文\"即可。 字体斜体：斜体的内容使用前后1个星号*包围或者前后1个下划线_包围起来,例如： 输入内容 渲染效果 这是*斜体*的内容 这是斜体 的内容 这也是 _斜体_ 的内容 这也是 斜体 的内容 代码字体：行内代码的内容使用前后1个英式反引号包围起来(反引号`在键盘左上角,数字1左边)，一般来说，代码语法渲染后有轻度高亮的效果，例如: 输入内容 渲染效果 这是`代码`的内容 这是代码的内容 字体删除线：对删除线的内容前后2个连续的英式波浪号 ~包围起来，例如： 输入内容 渲染效果 ~~这是删除线的内容~~ 这是删除线的内容 字体的组合:以上的效果可以组合起来使用： 输入内容 渲染效果 ***加粗和斜体*** 加粗和斜体 ~~**删除线和加粗~~** 删除线和加粗 ~~*删除线和斜体*~~ 删除线和斜体 ~~***加粗, 斜体和删除线***~~ 加粗, 斜体和删除线 **`加粗和高亮`** 加粗和高亮 ","date":"2022-01-11","objectID":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/:3:0","tags":["markdown","工具"],"title":"Markdown语法总结","uri":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/"},{"categories":["脚本"],"content":"列表 列表分为无序列表和有序列表：无序列表用英式符号短横-、加号+、或星号* 后接空格来表示；有序列表使用数字加点接空格(例如\"1. “)来表示。 输入内容 渲染效果 - 短横无序列表 - 短横无序列表 短横无序列表 短横无序列表 + 加号无序列表 + 加号无序列表 加号无序列表 加号无序列表 * 星号无序列表 * 星号无序列表 星号无序列表 星号无序列表 1. 数字有序列表 2. 数字有序列表 数字有序列表 数字有序列表 提示： 列表一般会自动缩进，而且写完一条列表内容后，按下Enter换行，markdown会自动新建下一个列表 列表可以嵌套使用 ","date":"2022-01-11","objectID":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/:4:0","tags":["markdown","工具"],"title":"Markdown语法总结","uri":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/"},{"categories":["脚本"],"content":"引用 使用英式大于号 \u003e 来标识一段引用内容，支持多行引用，也支持引用内列表。引用很有用，渲染效果一般是一段加了浅色阴影的文本，可以用于文首/文末的声明，参考链接等内容，有时可以用来做注意事项的声明。 输入内容： \u003e 注意：这是引用内容 \u003e - 引用细节1 \u003e - 引用细节2 渲染效果： 注意：这是引用内容 引用细节1 引用细节2 ","date":"2022-01-11","objectID":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/:5:0","tags":["markdown","工具"],"title":"Markdown语法总结","uri":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/"},{"categories":["脚本"],"content":"插入图片 markdown使用 ![图片描述](图片链接) 的形式来展示一张图片。 这个链接可以是本地链接，也可以是网络链接。 如果是只在本地看，可以使用本地链接，分为本地全路径和本地相对路径： 本地全路径：有一张图在D:\\Cat.png,那么可以在markdown中引入图片![小猫](D:\\Cat.png) ; 本地相对路径：本md文档同目录有个Pic目录，里面有张Cat.png,那么可以在markdown中引入图片![小猫](./Pic/Cat.png) ; 如果是需要发布到网络博客，那么就需要使用图片的网络链接了 想引用网页的某张图，鼠标右键复制图片链接地址, 就是我们需要的图片链接了。举例，去 菜鸟教程C++ 的主页，主页Logo复制到链接后，输入如下内容插入图片： ![C++ programming](https://www.runoob.com/wp-content/uploads/2015/01/cpp-mini-logo.png) 渲染后，图片则自动显示如下： 那么，如果我们自己的制作的图片想要上传到网络呢？ 最常见的是写博客和云笔记，除了某些云笔记软件自带图床，更通常的做法是自己备份在Gitee或Github，更简便的办法是采用 图床 ,推荐个好用的开源工具PicGo，奉上👉 PicGO-Github-Release链接。 图片排版 首先，markdown插入图片都是左对齐的，有时想要图片居中，只能动用html排版了，具体用法如下(图片显示尺寸width字段可以省略不写 )： 输入内容: \u003cdiv align =center\u003e \u003cimg src=\"https://www.runoob.com/wp-content/uploads/2015/01/cpp-mini-logo.png\" width = \"120\"/\u003e \u003c/div\u003e 渲染效果： ","date":"2022-01-11","objectID":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/:6:0","tags":["markdown","工具"],"title":"Markdown语法总结","uri":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/"},{"categories":["脚本"],"content":"插入URL超链接 markdown 使用 [超链接描述](链接地址) ，适用场景：比如想给出某链接的地址，浏览者鼠标点击即可浏览器跳转。 比如输入内容： [访问一个高Star的免费中文书籍仓库](https://github.com/justjavac/free-programming-books-zh_CN) 渲染效果： 访问一个高Star的免费中文书籍仓库 ","date":"2022-01-11","objectID":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/:7:0","tags":["markdown","工具"],"title":"Markdown语法总结","uri":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/"},{"categories":["脚本"],"content":"水平分隔线 在一个大段落之后，想和后续内容在视觉上有分隔效果，这时候就需要用到水平分隔线了。markdown中的水平分隔线使用方法：单行使用3个及以上的星号*(***),或短横线-(—),或下划线_(___)，且上下为空行，和正文分开。 输入内容(只演示*号，另外2种一样的): 段落1 ***** 段落2 渲染效果: 段落1 段落2 扩展语法 在基础语法发布后，人们发现不够用，于是有了扩展语法。扩展语法的特性包括表格、代码段控制、脚注、标题ID(Heading ID,我更愿称之为标题锚点)、任务列表、Emoji表情、高亮语法等语法。 因为markdown是兼容html的，所以某些扩展语法需要借助html的各类标签。 提示 扩展语法不是所有Markdown编辑器都全盘支持，具体情况以该编辑器的支持情况为准； 代码段和表格基本都支持，其他的特性就很依赖编辑器的具体实现了； ","date":"2022-01-11","objectID":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/:8:0","tags":["markdown","工具"],"title":"Markdown语法总结","uri":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/"},{"categories":["脚本"],"content":"表格 表格基本用法 表格使用英式竖向分隔线|和短横-来构建，举例如下： 输入内容(第一行表头,第二行表格分割线,第3~n行都是主体内容)： |设备|iPhone11| macBookPro| 小米10|华为mate40Pro| |---| ---|---|---|---| |系统|iOS | macOS|Android|Android/Harmony| |供应商|Apple|Apple|小米|华为 | 渲染效果如下： 设备 iPhone11 macBookPro 小米10 华为mate40Pro 系统 iOS macOS Android Android/Harmony 供应商 Apple Apple 小米 华为 提示💡 : 表格内如果想显示竖线分隔符|，需要使用\\转义。 表格对齐 表格内容是可以做对齐的，只要将上述第二行的三条短横线改成 “:–\"(左对齐)、\"–:\"(右对齐)、\":-:\"(居中对齐)，每列都能单独控制对齐方式。 单元格内多行 表格内多行需要借助html，比如某行内容太长或者想分行叙述两三项内容，就可以用换行符 \u003cbr\u003e 实现单元格内换行。 表格单元格合并 markdown表格没有相关的语法，但是可以借助html标签，只要使用的编辑器支持html标签就可以渲染出来。 需要用到的标签： colspan：规定单元格可纵深的列数 rowspan：规定单元格可横跨的行数 \u003ctable\u003e的基本规则: 整体表格描述用\u003ctable\u003e和\u003c/table\u003e包裹起来； “绘制表格”的顺序从左到右，类似扫描，一行(几行)的描述，然后再从上到下； 每一行表格使用\u003ctr\u003e和\u003c/tr\u003e包裹起来； 每个单元格的实际文本内容使用\u003ctd\u003e和\u003c/td\u003e包裹起来，行列伸展的rowspan/colspan在td内声明； 单元格可以设置对齐方式，在\u003ctd\u003e范围内使用align=“left”(或right,center,justify,char)； 例如，如下描绘了“表格列合并”： 输入内容: \u003ctable\u003e \u003ctr\u003e \u003ctd\u003e东方\u003c/td\u003e \u003ctd align = \"right\"\u003e西门\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd colspan=\"2\" align = \"center\"\u003e姓氏\u003c/td\u003e \u003c/tr\u003e \u003c/table\u003e 渲染效果： 东方 西门 姓氏 如下描绘了稍微复杂的“表格行合并”： 输入内容如下(Code可展开): \u003ctable\u003e \u003ctr\u003e \u003ctd align=\"center\"\u003e类别\u003c/td\u003e \u003ctd\u003e名称\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd rowspan=\"2\" align=\"center\"\u003e颜色\u003c/td\u003e \u003ctd\u003e红色\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e黄色\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e距离\u003c/td\u003e \u003ctd rowspan=\"2\"\u003e物理单位\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e时间\u003c/td\u003e \u003c/tr\u003e \u003c/table\u003e 渲染效果： 类别 名称 颜色 红色 黄色 距离 物理单位 时间 ","date":"2022-01-11","objectID":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/:9:0","tags":["markdown","工具"],"title":"Markdown语法总结","uri":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/"},{"categories":["脚本"],"content":"代码段 代码段的高亮使用3个连续的反引号 ` 来标识代码段，并后接语言类型(针对语法高亮)，结尾处用3个反引号包围代码段。如果不接语言类型，也是可以的，不做任何语法的高亮。如下是C++的代码例子： 输入以下内容 ```c++ #include \u003ciostream\u003e int main(){ std::cout \u003c\u003c \"hello world!\\n\"; return 0; } ``` 渲染效果： #include \u003ciostream\u003e int main(){ std::cout \u003c\u003c \"hello world!\\n\"; return 0; } 提示 如果想要引述的代码块本身包含了3个连续的反引号```，那么就用连续的4个反引号````把它包围起来(上方C++的原文内容输入就是这么做的)。 markdown支持的代码段语言非常丰富 ，包括了几乎所有主流编程语言，参照比较通用的Github风格(GFM,Github Flavored Markdown)所支持的语法高亮，语言类型支持列表(参考Languages Supported by Github Flavored Markdown)如下列表(Code可展开)： actionscript3 apache applescript asp brainfuck c cfm clojure cmake coffee-script, coffeescript, coffee cpp cs csharp css csv bash diff elixir erb - HTML + Embedded Ruby go haml http java javascript json jsx less lolcode make - Makefile markdown matlab nginx objectivec pascal PHP Perl python profile - python profiler output rust salt, saltstate - Salt shell, sh, zsh, bash - Shell scripting scss sql svg swift rb, jruby, ruby - Ruby smalltalk vim, viml - Vim Script volt vhdl vue xml - XML and also used for HTML with inline CSS and Javascript yaml ","date":"2022-01-11","objectID":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/:10:0","tags":["markdown","工具"],"title":"Markdown语法总结","uri":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/"},{"categories":["脚本"],"content":"目录树 markdown可以自动生成目录，一般在文档的开头位置，单独一行输入[TOC]，如果编辑器支持，是可以自动生成目录树的，支持点击跳转。 ","date":"2022-01-11","objectID":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/:11:0","tags":["markdown","工具"],"title":"Markdown语法总结","uri":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/"},{"categories":["脚本"],"content":"任务列表 任务列表特别适合记录TODO-List，复盘每天/每周的工作哪些做了，哪些没做。具体语法为“短横+空格+中括号[ ]”中括号内为空格表示不勾选，写入字母x则表示选中☑️,如下: 输入内容: - [x] 基础功能Api完成 - [x] 各项功能单元测试 - [x] 测试部提测 - [ ] 提测反馈修复与迭代 - [ ] 正式发版 渲染效果: 基础功能Api完成 各项功能单元测试 测试部提测 提测反馈修复与迭代 正式发版 ","date":"2022-01-11","objectID":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/:12:0","tags":["markdown","工具"],"title":"Markdown语法总结","uri":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/"},{"categories":["脚本"],"content":"标题ID 标题ID(heading IDs)这个功能其实是用来给某级标题做个自定义的id标记，方便阅读者在另外一个位置通过这个指定的id跳转的。举例，本文的扩展语法下的代码段那一节的标题给他添加Heading-id，id标记名为\"code-block”，则那一行的标题后要追加该id，写作： ## 代码段 {#code-block} “代码段”这个标题渲染后看起来没什么不同。但是，我在本节，这个位置新增[转到代码段](#code-block),显示效果像链接，点这个跳转👉 转到代码段。就成功的跳转到了那一节的标题处。 其他用法：还可以用于给出远端链接时，那篇文章本身带有Heading-id，这样访问链接时直接跳转到指定的章节，而不是从头读起。 给出带有标题Id的链接格式为: [链接描述](链接地址/#heading-id名)，举例如下： [markdown-guide的heading-id章节](https://www.markdownguide.org/extended-syntax/#linking-to-heading-ids) 渲染效果(点击后可根据heading-id直接跳转到指定章节)： markdown-guide的heading-id章节 ","date":"2022-01-11","objectID":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/:13:0","tags":["markdown","工具"],"title":"Markdown语法总结","uri":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/"},{"categories":["脚本"],"content":"高亮背景色 这个功能用的相对比较少，但是如果使用的markdown编辑器支持html的，渲染效果也不错。 用法： 使用\u003cmark\u003e高亮背景内容\u003c/mark\u003e来实现突出重要内容，渲染效果： 高亮背景内容 ","date":"2022-01-11","objectID":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/:14:0","tags":["markdown","工具"],"title":"Markdown语法总结","uri":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/"},{"categories":["脚本"],"content":"上标下标 同样地，使用html标签语法来实现该功能： 上标用法：使用\u003csup\u003e上标内容\u003c/sup\u003e来实现上标效果，比如输入 国际认证商标\u003csup\u003eTM\u003c/sup\u003e，渲染效果：国际认证商标TM 下标用法：使用\u003csub\u003e下标内容\u003c/sub\u003e来实现下标效果，比如输入 水的分子式为H\u003csub\u003e2\u003c/sub\u003eO，渲染效果：水的分子式为H2O 提示：如果是要写数学公式，单就这2个是完全不够的，直接在Markdown编辑里找到math公式支持的设置，打开即可(或者是安装其对应的数学插件)，较为通用的有 mathJax , Katex 等。 ","date":"2022-01-11","objectID":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/:15:0","tags":["markdown","工具"],"title":"Markdown语法总结","uri":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/"},{"categories":["脚本"],"content":"Emoji表情 某些编辑器是支持使用Emoji表情的，具体用法：使用2个英式冒号包围表情短码,短码(short-code，可以理解为代号)的。举例如下： 输入内容 渲染效果 :roll_eyes: 🙄 :rofl: 🤣 :man_shrugging: 🤷‍♂️ :thinking: 🤔 :snail: 🐌 :house_with_garden: 🏡 :cn: 🇨🇳 这只是其中的几个表情，还有大量的Emoji表情，如官方列举👉：list of emoji short-codes. 参考链接 Markdown Guide - Basic Syntax Markdown Guide - Extended Syntax Markdown官方教程中文版 Toast-lab - Markdown Syntax ","date":"2022-01-11","objectID":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/:16:0","tags":["markdown","工具"],"title":"Markdown语法总结","uri":"/2022/01/10_markdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93/"},{"categories":["计算机图形学"],"content":"摘要：Fundamentals of Computer Graphics第四版，原书第2章Miscellaneous Math的总结","date":"2021-12-27","objectID":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/","tags":["图形学基础","图形渲染"],"title":"Fundamentals of Computer Graphics学习总结_第2章(杂项数学)","uri":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":" 序言：看原书第二章后做的笔记，关键术语留有英文注解, 有些内容补充了自己的理解，并非直接翻译原文。 本人水平有限，若有不当之处，欢迎交流与指正，谢谢。 原书第四版pdf下载链接：Github: t4world/Computer-Graphics Markdown 数学公式语法参考: Cmd Markdown 公式指导手册 1 集合与映射 通常，我们所指的函数是映射(mapping)的一种特殊情况。映射是集合A到集合B的一种对应关系。 笛卡尔积(Cartesian product)$A$x$B$是2个集合的元素的所有可能组合，即a$\\epsilon$A, b$\\epsilon$B,对所有可能的有序组合(a,b)。$A$ x $A$简写为$A^2$,以下常用符号： 符号 意义 $R$ 实数 $R^+$ 非负实数 $R^2$ 2维实数平面 $R^n$ n维实数笛卡尔空间 $Z$ 整数 $S^2$ 3D单位球面上的点 映射的表示方法 使用冒号和箭头,举例: $f: R \\rightarrow Z$ 其中前者为定义域(domain),后者为值域(target). 从编程语言的角度来看，也可以认为是 参数为$R$，返回值为$Z$。 ","date":"2021-12-27","objectID":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:0:0","tags":["图形学基础","图形渲染"],"title":"Fundamentals of Computer Graphics学习总结_第2章(杂项数学)","uri":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"1.1 逆映射 通常所说的反函数是一种逆映射。 对于一个映射 $f: A \\rightarrow B$,那么可能存在逆映射 $f^{-1} : B \\rightarrow A$. 即 对于 $b = f(a)$,有$f^{-1}(b)=a$. 存在逆映射的条件是： 对每一个b$\\epsilon$B,存在唯一确定的$a\\epsilon A$满足$f(a)=b$. 若在满足逆映射的条件下，此时f是函数，(即 对每一个a$\\epsilon$A,有唯一确定的b=f(a)),此时这种特殊的映射关系称为双射(bijection), $f$和$f^{-1}$互为反函数，值域和定义域对调。 反函数例子: f: R $\\rightarrow$ R,函数f(x)=$x^3$ ,反函数$f^{-1}(x)=\\sqrt[3]x$ ","date":"2021-12-27","objectID":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:1:0","tags":["图形学基础","图形渲染"],"title":"Fundamentals of Computer Graphics学习总结_第2章(杂项数学)","uri":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"1.2 区间 关于是否包含区间边界值，分为开区间和闭区间以及半开区间。 涉及到图形的表示，注意，例如表示一个单位立方体的3D区间，立方体内的点$x$可以表示为$x \\epsilon [0,1]^3$. 区间还有个方便之处，区间运算，并集(union,符号$\\cup$)，交集(intersection,符号$\\cap$)，差集(difference,符号-)等。 ","date":"2021-12-27","objectID":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:2:0","tags":["图形学基础","图形渲染"],"title":"Fundamentals of Computer Graphics学习总结_第2章(杂项数学)","uri":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"1.3 对数 对数是相对于指数关系而生的，针对一个底数a，求它的多少次方为x. 表现形式如下： $$y = \\log_a x \\iff a^y = x $$ 复习几个常用的公式： $a^{\\log_a (x )} = x$ $\\log_a {(a^x)} = x$ $\\log_a (xy) = \\log_a x +\\log_a y$ $\\log_a (x /y) = \\log_a x - \\log_a y$ $\\log_a x = \\log_a b \\cdot \\log_b x$ 有个特殊的底数为$e=2.718…$,用它作底数，那么对数形式则会简写为： $$\\ln x \\equiv \\log_e x$$ 它和指数函数的导数形式分别如下： $\\frac {d}{dx} \\log_a{x}=\\frac{1}{x\\ln a}$ $\\frac {d}{dx} a^{x} =a^x \\ln a$ $\\text{上述公式当a = e 时}, \\ln a = 1.$ 2 求解二次方程 复习一下初中数学知识, 一元二次方程的一般形式： $$Ax^2 + Bx + C = 0,$$ 求根判别式(discriminant)为 $\\Delta = B^2 - 4 \\cdot A \\cdot C$，有三种情况: $\\Delta\u003c0:$ 方程没有根 $\\Delta=0:$ 方程只有一个根, $x_0 =x_1 =\\frac{-B}{2A}$ $\\Delta\u003e0:$ 方程有2个根, $x_0= \\frac{-B+\\sqrt{\\Delta}}{2 \\cdot A} , x_1= \\frac{-B-\\sqrt{\\Delta}}{2 \\cdot A}$ 个人经验：注意, 开方和除法开销昂贵，图形学中为了简化运算，提倡对$x_0,x_1$ ,做简化： $\\text{令 }\\Delta _2 = {(\\frac{B}{2})}^2- A \\cdot C$ , 则 $x_0= \\frac{-(\\frac{B}{2})+\\sqrt{\\Delta _2}}{A} , x_1= \\frac{-(\\frac{B}{2})-\\sqrt{\\Delta _2}}{A}$ 3 三角学 ","date":"2021-12-27","objectID":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:3:0","tags":["图形学基础","图形渲染"],"title":"Fundamentals of Computer Graphics学习总结_第2章(杂项数学)","uri":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"3.1 角度 如下图所示，角度由2条射线(half-line)组成,射线将圆分成了2段弧(arc)，弧线长度即为角度大小,角度有正负之分,逆时针方向为正(counterclockwise)，图中的角度 $\\Phi$ 即为短的那段弧。按照这样的定义，角度值的取值范围为$[-\\pi , \\pi]$ 角度制(degrees)和弧度制(radians)的转换，因为整圆是$360^\\circ$,也是弧度制的$2\\pi$, 所以角度转换如下： $$degrees = \\frac{180}{\\pi} \\cdot radians$$ ","date":"2021-12-27","objectID":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:4:0","tags":["图形学基础","图形渲染"],"title":"Fundamentals of Computer Graphics学习总结_第2章(杂项数学)","uri":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"3.2 三角函数 说起三角函数，先复习勾股定理(也叫毕达哥拉斯定理，$Pythagorean-theorem$),如下图所示，简单的证明了斜边(hypotenuse)平方为2条直角边的平方和。 $$a^2 + o^2 = h^2,$$ 由此定义了正弦(sine),反正弦(arc sine),余弦(cosine),反余弦(arc cosine),正切(tangent),反正切(arc tangent). 函数 $\\sin \\Phi $ $\\csc \\Phi $ $\\cos \\Phi $ $\\sec \\Phi $ $\\tan \\Phi $ $\\cot \\Phi $ 值 $ o/ h$ $ h/ o$ $ a/h$ $ h/a$ $ o/a$ $ a/o$ 涉及到图形学中的方位角(直角坐标和极坐标的映射)，有个实用的函数$atan2$,它比$atan$的数值更稳定,且值域更广，对于一个笛卡尔(Cartesian)直角坐标$(x,y)$如下所示： $$ atan2(y,x)= \\begin{cases} arctan(\\frac {y}{x}), \u0026 \\text { x \u003e 0} \\\\ arctan(\\frac {y}{x}) + \\pi, \u0026 \\text{ $y \\geq 0$,x\u003c0} \\\\ arctan(\\frac {y}{x}) - \\pi, \u0026 \\text{ y \u003c 0,x\u003c0} \\\\ +\\frac{ \\pi}{2}, \u0026 \\text{ y \u003e 0,x=0} \\\\ -\\frac{ \\pi}{2}, \u0026 \\text{ y \u003c 0,x=0} \\\\ undefined, \u0026 \\text{ y = 0,x=0} \\end{cases} $$ 以上的函数定义域和值域如下： $asin : [-1,1] \\mapsto[- \\pi / 2, \\pi /2];$ $acos: [-1,1] \\mapsto[0,\\pi];$ $atan:R \\mapsto[-\\pi/2,\\pi/2];$ $atan2: R^2 \\mapsto [-\\pi, \\pi]$ ","date":"2021-12-27","objectID":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:5:0","tags":["图形学基础","图形渲染"],"title":"Fundamentals of Computer Graphics学习总结_第2章(杂项数学)","uri":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"3.3 一些有用的特性 角度平移特性(高中数学老师说过,\"奇变偶不变，符号看象限\") $\\sin(-A) = - \\sin A$ $\\cos(-A) = \\cos A$ $\\tan(-A) = - \\tan A$ $\\sin(\\frac {\\pi} {2} - A) =\\cos A$ $\\cos(\\frac {\\pi} {2} -A) = \\sin A$ $\\tan(\\frac {\\pi} {2} -A) = \\cot A$ 勾股定理推导特性 ${\\sin}^2 A +{\\cos}^2 A=1$ ${\\sec}^2 A -{\\tan}^2 A=1$ ${\\csc}^2 A -{\\cot}^2 A=1$ 加减特性 $\\sin(A +B )=\\sin A \\cos B + \\sin B \\cos A$ $\\sin(A -B )=\\sin A \\cos B - \\sin B \\cos A$ $\\cos(A +B )=\\cos A \\cos B - \\sin A \\sin B$ $\\cos(A -B )=\\cos A \\cos B + \\sin A \\sin B$ $\\tan (A+B) =\\frac{\\tan A + \\tan B}{1- \\tan A \\tan B}$ $\\tan (A-B) =\\frac{\\tan A - \\tan B}{1+ \\tan A \\tan B}$ $\\sin (2A) = 2 \\sin A \\cos A$ $\\cos (2A) = \\cos ^2 A -\\sin ^2 A$ $\\tan (2A) =\\frac {2 \\tan A}{1 -\\tan ^2 A}$ 半角特性 $\\sin ^2 (\\frac{A}{2})=(1- \\cos A)/2$ $\\cos ^2 (\\frac{A}{2}) =(1+\\cos A)/2$ 积化和差 $\\sin A \\sin B = -\\frac {\\cos (A+B) -\\cos (A-B)}{2}$ $\\sin A \\cos B = \\frac {\\sin (A+B) +\\sin (A-B)}{2}$ $\\cos A \\cos B = \\frac {\\cos (A+B)+\\cos (A-B)}{2}$ 三角形特性 对于任意三角形，假设边长为$a,b,c$,三条边的对角分别为$A,B,C$，那么有以下等式： $$\\frac{\\sin A}{a} =\\frac{\\sin B}{b} =\\frac{\\sin C}{c} \\text{ (正弦定理)}$$ $$c^2 = a^2 + b^2 - 2 \\cdot a \\cdot b \\cdot \\cos C \\text{ (余弦定理)}$$ $$\\frac{a+b}{a-b} = \\frac{\\tan(\\frac{A+B}{2})}{\\tan(\\frac{A-B}{2})} \\text{ (正切定理)}$$ $$S_ \\Delta = \\frac {1}{4} \\sqrt {(a+b+c)(-a+b+c)(a-b+c)(a-b+c)(a+b-c)} \\text{ (海伦－秦九韶面积公式)}$$ $$\\text{或者，令} p = \\frac{a+b+c}{2} , S_ \\Delta = \\sqrt {p(p-a)(p-b)(p-c)}$$ 4 向量 向量，也称为矢量，通常表示为一段特定长度和特定方向的箭头$\\rightarrow$。通常，不会用来表示坐标或位置，而是偏移(offset)或者位移(displacement). ","date":"2021-12-27","objectID":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:6:0","tags":["图形学基础","图形渲染"],"title":"Fundamentals of Computer Graphics学习总结_第2章(杂项数学)","uri":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"4.1 向量运算 向量加减运算符合平行四边形原则(parallelogram rule),向量加减满足交换律(commutative property),即 $\\vec {a} + \\vec {b} = \\vec {b} + \\vec {a}$ . 向量乘法有多种形式，其中，如果$\\vec {a}$与数字$k$相乘，$k$为正数则方向不变，$k$为负数则方向相反，长度则乘以$k$的绝对值.例如 $3.5 \\vec{a}$,表示方向不变，长度变为原来的3.5倍. ","date":"2021-12-27","objectID":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:7:0","tags":["图形学基础","图形渲染"],"title":"Fundamentals of Computer Graphics学习总结_第2章(杂项数学)","uri":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"4.2 直角坐标下的向量 对于一个二维向量$\\vec {c}$，可以由任意2个不平行的基础向量组合而成： $$\\vec {c} = w_a \\vec{a} + w_b \\vec{b} ,\\text{($w_a$,$w_b$是唯一一组常数解)}$$ 那么，如果让这2个基础向量为直角坐标系的横轴$x$和纵轴$y$两个方向上的单位向量,则向量$\\vec{a}$表示为： $$\\vec a =x_a \\vec{x} + y_a \\vec{y}$$ 通常为了方便，也会直接用直角坐标$(x_a,y_a)$表示这个向量，或者使用一个列矩阵，$\\vec a =\\begin{bmatrix} x_a \\\\ y_a \\end{bmatrix}$, 为了书写和印刷方便，也会直接写为它的转置形式 ${\\vec a} ^ T=\\begin{bmatrix} x_a \u0026 y_a \\end{bmatrix}$ . ","date":"2021-12-27","objectID":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:8:0","tags":["图形学基础","图形渲染"],"title":"Fundamentals of Computer Graphics学习总结_第2章(杂项数学)","uri":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"4.3 点乘 向量点乘得到的为标量积,向量$\\vec{a}$和$\\vec{b}$的点乘为两个向量的长度相乘，再乘以夹角$\\Phi$的余弦值。表示为： $$\\vec{a} \\cdot \\vec{b} =\\lVert a \\rVert \\cdot \\lVert b \\rVert \\cdot \\cos \\Phi$$ 常用：用于计算2个向量的夹角余弦值，进而推算夹角大小。 向量点乘遵守结合律(associative property)和分配律(distributive property): $$\\vec {a} \\cdot \\vec {b} =\\vec{b} \\cdot \\vec{a}$$ $$\\vec {a} \\cdot (\\vec {b} + \\vec {c})=\\vec {a} \\cdot \\vec {b} +\\vec {a} \\cdot \\vec {c}$$ $$(k \\vec{a})\\cdot \\vec{b}=\\vec{a}\\cdot (k\\vec{b})=k\\vec{a}\\cdot \\vec{b}$$ 在直角坐标系下，假设有二维向量$\\vec{a}=(x_a,y_a)$和$\\vec{b}=(x_b,y_b)$，那么两者点乘结果为 $\\vec {a} \\cdot \\vec {b}=x_a x_b + y_a y_b$ . 类似地，如果是三维向量，那么: $\\vec {a} \\cdot \\vec {b}=x_a x_b + y_a y_b +z_a z_b$ ","date":"2021-12-27","objectID":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:9:0","tags":["图形学基础","图形渲染"],"title":"Fundamentals of Computer Graphics学习总结_第2章(杂项数学)","uri":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"4.4 叉乘 向量叉乘得到的为向量积，通常用于三维向量。 $\\vec{a} ,\\vec{b}$叉乘向量积的模长为这两个向量的模长相乘，再乘以夹角的正弦值,数值正好等于$\\vec{a} ,\\vec{b}$围成的平行四边形面积。 $$\\lVert \\vec{a} \\times \\vec{b} \\rVert=\\lVert \\vec{a} \\rVert \\lVert \\vec{b} \\rVert \\sin \\Phi ,\\text{(且方向同时垂直于$\\vec{a} ,\\vec{b}$)}$$ 下图为一个右手坐标系 定义$x,y,z$三轴的单位向量分别为： $$\\vec{x} =(1,0,0)$$ $$\\vec{y} =(0,1,0)$$ $$\\vec{z} =(0,0,1)$$ 那么$\\vec{x} \\times \\vec{y}$叉乘结果可以为人为规定为$+\\vec{z}$或$-\\vec{z}$,这里我们采用$+\\vec{z}$，则有： $$\\vec{x} \\times \\vec{y}=+\\vec{z}$$ $$\\vec{y} \\times \\vec{x}=-\\vec{z}$$ $$\\vec{y} \\times \\vec{z}=+\\vec{x}$$ $$\\vec{z} \\times \\vec{y}=-\\vec{x}$$ $$\\vec{z} \\times \\vec{x}=+\\vec{y}$$ $$\\vec{x} \\times \\vec{z}=-\\vec{y}$$ 对右手坐标系的解释：对于$\\vec {a} \\times \\vec{b}$,右手手掌与$\\vec{a}$平行，且四指向$\\vec{b}$弯曲，此时大拇指所指方向就是叉乘结果$\\vec {a} \\times \\vec{b}$的方向。 注意：常用的$x-y-z$直角坐标系为右手坐标系，即$\\vec{x} \\times \\vec{y}=+\\vec{z}$。 叉乘运算满足分配律，结合律(与常数)，但不满足交换律： $$\\vec{a} \\times (\\vec{b} + \\vec{c} ) = \\vec{a} \\times \\vec{b} + \\vec{a} \\times \\vec{c}$$ $$\\vec{a} \\times (k\\vec{b})=k(\\vec{a} \\times \\vec{b}) , \\text{ (常数可以提取出来)}$$ $$\\vec{a} \\times \\vec{b} = -(\\vec{b} \\times \\vec{a}), \\text{ (一交换则反向)}$$ 现在有向量$\\vec{a}=(x_a,y_a,z_a)$,或者表示为$\\vec{a}=x_a \\vec{x} + y_a \\vec{y} + z_a \\vec{z}$, 另一个向量 $\\vec{b} =(x_b, y_b, z_b)$, 那么： $$\\vec{a} \\times \\vec{b} =(x_a \\vec{x} + y_a \\vec{y} + z_a \\vec{z}) \\times( x_b \\vec{x} + y_b \\vec{y} + z_b \\vec{z})$$ $$=(y_a z_b - z_a y_b)\\vec{x} + (z_a x_b -x_a z_b)\\vec{y} +(x_a y_b - y_a x_b)\\vec{z}$$ 最终结果也可写作 $\\vec{a} \\times \\vec{b} =(y_a z_b - z_a y_b, z_a x_b -x_a z_b , x_a y_b - y_a x_b )$ . ","date":"2021-12-27","objectID":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:10:0","tags":["图形学基础","图形渲染"],"title":"Fundamentals of Computer Graphics学习总结_第2章(杂项数学)","uri":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"4.5 标准正交基与坐标系 标准正交基：在2D平面，有互相垂直的一组向量基 $\\vec{u} ,\\vec{v}$，且都为单位向量，即： $$\\lVert \\vec{u} \\rVert =\\lVert \\vec{v} \\rVert =1, \\text{and, }\\vec{u} \\cdot \\vec{v} =0$$ 如果是3D空间，则这组标准正交基$\\vec{u}, \\vec{v}, \\vec{w}$满足： $\\text{(1)} \\lVert \\vec{u} \\rVert =\\lVert \\vec{v} \\rVert =\\lVert \\vec{w} \\rVert =1$ $\\text{(2)} \\vec{u} \\cdot \\vec{v} =\\vec{v} \\cdot \\vec{w} =\\vec{w} \\cdot \\vec{u} =0$ $\\text{(3)} \\vec{w}=\\vec{u} \\times \\vec{v} \\text{ (右手坐标系)}$ 像这样的正交基 $\\vec{u} ,\\vec{v} , \\vec{w}$有无数组，我们通常默认选用直角坐标轴的单位向量$\\vec{x}, \\vec{y}, \\vec{z}$作为正交基，且原点为$O(0,0,0)$,这样的正则坐标系我们称为世界坐标系(world coordinate system)或全局坐标系(global coordinate system). 有一个物体坐标系$u-v-w$ ,该坐标系中有个向量$\\vec{a}$,如果要转换为在世界坐标系下的坐标,使用简单的点乘 即可得到，为 $u_a\\vec{u} +v_a\\vec{v} +w_a \\vec{w}$. ","date":"2021-12-27","objectID":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:11:0","tags":["图形学基础","图形渲染"],"title":"Fundamentals of Computer Graphics学习总结_第2章(杂项数学)","uri":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"4.6 单个向量构造向量基 设想较为常见的一种情形：给定一个向量$\\vec{a}$,我们希望能给出3个互相垂直的正交基$\\vec{u},\\vec{v},\\vec{w}$，要求$\\vec{w}$和$\\vec{a}$同向,并且不关注$\\vec{u},\\vec{v}$的具体指向。 分为3步： 取$\\vec{a}$的单位向量为$\\vec{w}$ ，即: $\\vec{w} =\\frac{\\vec{a}}{\\lVert \\vec{a} \\rVert}$ 任意取一个与$\\vec{w}$不共线的向量$\\vec{t}$, 两者叉乘后单位化得到$\\vec{u}$，即 : $\\vec{u}=\\frac{\\vec{t} \\times \\vec{w}}{\\lVert \\vec{t} \\times \\vec{w} \\rVert}$ 将上述得到的$\\vec{w} ,\\vec{u}$叉乘得到$\\vec{v}$ ，即: $\\vec{v} =\\vec{w} \\times \\vec{u}$ 书中提到这一场景适用于表面着色，因为法线方向很重要(垂直于表面),着色过程垂直于法线的表面向量无关紧要。 ","date":"2021-12-27","objectID":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:12:0","tags":["图形学基础","图形渲染"],"title":"Fundamentals of Computer Graphics学习总结_第2章(杂项数学)","uri":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"4.7 由两个向量构建向量基 在某些场景需要用2个不共线向量来构建坐标系，比如给定2个互相垂直(perpendicular)的向量$\\vec{a}$(指定$\\vec{w}$) ,$\\vec{b}$(指定$\\vec{v}$),则直接叉乘得到第三个向量基$\\vec{u}=\\vec{b} \\times \\vec{a}.$ 或者，给定的$\\vec{a},\\vec{b}$并不是完全垂直，而是近似垂直,比如成$80^\\circ$角，采用上一节的方法也可以得到最接近的解： $\\vec{w} =\\frac{\\vec{a}}{\\lVert \\vec{a} \\rVert}$, $\\vec{u}=\\frac{\\vec{b} \\times \\vec{w}}{\\lVert \\vec{b} \\times \\vec{w} \\rVert}$, $\\vec{v} =\\vec{w} \\times \\vec{u} \\text{ ,(向量} \\vec{v} \\text{ 很接近} \\vec{b})$ . 获得图形学中相机的Look-At 矩阵/向量也可以采用这一方法，向量$\\overrightarrow {direction}$是确定的$from$点到$to$点的向量，而$up$向量和$right$向量就看自己选择了(可以指定Right向量，再来确定Up向量)，这一点在LearnOpenGL-CN中的Camera章节有相关内容。 ","date":"2021-12-27","objectID":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:13:0","tags":["图形学基础","图形渲染"],"title":"Fundamentals of Computer Graphics学习总结_第2章(杂项数学)","uri":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"4.8 摆正向量基 某些场景下可能遇到这样的问题，由于浮点计算精度或者数据保存读取等原因，造成向量基精度丢失，向量基之间不再那么垂直，如何修正是个问题： 可以这样做：基于已有的$\\vec{w}, \\vec{v}$得到新的$\\vec{u}$,然后再计算$\\vec{u}$. 虽然得到了精确垂直的新向量基，但是，这并非最好的办法，因为新的向量基$\\vec{w}, \\vec{v},\\vec{u}$和原向量基之间，这3者的误差是不对等的, $\\vec{w}$误差最小，$\\vec{u}$误差最大。 在本书的第五章第5.4.1 节的奇异值分解可以很好的解决这一问题。 5 曲线与面 ","date":"2021-12-27","objectID":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:14:0","tags":["图形学基础","图形渲染"],"title":"Fundamentals of Computer Graphics学习总结_第2章(杂项数学)","uri":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"5.1 2D隐式曲线 先理解一下“隐式”:在我看来，隐式曲线就是隐函数来表示的曲线。隐函数，就是没法用$y=f(x)$来干净清晰的表示函数关系，而是转而使用类似方程$f(x,y)=0$的形式(例如开普勒方程$y-x-\\epsilon \\sin y=0$,$\\epsilon$为常熟)。 为人所熟知的隐式曲线必然是圆了，圆方程$f(x,y)=(x-x_c)^2 + (y-y_c)^2 -r^2$描绘了以$(x_c,y_c)$为圆心，$r$为半径的圆. 对任意的点$(x,y)$值，都可以计算出$f(x,y)$的值，则有： 点在圆内：$f(x,y)\u003c0$; 点在圆曲线上：$f(x,y)=0$; 点在圆外：$f(x,y)\u003e0$; 从向量的角度理解，可以认为圆心$c$,圆上的点为$p$, 则向量$\\overrightarrow{cp}$模长正好为圆半径$r$，即:$\\lVert \\overrightarrow{cp} \\rVert =r$。 从向量的角度来表示，比原来$x,y,z$之类的坐标表示更易懂，更能体现几何关系，也更不容易在写代码时犯错，尽可能用向量的形式来表示隐式关系。 ","date":"2021-12-27","objectID":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:15:0","tags":["图形学基础","图形渲染"],"title":"Fundamentals of Computer Graphics学习总结_第2章(杂项数学)","uri":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"5.2 2D梯度 假设函数$f(x,y)$是高度场的函数$height=f(x,y)$,那么梯度向量所指的方向就是指向上坡最陡的方向,或者说函数值增长最快的方向。一般是以偏微分的形式 $\\nabla f(x,y)$ 给出： $$\\nabla f(x,y)=(\\frac {\\partial f} {\\partial x} \\text{ ，} \\frac {\\partial f} {\\partial y} ) .$$ so，偏微分复习：$\\frac {\\partial f} {\\partial x} = lim_{\\Delta x \\to 0} \\frac{f(x+\\Delta x , y) - f(x,y)}{\\Delta x}$ 原文图注解：A surface height = f(x,y) is locally planar near(x,y) = (a,b). The gradient is a projection of the uphill direction onto the height = 0 plane. 如上图，对于二维曲线$f(x,y)=0$的点$p(x,y)$,则此时梯度向量垂直于该点的切向量，梯度向量此时为法线向量。 换句话说，把二维曲线$f(x,y)=0$看作是三维曲面$f(x,y)=h$ 被$xoy$水平面截出的等高线，这样上山的最陡路径投影在平面上，正好就是二维曲线的法向方向. 关于这一点，有位知乎答主做了很好的图文并茂的解释，深入理解可以移步$\\implies$ 知乎: 形象理解“梯度”与“法向量”的关系 另外，因为梯度指向了上坡方向(uphill),所以指向的是$f(x,y)\u003e0$的区域。 那么，为什么梯度和偏微分有关系呢？下图中，假设在很微小的一个区域，$height=f(x,y)$是一块平面，且向量$\\vec{a}$在这个$f$不变的区域移动了一小段距离，即$\\vec{a}=(\\Delta x,\\Delta y)$.因为上坡方向(uphill)垂直于向量$\\vec{a}$,即点积为0： $$(\\nabla f)\\cdot \\vec{a} \\equiv (x_\\nabla,y_\\nabla)\\cdot(x_a,y_a)=x_\\nabla \\Delta x + y_\\nabla \\Delta y=0 \\text{, (式2.5.2-a) }$$ 同样地，我们知道$f$的值没有改变，即$\\Delta f=0$: $$\\Delta f = \\frac {\\partial f} {\\partial x} \\Delta x + \\frac {\\partial f} {\\partial y} \\Delta y= \\frac {\\partial f} {\\partial x} x_a + \\frac {\\partial f} {\\partial y} y_a =0$$ 回顾向量知识，如果$(x,y)$ 和 $(x',y')$垂直，则$xx'+yy'=0$，(x',y')可以取值$(y,-x)$. 那么: $$(x_a,y_a)=k(\\frac{\\partial f}{\\partial y} , - \\frac{\\partial f}{\\partial x}) \\text{, (式2.5.2-b) }$$ 根据式子2.5.2-a和2.5.2-b，可以得出: $$(x_\\nabla, y_\\nabla) = m(\\frac{\\partial f}{\\partial x} , \\frac{\\partial f}{\\partial y}) \\text{, (式2.5.2-c) }$$ 通常取k\u003e0,且m=1. 隐式2D直线(implicit 2D lines) 考虑使用隐函数形式表达一条直线：$Ax+By+C=0$,这种一般形式包含了垂直于$x$轴没有斜率的情况。假设直线上存在两个不同的点$(x_0,y_0), (x_1,y_1)$，则: $$\\begin{cases} Ax_0 + By_0+C =0 \\\\ Ax_1 + By_1+C =0\\\\ \\end{cases}$$ 很明显，这是个不定方程。 梯度为$\\nabla f=(A,B)$, 又因为 $\\nabla f$垂直于$(\\Delta x, \\Delta y)$, 则与 (式2.5.2-c)同理，可以令$\\nabla f=(y_0 -y_1,x_1-x_0)$. 替换A，B，则有： $$(y_0 - y_1)x + (x_1 - x_0)y +C =0 \\text{, (式2.5.2-d)}$$ 对于(式2.5.2-d)，代入$(x_0,y_0)$，则有$C=x_0y_1 - x_1y_0$: $$(y_0 - y_1)x + (x_1 - x_0)y + x_0y_1 - x_1y_0=0$$ 那么写成\"斜率-截距式\"(slope-intercept): $$y =\\frac{y_1 -y_0}{x_1-x_0}x + \\frac{x_1y_0 - x_0y_1}{x_1-x_0}$$ 关于隐式表达式的另外一个有趣的属性是可以用来推算点到直线的有向距离，如下图，平行于直线的$f(x,y)$分布于$\\pm$两侧。 直线之间的距离为梯度的长度，而梯度为k(A,B)，距离则为： $$distance =k \\sqrt{A^2 + B^2}\\text{, (式2.5.2-e)}$$ $Ax + By+C =0$直线上的点$(x_0,y_0)$,则该点的梯度方向有某点$(a,b)=(x_0,y_0)+k(A,B)$,带入计算： $$f(a,b)=f(x_0+kA,y_0+kB)=k(A^2 +B^2)\\text{, (式2.5.2-f)}$$ 综合 (式2.5.2-e), (式2.5.2-f)可知，点$(a,b)$到直线$Ax + By+C =0$的距离： $$distance=\\frac{f(a,b)}{\\sqrt{A^2 + B^2}}$$ 隐式二次曲线(implicit quadric curves) 对于隐式的2D二次曲线，一般形式可以写作如下： $$Ax^2 + Bxy + Cy^2 +Dx + Ey +F =0$$ 该形式包含了椭圆(ellipse)，双曲线(hyperbola)，抛物线(parabola). ","date":"2021-12-27","objectID":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:16:0","tags":["图形学基础","图形渲染"],"title":"Fundamentals of Computer Graphics学习总结_第2章(杂项数学)","uri":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"5.3 3D隐式曲面 和2D隐式曲线类似，3D隐式曲面的表达式记作： $$f(x,y,z)=0.$$ 对曲面上任意点$p(x,y,z)$，有$f(p)=0$. ","date":"2021-12-27","objectID":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:17:0","tags":["图形学基础","图形渲染"],"title":"Fundamentals of Computer Graphics学习总结_第2章(杂项数学)","uri":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"5.4 隐式曲面的表面法线 和2D隐式曲线类似，3D隐式曲面上某点$p(x,y,z)$的法线正好就是该点的梯度: $$\\vec{n}=\\nabla f(p)=(\\frac {\\partial f(p)}{\\partial x}, \\frac {\\partial f(p)}{\\partial y} ,\\frac {\\partial f(p)}{\\partial z})$$ 并且法线$\\vec n$指向的方向为$f(q)\u003e0$的方向(点$q$不在曲面上). 需要注意的是，$f(p)=0$和$-f(p)=0$虽然描述的是同一个曲面，但是法线/梯度方向正好相反：$-\\nabla f(p) =\\nabla(-f(p))$. ","date":"2021-12-27","objectID":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:18:0","tags":["图形学基础","图形渲染"],"title":"Fundamentals of Computer Graphics学习总结_第2章(杂项数学)","uri":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"5.5 隐式平面 平面可以由一个已知的点$a$和已知的法线$\\vec n$来描述 对于平面上任意点$p$： $$(p-a) \\cdot \\vec n=0$$ 平面也可以由3个已知的点$a,b,c$来确定 法线可以通过叉乘得到$\\vec n=(b-a)\\times (c-a)$，对于平面上任意点$p$： $$(p-a)\\cdot ((b-a)\\times (c-a))=0$$ 写成行列式(determinant)则如下： $$\\begin{vmatrix} { x-x_a} \u0026 {y-y_a} \u0026 {z-z_a} \\\\ {x_b-x_a} \u0026 {y_b-y_a} \u0026 {z_b-z_a} \\\\ { x_c-x_a} \u0026 {y_c-y_a} \u0026 {z_c-z_a} \\\\ \\end{vmatrix}=0$$ 3D二次曲面(3D quadric surfaces) 2D曲线可以用二元二次多项式$(x,y)$来表示，类似地，3D曲面可以用三元二次多项式$(x,y,z)$来表示。 对于一个球面： $$f(p)=(p-c)^2-r^2 =0$$ 对于一个椭球面(ellipsoid)： $$f(p)= \\frac{(x-x_c)^2}{a^2} + \\frac{(y-y_c)^2}{b^2} +\\frac{(z-z_c)^2}{c^2} -1=0$$ 由曲面构建曲线(3D curves from implicit surfaces) 如果2个曲面相交，则得到了相交位置的曲线，该曲线的点$p$同时满足： $$ \\begin{cases} f(p)=0 ,\\\\ g(p)=0 .\\\\ \\end{cases}$$ ","date":"2021-12-27","objectID":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:19:0","tags":["图形学基础","图形渲染"],"title":"Fundamentals of Computer Graphics学习总结_第2章(杂项数学)","uri":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"5.6 带参数的2D曲线 带参数的函数：是指自变量$x$和因变量$y$都采用参数$t$表达，点$(x,y)$的位置由$t$来决定，即： $$\\begin{bmatrix} x \\\\ y \\end{bmatrix} =\\begin{bmatrix} g(t) \\\\ h(t) \\end{bmatrix}.$$ 当$t$在连续的改变时，连续函数$g(t),h(t)$也在改变,即点$p(x,y)$在曲线上\"移动\"了,$t$可以看作是时间，不同$t$区间的(x,y)变化幅度不同，点移动时就会有\"速度\"的概念。 带参数函数只看变量$t$的这一特性，给相关的程序编写也带来了很大的便利，只有一个函数入参，Cool. 带参数的2D直线(2D parametric lines) 2D直线上有2个已知的点$p_0(x_0,y_0),p_1(x_1,y_1)$,那么该直线可表示为： $$\\begin{bmatrix} x \\\\ y \\end{bmatrix} =\\begin{bmatrix} x_0+t(x_1-x_0) \\\\ y_0+t(y_1-y_0) \\end{bmatrix}.$$ 或者采用向量的概念：$p(t)=p_0+t(p_1-p_0)$ 如上图，从几何角度理解为“从p0出发前往p1,具体位置由参数t决定”,且$p(0)=p_0,p(1)=p_1$。所以基于这一点，直线可以表示为从一个定点$origin$出发,移动$t$个单位向量$\\vec u$，即： $$p(t)=origin + t \\cdot \\vec u$$ 而这种表示方法，在光线追踪计算时是表示一条光线的绝佳形式。 带参数的2D圆(2D parametric circles) 一个以$(x_c,y_c)$为圆心,$r$为半径的圆，带参数形式可以写作： $$\\begin{bmatrix} x \\\\ y \\end{bmatrix} =\\begin{bmatrix} x_c+ r \\cos \\Phi \\\\ y_c+ r \\sin \\Phi \\end{bmatrix}. \\text{ (其中$\\Phi \\in [0,2 \\pi)$)}$$ 而一个以$(x_c,y_c)$为椭圆中心,$a,b$为长轴、短轴的椭圆，带参数形式可以写作： $$\\begin{bmatrix} x \\\\ y \\end{bmatrix} =\\begin{bmatrix} x_c+ a \\cos \\Phi \\\\ y_c+ b \\sin \\Phi \\end{bmatrix}. \\text{ (其中$\\Phi \\in [0,2 \\pi)$)}$$ ","date":"2021-12-27","objectID":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:20:0","tags":["图形学基础","图形渲染"],"title":"Fundamentals of Computer Graphics学习总结_第2章(杂项数学)","uri":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"5.7 带参数的3D曲线 带参数的3D曲线形式如下： $$\\begin{cases} x=f(t) \\\\ y=g(t) \\\\ z=h(t) \\\\ \\end{cases}$$ 例如，绕$z$轴的螺旋线如下： $$\\begin{cases} x= \\cos t \\\\ y= \\sin t \\\\ z= t \\\\ \\end{cases}$$ 本章只阐述3D直线，不详细阐述3D曲线，而是在本书的第15章(Chapter15.Curves)详细阐述。 带参数的3D直线(3D parametric lines) 带参数的3D直线可以记作向量的形式，举例如下： $$\\begin{cases} x= 2+7t \\\\ y= 1+2 t \\\\ z= 3-5t\\\\ \\end{cases} \\quad \\text{向量形式$\\implies$} \\begin{cases} origin=(2,1,3)\\\\ \\overrightarrow {dircetion}= (7,2,-5) \\\\ position = origin + t \\cdot \\overrightarrow {dircetion} \\\\ \\end{cases}$$ ","date":"2021-12-27","objectID":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:21:0","tags":["图形学基础","图形渲染"],"title":"Fundamentals of Computer Graphics学习总结_第2章(杂项数学)","uri":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"5.8 带参数的3D曲面 不同于2D曲面，只有一个参数$t$,3D曲面需要2个参数$u,v$，$x,y,z$都可以表示为$(u,v)$有关的带参数形式： $$\\begin{cases} x= f(u,v) \\\\ z= h(u,v) \\\\ \\end{cases} \\quad \\text{向量形式$\\implies$} \\begin{bmatrix} x \\\\ y \\\\ z \\end{bmatrix}=p(u,v)$$ 举例：对于一个球面，给定的已知半径$r$，由经度角$\\phi$，纬度角$\\theta$这2个角度变化确认球面任意点： $$\\begin{cases} x= r \\cos \\phi \\sin \\theta \\\\ y= r \\sin \\phi \\sin \\theta \\\\ z= r \\cos \\theta \\\\ \\end{cases} \\quad \\text {可以反推} \\begin{cases} \\theta= arccos(z / \\sqrt{x^2 + y^2 +z^2}) \\\\ \\phi = atan2(y,x) \\\\ \\end{cases}$$ 考虑一下曲面的法线呢？ 首先定义函数$q(t)=p(t,v_0)$，此函数u自由变化且v值固定为$v_0$,这就定义了在曲面上的一条曲线，也叫“等参曲线”。(下图采用自AutoDesk工具ALIAS介绍，意义相近) 则q的导数$q'$和曲面相切，$q'$为P的偏微分$P_u$，同样地，还可以得到第二条切线$P_v$，那么该点的法线$\\vec n$指向曲面外，且同时垂直于这2条曲面切线： $$\\vec n = \\overrightarrow P_u \\times \\overrightarrow P_v$$ 6 线性插值 线性插值可能是图形学中最为常见的思想和计算操作了，回顾我们之前的带参数的2D直线，$p(t)=p_0+t(p_1-p_0)$，即$p(t)=(1-t)\\cdot p_0+t \\cdot p_1$,其实可以认为是在点$p_0,p_1$之间线性插值，权重为$t$. 更通用的一种情形，有$n+1$个散点，对应的$x$坐标$x_0,x_1 … x_{n-1},x_n$,对应的y值为$y_0,y_1 … y_{n-1},y_n$,此时想得到一条连续的函数$f(x)$,就可以通过在相邻的散点插值得到： $$f(x)=y_i+\\frac{x-x_i}{x_{i+1}-x_i}(y_{i+1}-y_i) \\text {,(此时的$t=\\frac{x-x_i}{x_{i+1}-x_i}$)}$$ 7 三角形 无论是2D三角形还是3D三角形，都是各种图形学程序中的基础模型图元(modeling primitive)。比如三角形的Color图元，只有3个顶点(Vertex)有Color值，三角形内的其他值则通过插值方法得到，通常直接采用重心坐标插值(barycentric coordinates)。 本节将分别讨论2D和3D三角形。 ","date":"2021-12-27","objectID":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:22:0","tags":["图形学基础","图形渲染"],"title":"Fundamentals of Computer Graphics学习总结_第2章(杂项数学)","uri":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"7.1 2D三角形 对于一个2D三角形，三个顶点为$a,b,c$，则可以立马通过向量叉乘($S=\\frac {1}{2} \\vec{ab} \\times \\vec{ac}$)得到它的面积： $$S = \\frac {1}{2} \\left | \\begin{array}{ccc} x_b-x_a \u0026 x_c-x_a\\\\ y_b-y_a \u0026 y_c-y_a \\\\ \\end{array} \\right |= \\frac {1}{2}(x_a y_b+x_b y_c+x_c y_c-x_a y_c-x_b y_a-x_c y_b)$$ (该公式的推导可以参考本书章节$Chapter5.Linear Algebra-5.3$.注意,考虑到叉乘的方向性，$a,b,c$三个点要成逆时针排列，否则得到面积的相反数.) 三角形的坐标插值，基本原理还是来自于平行四边形规则的向量合成，即使2个向量不平行，同样可以作为向量基。 首先，对于三角形所在平面内的任意点$p$,满足： $$p=a+\\beta \\vec{ab} + \\gamma \\vec{ac}=a+\\beta (b-a) + \\gamma (c-a)=(1-\\beta -\\gamma)a+\\beta b+\\gamma c$$ 为方便计算书写，令$\\alpha \\equiv 1-\\beta -\\gamma$,则$p(\\alpha,\\beta,\\gamma)=\\alpha a + \\beta b +\\gamma c.$ 注意，点$p$位于三角形内部的充要条件为: $\\alpha, \\beta,\\gamma \\in (0,1)$. 回顾2.5.2节隐式2D直线的内容，平行于直线$f(x,y)=0$的其他直线的函数值$f(x,y)$大于或小于0，分布于$f(x,y)=0$的两侧。如下图所示，我们规定$f_{ac}(x,y)=0$,且点b所在平行线$f_{ac}(x,y)_{\\beta}=1$. 那么在线段$ab$上的点$(x,y)$，$\\beta$值为： $$\\beta=\\frac{f_{ac}(x,y)}{f_{ac}(x_b,y_b)}$$ 基于隐式2D直线章节的内容，ab直线可表示为： $f_{ab}(x,y)\\equiv (y_a -y_b)x +(x_b-x_a)y + x_a y_b -x_b y_a=0$. 则相对应的$\\gamma$值为： $$\\gamma =\\frac {(y_a -y_b)x +(x_b-x_a)y + x_a y_b -x_b y_a}{(y_a -y_b)x_c +(x_b-x_a)y_c + x_a y_b -x_b y_a}$$ 同理，可计算得到点b对应的$\\beta$值,最后$\\alpha=1-\\beta -\\gamma$. 值得注意的是，$\\alpha,\\beta,\\gamma$值表征的是$f(x,y)的值，隐式地表征$点p到各条边的距离，所以，点p和三个顶点行成的3个小三角形和大三角形的比值其实就是$\\alpha,\\beta,\\gamma$,即如下图所示： ","date":"2021-12-27","objectID":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:23:0","tags":["图形学基础","图形渲染"],"title":"Fundamentals of Computer Graphics学习总结_第2章(杂项数学)","uri":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"7.2 3D三角形 对于上一节得到的2D三角形插值公式完全适用于3D三角形$abc$,同样有： $$p=(1-\\beta -\\gamma)a+\\beta b+\\gamma c$$ 三角形$abc$，三条边对应3个比例$\\alpha,\\beta,\\gamma$,则对于三角形内任意点$p$: $$\\alpha =\\frac{Area_{pbc}}{Area_{abc}}=\\frac{\\lVert (c-b)\\times(p-b) \\rVert} {\\lVert (b-a)\\times(c-a) \\rVert}$$ 令$\\vec n=(b-a)\\times(c-a)$,$\\vec n_a =(c-b)\\times(p-b)$，因为两者平行且同向($\\vec n \\cdot \\vec n_a=||\\vec n|| \\cdot ||\\vec n_a||$),则上式可化简： $$\\alpha =\\frac{\\lVert \\vec n_a \\rVert}{\\lVert \\vec n \\rVert }= \\frac{\\lVert \\vec n_a \\rVert \\cdot \\lVert \\vec n \\rVert }{\\lVert \\vec n \\rVert \\cdot \\lVert \\vec n \\rVert } =\\frac{\\vec n \\cdot \\vec n_a }{ { \\lVert \\vec n \\rVert }^2 }$$ 同理可得$\\beta, \\gamma$的值： $$\\beta =\\frac{\\vec n \\cdot \\vec n_b}{ {\\lVert \\vec n \\rVert }^2}$$ $$\\gamma =\\frac{\\vec n \\cdot \\vec n_c}{ {\\lVert \\vec n \\rVert }^2}$$ 其中，$n_b =(a-c)\\times(p-c)$，$n_c =(b-a)\\times(p-a)$. $$\\text{——————– Chapter2(完结) @2021-12-19 ——————–}$$ ","date":"2021-12-27","objectID":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:24:0","tags":["图形学基础","图形渲染"],"title":"Fundamentals of Computer Graphics学习总结_第2章(杂项数学)","uri":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"摘要：Metal官方文档MetalGuide系列第三部分 -\u003e Metal有关的Shader着色器程序,以及MetalLib库文件的生成与使用","date":"2021-12-26","objectID":"/2021/12/4_metalguide-3-%E7%9D%80%E8%89%B2%E5%99%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%BA%93/","tags":["Metal","图形渲染"],"title":"MetalGuide(3)着色器程序与库","uri":"/2021/12/4_metalguide-3-%E7%9D%80%E8%89%B2%E5%99%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%BA%93/"},{"categories":["计算机图形学"],"content":"1 如何创建Metal库(MTLLibrary) Case A. 从已编译的代码中创建Library 为了提升性能，可以利用xcode工具在app的创建过程中就把Metal-Shader源代码编译打包到一个库文件中，如 此避免了在app的运行时编译着色程序代码的开销。从已编译的二进制库中创建一个MTLLibrary对象，可以使用如下的MTLDevice方法 ： newDefaultLibrary : 会return一个MTLLibrary，包含了渲染shader和app所需的并行计算程序； newLibraryWithFile:error : 它将返回一个MTLLibrary对象，从指定的库文件路径加载这个库文 件中的所有shader程序； newLibraryWithData:error :它将返回一一个MTLLibrary对象，从指定的二进制数据块对象加载数据块中的所有shader程序. Case B. 从源代码中创建Library 从包含有Metal-Shader代码编写的多个着色程序的字符串中创建MTLLibrary对象，这些方法将在MTLLibrary对象创建时编译源代码，具体的可以参考如下 MTLDevice方法 ： newLibraryWithSource:options:error: 属于同步阻塞调用 ,它编译输入字符串里的源代码创建多个 MTLFunction对象，最后返回一个包含这些MTLFunction对象的MTLLibrary对象； newLibraryWithSource:options:completionHandler: 属于异步调用，和上一个方法不同的是多了参数代码block块—completionHandler，block将在MTLLibrary对象创建完成后被调用 . 2 MTLFunction细节探究 ​ 如何从Library中获取Function ，可以用下述方法进行获取： ​ newFunctionWithName: 属于MTLLibrary的方法, 返回一个名字为输入参数的MTLFunction对象。如果在library中没有 找到一个方法其修饰名字匹配输入参数，那么该函数返回nil。 ","date":"2021-12-26","objectID":"/2021/12/4_metalguide-3-%E7%9D%80%E8%89%B2%E5%99%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%BA%93/:0:0","tags":["Metal","图形渲染"],"title":"MetalGuide(3)着色器程序与库","uri":"/2021/12/4_metalguide-3-%E7%9D%80%E8%89%B2%E5%99%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%BA%93/"},{"categories":["计算机图形学"],"content":"2.1 在运行时决定Function的细节 ​ 一个MTLFunction对象被定义为图形shader程序或是并行计算程序，它的实质内容在这个对象被创建前 就编译好了，而且shader程序的源代码不能直接被app使用.不过，可以在运行时查询下面的MTLFunction属性： ","date":"2021-12-26","objectID":"/2021/12/4_metalguide-3-%E7%9D%80%E8%89%B2%E5%99%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%BA%93/:1:0","tags":["Metal","图形渲染"],"title":"MetalGuide(3)着色器程序与库","uri":"/2021/12/4_metalguide-3-%E7%9D%80%E8%89%B2%E5%99%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%BA%93/"},{"categories":["计算机图形学"],"content":"2.2 相关的Reflection对象 ​ MTLFunction不提供访问shader程序参数的方法。但在pipeline state创建过程中，可以获得用于展示shader程序参数细节reflection对象(根据command encoder的类型不同， reflection对象分为MTLRenderPipelineReflection类型或 MTLComputePipelineReflection类型 )。 ​ 一个reflection对象包含了一个MTLArgument数组，视其关联的Encoder不同而不同： MTLRenderPipelineReflection：关联MTLRenderCommandEncoder ,包含的Arguments数组有vertexArguments和fragmentArguments 这2个属性； MTLComputePipelineReflection ：关联MTLComputeCommandEncoder ，包含的Argument数组表征并行计算程序的参数。 ​ 不是所有的shader程序的参数都在reflection对象中表示，一个reflection对象仅包含那些引用了相应资源的参数，通 过shader修饰符[[stage_in]]、 [[vertex_id]]、 [[attribute_id]]修饰的参数不会被包含在reflection对象中。 ","date":"2021-12-26","objectID":"/2021/12/4_metalguide-3-%E7%9D%80%E8%89%B2%E5%99%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%BA%93/:2:0","tags":["Metal","图形渲染"],"title":"MetalGuide(3)着色器程序与库","uri":"/2021/12/4_metalguide-3-%E7%9D%80%E8%89%B2%E5%99%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%BA%93/"},{"categories":["计算机图形学"],"content":"2.3 MTLArgument对象 ​ MTLArgument类型对象表示一个shader程序方法的入参细节： ​ 上述的属性type还决定了哪些其他MTLArgument属性是相关的，type类型不同，相关的属性也有所区别： MTLArgumentTypeTexture : textureType属性表征纹理类型(可能为texture1d_array， texture2d_ms， texturecube); textureDataType 属性表征其分量数据类型(可能为half， float， int， uint）; MTLArgumentTypeThreadgroupMemory : 说明threadgroupMemoryAlignment和 threadgroupMemoryDataSize这两个属性相关； MTLArgumentTypeBuffer : 说明bufferAlignment, bufferDataSize, bufferDataType, bufferStructType这几个属性相关 。 ​ 例如：如果bufferDataType的值是MTLDataTypeStruct ，那么bufferStructType属性含有一个MTLStructType类型的值 ,同时bufferDataSize属性表示这个结构体的长度 (bytes数量); 如果缓存Argument是数组，那么bufferDataType属性则表征的是数组元素的类型，同时bufferDataSize属性表示的也只是数组中一个元素的长度。 参考链接: Apple-Metal-Programming-Guide Metal’s Best Practice ","date":"2021-12-26","objectID":"/2021/12/4_metalguide-3-%E7%9D%80%E8%89%B2%E5%99%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%BA%93/:3:0","tags":["Metal","图形渲染"],"title":"MetalGuide(3)着色器程序与库","uri":"/2021/12/4_metalguide-3-%E7%9D%80%E8%89%B2%E5%99%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%BA%93/"},{"categories":null,"content":"Experience 专业打杂😉，焊过板子，写过嵌入式C和Qt桌面应用，也调过一些视觉算法API，现从事于图形学C++相关的开发工作。 Friends 希望遇到志同道合的朋友多多交流，欢迎互相友链，互相进步！ Hello 欢迎评论👨‍👩‍👧‍👦，并且主页头像下方的Email📧与 Github👩‍💻可戳😋 ","date":"2021-12-25","objectID":"/about/:0:0","tags":null,"title":"关于我","uri":"/about/"},{"categories":["计算机图形学"],"content":"摘要：Metal官方文档MetalGuide系列第二部分 -\u003e Metal资源与对象，即纹理Texture和Buffer","date":"2021-12-25","objectID":"/2021/12/3_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/","tags":["Metal","图形渲染"],"title":"MetalGuide(2)资源与对象","uri":"/2021/12/3_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/"},{"categories":["计算机图形学"],"content":"0.资源对象 资源对象，主要包含为缓存Buffers和纹理Textures。 ​ MTLBuffer它表示一块非格式化的内存可以存放任何类型的数据。它通常用于存放顶点数据、着色程序和计算状态数据。 ​ MTLTexture，它表示一块有格式的图像数据，有特定的纹理类型和像素格式。它通常被用作顶点着色程序、片元着色程序、或是并行计算函数的纹理源，它也可以存放图形渲染的结果输出。通常MTLTexture结构为这几种：1维、2维、或3维的图像，或是1维、2维的图像数组，或是拥有6个2维图像的立方体。 ​ MTLSamplerState，虽然采样器不是资源，但它总是用于纹理对象的查找计算。 1. 有关Buffer对象 ","date":"2021-12-25","objectID":"/2021/12/3_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/:0:0","tags":["Metal","图形渲染"],"title":"MetalGuide(2)资源与对象","uri":"/2021/12/3_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/"},{"categories":["计算机图形学"],"content":"1.1 创建Buffer对象 ​ 一个MTLBuffer对象表示了一个可以装载任何类型数据的内存片段。 ​ 下面的MTLDevice方法可以用于创建并返回类型MTLBuffer对象: ","date":"2021-12-25","objectID":"/2021/12/3_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/:1:0","tags":["Metal","图形渲染"],"title":"MetalGuide(2)资源与对象","uri":"/2021/12/3_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/"},{"categories":["计算机图形学"],"content":"1.2 Buffer的对象方法 ​ Buffer缓存对象有2种方法： contents: 返回缓存对象对应内存的CPU地址; newTextureWithDescriptor:offset:bytesPerRow: 创建某种特定类型的纹理。 2.Texture对象 ","date":"2021-12-25","objectID":"/2021/12/3_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/:2:0","tags":["Metal","图形渲染"],"title":"MetalGuide(2)资源与对象","uri":"/2021/12/3_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/"},{"categories":["计算机图形学"],"content":"2.1 创建Texture对象 ​ 下列的方法用于创建并返回一个MTLTexture对象： newTextureWithDescriptor ：新分配内存并创建一个MTLTexture对象，创建时需要传入的MTLTextureDescriptor参数描述了纹理的属性； ⚠️它隶属于MTLDevice方法； newTextureViewWithPixelFormat ： 该方法创建出来的 MTLTexture新对象和调用源对象共享存储，并重新解释了源纹理对象对应内存的图像格式；调用入参的MTLPixelFormat参数类型必须兼容源纹理对象的图像格式；⚠️它隶属于MTLTexture方法; newTextureWithDescriptor:offset:bytesPerRow ：创建一个MTLTexture对 象，共享调用源对象的内存，作为它自己的图像数据；⚠️它隶属于MTLBuffer方法。 ","date":"2021-12-25","objectID":"/2021/12/3_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/:3:0","tags":["Metal","图形渲染"],"title":"MetalGuide(2)资源与对象","uri":"/2021/12/3_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/"},{"categories":["计算机图形学"],"content":"2.2 纹理描述符 ​ MTLTextureDescriptor(纹理描述符)描述用于创建一个MTLTexture对象的各属性。包括图形尺寸(宽，高，深)，像素格式，组合模式(数组或是立方体)还有mipmaps的数量。 这些属性都只用在MTLTexture对象的创建过程中。当纹理对象创建完毕，descritor中的值后续再改变也不会影响纹理之前由它创建的对象。指定纹理的维度与组合模式(数组或立方) ​ Texture Descriptor内容组成以及含义如下图： ","date":"2021-12-25","objectID":"/2021/12/3_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/:4:0","tags":["Metal","图形渲染"],"title":"MetalGuide(2)资源与对象","uri":"/2021/12/3_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/"},{"categories":["计算机图形学"],"content":"2.3 创建纹理描述符 ​ 对一个2D纹理或是立方纹理来说，下面的快捷方法可以创建MTLTextureDescriptor对象并且自动设置多个值： texture2DDescriptorWithPixelFormat:width:height:mipmapped: 创建一个描述2D纹理的MTLTextureDescriptor对象，入参width和height定义2D纹理的尺寸， descriptor的type属性自动设置为MTLTextureType2D，属性depth和属性arrayLength自动设置为1； textureCubeDescriptorWithPixelFormat:size:mipmapped: 创建一个描述立方纹理的MTLTextureDescriptor对象, 入参size被设置给width和height， type属性自动设置为MTLTextureTypeCube，属性depth和属性arrayLength自动设置为1 。 上面两个快捷方法都接受一个入参pixelFormat，它定义了纹理的像素格式。这两个方法都接受一个入参mipmapped(值为YES/NO)，它指定纹理是否支持mipmap ； ","date":"2021-12-25","objectID":"/2021/12/3_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/:5:0","tags":["Metal","图形渲染"],"title":"MetalGuide(2)资源与对象","uri":"/2021/12/3_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/"},{"categories":["计算机图形学"],"content":"2.4 纹理分片(slice) ​ 纹理分片是一个单独纹理数据(可能是1维、 2维或是3维)以及所有和它关联的mipmap。 具有以下特点： 其基层的mipmap尺寸由MTLTextureDescriptor对象的width , height , depth属性设定； mipmap的第 i 层的尺寸是基层的1/2i ; 立方cube(6个2维分片)和数组array(每个数组元素对应1个分片)类型的纹理可以有多个分片；一个单独纹理数据(可能是1维、 2维或是3维)只能有1个分片； ","date":"2021-12-25","objectID":"/2021/12/3_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/:6:0","tags":["Metal","图形渲染"],"title":"MetalGuide(2)资源与对象","uri":"/2021/12/3_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/"},{"categories":["计算机图形学"],"content":"2.5 Copy图像数据进出纹理对象 ​ 以同步阻塞式拷贝图像数据进出纹理对象的内存，可以使用如下方法： replaceRegion:mipmapLevel:slice:withBytes:bytesPerRow:bytesPerImage: 从withBytes参数表示的资源对象中拷贝指定区域的像素数据到一个指定的纹理切片的指定内存区域； replaceRegion:mipmapLevel:withBytes:bytesPerRow: 和前一个方法类似，只是slice和bytesPerImage设置为0; getBytes:bytesPerRow:bytesPerImage:fromRegion:mipmapLevel:slice: 获取指定切片的指定区域的像素数据 ; getBytes:bytesPerRow:fromRegion:mipmapLevel: 和前一个方法类似，只是slice和bytesPerImage设置为0; ","date":"2021-12-25","objectID":"/2021/12/3_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/:7:0","tags":["Metal","图形渲染"],"title":"MetalGuide(2)资源与对象","uri":"/2021/12/3_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/"},{"categories":["计算机图形学"],"content":"2.6 纹理MTLTexture像素格式 ​ MTLTexture对象的MTLPixelFormat属性指定颜色、深度或是模板缓存数据中每一个像素如何组织。有3种像素格式：原生格式(ordinary),紧密填充格式(packed)和**压缩格式(**compressed): 原生格式 ：只有8、16或是32位颜色值，每个分量以升序内存地址排列，第一个分量处于最低的内存地址处 ；例如MTLPixelFormatRGBA8Unorm是一个32位格式颜色值 ，RGBA都各自占8bit; 紧密填充格式 ：把多个颜色分量结合起来从最低位LSB到最高位MSB存放在一个16位或是32位的值中 ；例如 MTLPixelFormatRGB10A2Uint是一个32位的填充格式色值,RGB都各自占8bit, A占2bit； 压缩格式 ：用于排列像素块的，每个块的布局被设定为这种像素格式；只能被用于2D、 2D数组或是立方类型的纹理; 其他格式：MTLPixelFormatGBGR422和MTLPixelFormatBGRG422是两种特殊的像素格式，用于存储YUV颜色空间的像素数据，只支持不含mipmap且width为偶数的2D类型的纹理。 还有几种支持sRGB颜色空间的格式，比如MTLPixelFormatRGBA8Unorm_sRGB和 MTLPixelFormatETC2_RGB8_sRGB ，sRGB颜色空间和线性颜色空间可以相互转换。 ","date":"2021-12-25","objectID":"/2021/12/3_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/:8:0","tags":["Metal","图形渲染"],"title":"MetalGuide(2)资源与对象","uri":"/2021/12/3_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/"},{"categories":["计算机图形学"],"content":"2.7 采样器状态(Sampler States)与纹理 ​ MTLSamplerState对象(采样器状态)包含了用于纹理查找 的属性。 ​ MTLSamplerState定义了寻址、过滤还有其他属性，用于一个图形着⾊色程序或是并行计算着色程序对一个MTLTexture对象实施采样操作。创建一个采样器state对象的步骤如下图： ​ ⚠️注意：descriptor的属性值仅在创建MTLSamplerState对象时生效，state对象创建完成后，改变descriptor的属性值不会影响已经创建的state对象。 3. CPU/GPU内存一致性 ​ CPU和GPU都可以访问同一个MTLResource类型的对象管理的存储数据。但是GPU和CPU的操作是异步进行的，为保持一致性，注意该事项： ​ 当MTLDevice对象执行一个MTLCommandBuffer对象时，它只有在command buffer被提交之前才能观察到由CPU引起的Command-Buffer内存变化，一旦被提交即状态为MTLCommandBufferStatusCommitted ，MTLDevice对象就观察不到这些资源的变化情况了。 参考链接: Apple-Metal-Programming-Guide Metal’s Best Practice ","date":"2021-12-25","objectID":"/2021/12/3_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/:9:0","tags":["Metal","图形渲染"],"title":"MetalGuide(2)资源与对象","uri":"/2021/12/3_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/"},{"categories":["折腾"],"content":"摘要：基于Hugo框架和Github-Page搭建个人博客","date":"2021-12-19","objectID":"/2021/12/5_%E5%9F%BA%E4%BA%8Ehugo%E5%92%8Cgithub-page%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","tags":["Hugo","Github Page"],"title":"利用Hugo和Github-Pages搭建免费的个人博客","uri":"/2021/12/5_%E5%9F%BA%E4%BA%8Ehugo%E5%92%8Cgithub-page%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["折腾"],"content":"0.为什么选Hugo+Github-Page 说起博客，除了用个人vps+wordPress这种麻烦但diy程度高的方式，比较流行的应该就是CSDN，博客园和简书，以及GithubPage(同类还有GiteePage)。因为可以对自己博客的完全掌控性，以及管理便利性，大多数博主各方面权衡后，选择了GitHubPage搭建静态网页的形式，与之配合的静态博客框架有jekyll、hexo和hugo。 有博主对3种框架进行过简单的测试对比，编译速度应该是Hugo\u003eHexo\u003eJekyll。 Jekyll由Ruby开发，是Github Page默认原生支持的框架，本人了解不多。 Hexo由Node.js开发，应该是使用人数最多的，主题齐全美观，功能稳定，部署和配置比Hugo稍微麻烦些。 而Hugo，由GO语言开发，号称是最快的静态网站部署框架(200篇博文编译大概1秒)，现在也有不少人从Hexo迁移到Hugo，所以还是选Hugo吧。 简述过程： Github Page，可以用来免费部署静态网站，使用效果也很直接，创建一个代码仓库，然后将上述的静态网站框架包含的文件拖进去，选择主题配置好，然后本地编译后得到静态网页内容，一起Push到远端仓库，Github Page会帮你部署好网站，假设usernamexxx是你的Github账号，那么进入域名https://usernamexxx.github.io 就可以打开你的博客了(当然这个域名可以后续自己折腾换成其他，这是后话了)。 1.准备工作 拥有一个Github账号，参考腾讯云：一步一步教你注册GitHub账号及简单使用. (邮箱建议不要用qq邮箱，虽然用了后面也有办法换，但在后续CDN加速的时候qq邮箱可能有问题) 电脑安装Git，下载安装地址：安装 Git. 电脑安装Hugo 最简单的办法，就是直接下载二进制免安装包，安装包下载地址Hugo-Release,选择最新的安装包，解压到本地某目录，并添加一下环境变量PATH即可。 如果坚持用命令行: 如果是mac系统，相信你已经有了brew程序，直接执行 brew install hugo 即可完成安装。 如果是Windows系统想要命令行安装，则管理员身份证运行终端，执行: # 如果有chocolatey，就直接执行 choco install hugo -confirm # 如果没有chocolatey，就先安装一下 powershell -NoProfile -ExecutionPolicy unrestricted -Command \"iex ((new-object net.webclient).DownloadString('https://chocolatey.org/install.ps1'))\" # 设置环境变量 SET PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin 安装成功后，命令行执行 hugo version 检查hugo版本，能正确打印版本信息即表示正常安装。 2.开通Github-Page 不太熟悉Github的朋友，官方写了很好的Quick Start，图文并茂的，直接贴链接吧，Github Page:Websites for you and your projects. 熟悉Github的朋友，直接新建一个public的仓库，如果用户名为usernamexxx仓库名为usernamexxx.github.io。 成功之后，请立即克隆到本地，并测试第一个网页，比克隆到D盘路径\"/d/Files\",执行如下命令： #假设用户名是usernamexxx cd /d/Files git clone https://github.com/usernamexxx/usernamexxx.github.io.git cd usernamexxx.github.io #测试第一个网页 echo \"Hello World\" \u003e index.html git add --all git commit -m \"Initial commit\" git push -u origin main 注意⚠ 上述Git-Push时可能会遇到填写账号密码的问题，密码注意是需要填写Access Token，可以直接访问Github-Developer-Setting,生成一个token，当作本次密码填入(Github从2021年8月份开始就需要这样通过https推代码了))。 Git简单设置避免后续麻烦： #windows平台需要执行这个，避免行尾\\r\\n,CRLF的提示，挺烦的 git config --global core.autocrlf false #终端环境保存https的token密码，避免每次都输入密码 git config --global credential.helper store 虽然这个免费的服务有一些限制：项目大小最大为1GB，每月带宽使用不超过100GB，每小时最多构建10个版本。对于个人博客网站，是绰绰有余了，所以不用担心。 3.新建hugo site站点 对于Windows系统，以下命令行都建议在Git-Bash中运行。 如上一节所述，我们的仓库在路径\"/d/Files/usernamexxx.github.io\". #cd到git仓库的目录 cd /d/Files/usernamexxx.github.io #确认关联到了远端仓库https://github.com/usernamexxx/usernamexxx.github.io.git git branch -v # 新建hugo站点,起个英文site名，比如MyHugoBlog hugo new site MyHugoBlog ##文件夹下会生成如下 # MyHugoBlog # ├─archetypes # ├─content (markdown内容存放处,一般是content/post/hello.md) # ├─data # ├─layouts # ├─static (站点静态资源存放处,比如image,js,css) # ├─themes # └─config.toml (站点最重要的配置文件) #cd到站点目录的原因：所有hugo命令都要在hugo根目录下执行 cd MyHugoBlog 4.设置主题 Hugo支持非常多简洁又美观的主题，可以在Hugo中文站的主题列表里或者Hugo官方站的主题列表挑选，看个人喜好了。这里可以不用太纠结，可以先随便选一个，让站点运行起来先，可以很方便就换掉的(配置文件里的theme选项)。 举例，看中了Even主题,Github地址为：https://github.com/olOwOlo/hugo-theme-even ，不要直接下载或直接clone，考虑到后续可能想有自定义修改，去Github界面fork到你自己仓库，然后再添加为子模块： cd /d/Files/usernamexxx.github.io git submodule add https://github.com/usernamexxx/hugo-theme-even MyHugoBlog/theme/even 5.创建hugo新文章 hugo的新文章在content/post目录，或者content/posts目录，看个人习惯而定，试用了几个主题，不同主题默认位置可能是二者其一。例如，执行下述hugo命令： cd /d/Files/usernamexxx.github.io/MyHugoBlog #会新建文件content/post/MyFirst.md hugo new post/MyFirst.md 新生成的markdown文档默认如下(三个短横---之间是配置选项，正文内容从短横之后开始)，可以手动添加一下正文内容 ： --- title: \"First\" date: 2022-01-03T15:19:14+08:00 draft: true --- # 正文内容在这里 - Hello world,first post! 其中draft的含义是草稿的意思，在正式发布的时候不会被包含和编译，那时要改为false。 所有文章的通用设置在根目录的config.toml进行配置，需要关注的有如下选项，更多选项请参考hugo-configuration baseURL = 'https://usernamexxx.github.io' languageCode = 'zh-cn' title = \"my blog\" theme = \"even\" publishDir=\"../docs\" 上述publishDir也可以不配置，默认是根目录下的public目录，意思是后续编译出的静态网页文件存放的目录，不和hugo的内容文件混在一起的话，方便后续查看Git-Log以及其他部署工作。 至此，Hugo新站点的骨架都搭建完了，可以本地调试看看效果了，在命令行运行： cd /d/Files/usernamexxx.github.io/MyHugoBlog hugo server -w 终端提示\"Web Server is available at http://localhost:1313/ (bind address 127.0.0.1)\"，访问localHost本地URL： http://localhost:1313 ，即可看到上述添加的MyFirst.md里的内容，并且保持终端site运行的情况下，手动修改markdown内容，保存","date":"2021-12-19","objectID":"/2021/12/5_%E5%9F%BA%E4%BA%8Ehugo%E5%92%8Cgithub-page%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:0:0","tags":["Hugo","Github Page"],"title":"利用Hugo和Github-Pages搭建免费的个人博客","uri":"/2021/12/5_%E5%9F%BA%E4%BA%8Ehugo%E5%92%8Cgithub-page%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["脚本"],"content":"摘要：10个简单好用的Linux命令","date":"2021-12-18","objectID":"/2021/12/1_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/","tags":["shell脚本","linux"],"title":"10个容易遗忘但好用的Linux命令","uri":"/2021/12/1_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["脚本"],"content":"1) pgrep ​ pgrep名字前有个p，我们可以猜到这是进程相关的grep命令。不过，这个命令主要是用来列举进程ID的。 $ pgrep -u username_xx ​ 这个命令相当于： ##效果待定,awk命令不熟悉(逃 ps -ef | egrep '^username_xx' | awk '{print $2}' ","date":"2021-12-18","objectID":"/2021/12/1_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/:0:1","tags":["shell脚本","linux"],"title":"10个容易遗忘但好用的Linux命令","uri":"/2021/12/1_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["脚本"],"content":"2）pstree ​ 这个命令可以用树形的方式列出进程。 ","date":"2021-12-18","objectID":"/2021/12/1_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/:0:2","tags":["shell脚本","linux"],"title":"10个容易遗忘但好用的Linux命令","uri":"/2021/12/1_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["脚本"],"content":"3）bc ​ 这个命令主要是做一个精度比较高的数学运算的。比如开平方根等。下面是一个我们利用bc命令写的一个脚本（文件名：square.sh） #!/bin/bash if [ $# == 0 ] then echo 'Usage: sqrt number' exit 1 else echo -e \"sqrt($1)\\nquit\\n\" | bc -q -i fi #运行方式：./squar.sh 或者 ./square.sh 10.00 ","date":"2021-12-18","objectID":"/2021/12/1_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/:0:3","tags":["shell脚本","linux"],"title":"10个容易遗忘但好用的Linux命令","uri":"/2021/12/1_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["脚本"],"content":"4）split ​ 把一个很大的文件分割成一些小的文件，注意，split执行后源文件仍然在的。 #例如把上文的square.sh分割成多个文件,先查看大小，发现是124字节 ls -al #sqx_为前缀，会得到3个文件:sqx_aa,sqx_ab,sqx_ac split -b 50 square.sh sqx_ #把文件重新合并，使用cat命令即可 cat sqx_* \u003e square.sh.new ","date":"2021-12-18","objectID":"/2021/12/1_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/:0:4","tags":["shell脚本","linux"],"title":"10个容易遗忘但好用的Linux命令","uri":"/2021/12/1_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["脚本"],"content":"5）nl ​ nl命令其它和cat命令很像，只不过它会打上行号。 #不加后续的head命令也可以 benjamin@ubuntu:~$ nl square.sh | head -n 5 1 #!/bin/bash 2 if [ $# == 0 ] 3 then echo 'Usage: sqrt number' 4 exit 1 5 else ","date":"2021-12-18","objectID":"/2021/12/1_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/:0:5","tags":["shell脚本","linux"],"title":"10个容易遗忘但好用的Linux命令","uri":"/2021/12/1_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["脚本"],"content":"6）mkfifo ​ mkfifo的作用是创建一个有名管道，平时使用的较多的是无名管道，例如“ls | grep txt”. ​ 有名管道创建后可以像文件一样存在文件夹中，像是一个缓存区。 ​ 使用举例如下： #在终端窗口1执行如下命令，ls没有输出内容 mkfifo pipex ls \u003e pipex #打开终端窗口2执行如下命，会看到 ls 命令输出的内容 cat \u003c pipex 拓展：常用的管道命令有==\u003e cut、grep、sort、wc、uniq tee：重定向，既能在屏幕输出，又能保存到文件中 tr、col、join、paste、expand、split ","date":"2021-12-18","objectID":"/2021/12/1_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/:0:6","tags":["shell脚本","linux"],"title":"10个容易遗忘但好用的Linux命令","uri":"/2021/12/1_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["脚本"],"content":"7）ldd ​ 这个命令可以知道你的一个可执行文件所使用了动态链接库 ###假设有个文件calc.so,命令后接文件名即可，具体参数选项可参照命令help内容 ldd calc.so ","date":"2021-12-18","objectID":"/2021/12/1_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/:0:7","tags":["shell脚本","linux"],"title":"10个容易遗忘但好用的Linux命令","uri":"/2021/12/1_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["脚本"],"content":"8）col ​ Linux col命令用于过滤控制字符。 ​ 在许多UNIX说明文件里，都有RLF控制字符。当我们运用shell特殊字符\"\u003e“和”»\"，把说明文件的内容输出成纯文本文件时，控制字符会变成乱码，col指令则能有效滤除这些控制字符。 ​ 下面以 man 命令帮助文档为例，讲解col 命令的使用。 ​ 将man 命令的帮助文档保存为man_help，使用-b 参数过滤所有控制字符。在终端中使用如下命令： #man命令用法，man + linux命令 man man | col -b \u003e man_help ","date":"2021-12-18","objectID":"/2021/12/1_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/:0:8","tags":["shell脚本","linux"],"title":"10个容易遗忘但好用的Linux命令","uri":"/2021/12/1_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["脚本"],"content":"9）xmlwf ​ 这个命令可以让你检查一下一个XML文档是否是所有的tag都是正常的。 ","date":"2021-12-18","objectID":"/2021/12/1_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/:0:9","tags":["shell脚本","linux"],"title":"10个容易遗忘但好用的Linux命令","uri":"/2021/12/1_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["脚本"],"content":"10）lsof ​ 这个命令可以列出打开了的文件。 [root@RHELSVR5 ~]# lsof | grep TCP httpd 548 apache 4u IPv6 14300967 TCP *:http (LISTEN) httpd 548 apache 6u IPv6 14300972 TCP *:https (LISTEN) httpd 561 apache 4u IPv6 14300967 TCP *:http (LISTEN) httpd 561 apache 6u IPv6 14300972 TCP *:https (LISTEN) ","date":"2021-12-18","objectID":"/2021/12/1_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/:0:10","tags":["shell脚本","linux"],"title":"10个容易遗忘但好用的Linux命令","uri":"/2021/12/1_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["计算机图形学"],"content":"摘要：Metal官方文档MetalGuide系列第一部分 -\u003e 基本的指令和执行模型","date":"2021-12-18","objectID":"/2021/12/2_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/","tags":["Metal","图形渲染"],"title":"MetalGuide(1)指令组织和执行模型","uri":"/2021/12/2_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/"},{"categories":["计算机图形学"],"content":"1. 基本概念认知 ​ Metal 是一个和 OpenGL ES 类似的面向底层的图形编程接口，通过使用相关的API 可以直接操作 GPU。不过不同的是，Metal不具有跨平台特性，只针对苹果的平台系统使用，并且编程开发语言为Objective - C或Swift。 ​ Metal框架支持GPU加速的3D图形渲染和并⾏数据计算，它提供了一系列的API用于在细粒度和低层次上组织、处理、提交图形渲染指令、并⾏计算指令，并管理和这些指令相关联的数据和资源。使用Metal的一个主要⽬标是减少GPU执⾏这些计算的开销。 2. 指令组织和执行模型 ​ 一个command queue包含了一系列command buffers。command queue用于组织它拥有的各个command buffer按序执行。一个command buffers包含多个被编码的指令，这些指令将在一个特定的设备上执⾏。一个Encoder可以将绘制、计算、位图传输指令推入一个command buffer，最后这些command buffer将被提交到设备执⾏。 ​ 任一时刻，只会有一个Encoder是处于激活状态的，它可以向一个command buffer提交指令。前一个Encoder结束后，另一个Encoder才可以被创建并用于同一个command buffer。 ​ 最终，他们的逻辑模型类似于下图： ","date":"2021-12-18","objectID":"/2021/12/2_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/:0:0","tags":["Metal","图形渲染"],"title":"MetalGuide(1)指令组织和执行模型","uri":"/2021/12/2_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/"},{"categories":["计算机图形学"],"content":"2.1 何为设备 ​ 一个MTLDevice对象代表一个可以执行指令的GPU，该协议包含创建新的command queue的方法、从内存申请缓存的方法、创建纹理对象的方法以及查询设备功能的方法。调用MTLCreateSystemDefaultDevice方法获取系统首选的设备对象。 ","date":"2021-12-18","objectID":"/2021/12/2_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/:1:0","tags":["Metal","图形渲染"],"title":"MetalGuide(1)指令组织和执行模型","uri":"/2021/12/2_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/"},{"categories":["计算机图形学"],"content":"2.2 暂态/非暂态(Non-Transient)对象 ​ 故名思义，两者是按照对象的生命周期来区分的。 在Metal中有些对象被设计成暂态，使用它们⾮常轻量。 另外一些则要昂贵许多，因此它们应该拥有长的生命周期。 非暂态对象在性能相关的代码中应该避免反复创建，尽量重用，Metal的非暂态对象列表如下： 相对地，Metal的暂态对象用于一次性使用,创建和销毁的成本廉价,它们的创建方法都返回autoreleased对象。Metal的暂态对象列表如下： ","date":"2021-12-18","objectID":"/2021/12/2_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/:2:0","tags":["Metal","图形渲染"],"title":"MetalGuide(1)指令组织和执行模型","uri":"/2021/12/2_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/"},{"categories":["计算机图形学"],"content":"2.3 指令队列(Command Queue) ​ 一个command queue管理着一个在GPU上即将执⾏的command buffer有序队列。同一个队列的所有command buffer都会被按照入队的次序执⾏。通常，command queue是线程安全的，允许多个command buffer 同时编码。 ​ 如何创建Command Queue，以下的2个方法都是可行的: newCommandQueue newCommandQueueWithMaxCommandBufferCount ⚠️：Command Queue是非暂态对象，是具有长生命周期的，不要反复地创建和销毁这种对象。 ","date":"2021-12-18","objectID":"/2021/12/2_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/:3:0","tags":["Metal","图形渲染"],"title":"MetalGuide(1)指令组织和执行模型","uri":"/2021/12/2_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/"},{"categories":["计算机图形学"],"content":"2.4 指令缓存(Command Buffer) ","date":"2021-12-18","objectID":"/2021/12/2_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/:4:0","tags":["Metal","图形渲染"],"title":"MetalGuide(1)指令组织和执行模型","uri":"/2021/12/2_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/"},{"categories":["计算机图形学"],"content":"2.4.1 Command Buffer的特点 ​ 一个command buffer在被GPU执行之前会存储多个被编码的指令。一个command buffer可以包含多种类型的编码。 ​ Command Buffer具有以下特点： 一帧渲染即使含有多个RenderPass或多个计算处理程序、多个位图操作，都可以被编码到同一个Command Buffer中； 它是暂态对象，不支持重用；一旦被提交等待执行，即进入队列； 它还代表了app中独立的可被追踪的任务单元。 ","date":"2021-12-18","objectID":"/2021/12/2_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/:4:1","tags":["Metal","图形渲染"],"title":"MetalGuide(1)指令组织和执行模型","uri":"/2021/12/2_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/"},{"categories":["计算机图形学"],"content":"2.4.2 创建Command Buffer ​ 如何创建Command Buffer对象，以下的2个方法都是可行的: commandBuffer：数据是强引用的，一个MTLCommandBuffer对象只能提交给创建它的那个command queue。 commandBufferWithUnretainedReferences：数据不是强引用的，在可以保证和command buffer相关数据在其被执⾏时都有引用计数的情况下，又极端需要提升性能，才会使用该方法。使用时需要格外注意引用计数。 ","date":"2021-12-18","objectID":"/2021/12/2_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/:4:2","tags":["Metal","图形渲染"],"title":"MetalGuide(1)指令组织和执行模型","uri":"/2021/12/2_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/"},{"categories":["计算机图形学"],"content":"2.4.3 执行指令 ​ MTLCommandBuffer协议使用如下的方法来设定其在指令队列中的执⾏顺序： enqueue：为一个command buffer在command queue中预定一个位置，但是不会提交这个command buffer。当这个command buffer最终被提交时，指令队列把它安排在对应的enqueue顺序队列中执行。 commit：使得command buffer尽可能快地被执⾏，但还是得等到所有在command queue中的早前排入队列的 其他command buffer被执行完成后才能执⾏。如果commad queue中没有排在前面的command buffer，该方法隐式执⾏enqueue操作。 ","date":"2021-12-18","objectID":"/2021/12/2_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/:4:3","tags":["Metal","图形渲染"],"title":"MetalGuide(1)指令组织和执行模型","uri":"/2021/12/2_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/"},{"categories":["计算机图形学"],"content":"2.4.4 注册处理程序块(Register Handler Blocks) ​ 下列的MTLCommandBuffer的方法可以监视指令的执⾏。使用了这些方法注册处理程序块，那么在某个线程中，这些处理程序块会按照执⾏顺序被调用。这些处理程序块应该是迅速可被执⾏完成的，如果有开销⼤的造成阻塞的任务，那么应该将它们安排到其他线程执⾏行。 addScheduledHandler : 注册的处理程序块将在command buffer被“排定好”(scheduled)时调用。“排定好”一般是指，MTLCommandBuffer对象或系统API提交的所有任务之间的依赖关系都能被满⾜。 waitUntilScheduled : 调用后就开始等待，return时机为所有command buffer被“排定好”而且addScheduledHandler方法注册的处理程序块都执行完毕。 addCompletedHandler : 注册的处理程序块将在command buffer被执⾏完毕后立即调用；一个command buffer对象可以注册多个这样的处理程序块。 waitUntilCompleted : 调用后就开始等待，return时机为所有command buffer都执行完而且addCompletedHandler注册的处理程序块都执行完毕。 presentDrawable : 较为便捷，它用于当command buffer处于“排定好”时呈现一个可显示资源 (CAMetalDrawable类型对象)的内容。 执行完毕后，需要关注以下2种Command Buffer的属性： status: 只读属性，包含了一个MTLCommandBufferStatus类型的枚举值，它反映了command buffer在其生命周期中处于哪个阶段。 error：如果command buffer成功执⾏，值为nil。如果有异常发生，值为“Command Buffer Error Codes”类型。且status属性被设 置为MTLCommandBufferStatusError。 ","date":"2021-12-18","objectID":"/2021/12/2_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/:4:4","tags":["Metal","图形渲染"],"title":"MetalGuide(1)指令组织和执行模型","uri":"/2021/12/2_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/"},{"categories":["计算机图形学"],"content":"2.5 指令编码(Command Encoder) ","date":"2021-12-18","objectID":"/2021/12/2_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/:5:0","tags":["Metal","图形渲染"],"title":"MetalGuide(1)指令组织和执行模型","uri":"/2021/12/2_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/"},{"categories":["计算机图形学"],"content":"2.5.1 Command Encoder的特点 ​ Command Encoder用来编码渲染和计算指令，然后被推入到一个command buffer并最终在GPU上执行。它具有以下特点： 它有多个对象方法可以往Command Buffer里追加指令； 当一个Encoder是激活状态时，就可以调用endEncoding方法向它所属的command buffer推送指令； 推送完成后要写入更多的指令，就创建一个新的 Encoder。 ","date":"2021-12-18","objectID":"/2021/12/2_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/:5:1","tags":["Metal","图形渲染"],"title":"MetalGuide(1)指令组织和执行模型","uri":"/2021/12/2_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/"},{"categories":["计算机图形学"],"content":"2.5.2 创建Command Encoder ​ MTLCommandBuffer协议中的若干方法都可以创建Command Encoder对象，这些对象可以向对应的command buffer推送指令。具体地，以下的4个方法都是可行的: renderCommandEncoderWithDescriptor ：创建一个MTLRenderCommandEncoder类型的Encoder实现图形渲染，图形绘制用到的attachment附件由那个MTLRenderPassDescriptor类型的入参对象指定； computeCommandEncoder ：创建一个MTLComputeCommandEncoder类型的Encoder来实现并行数据计算； blitCommandEncoder ：创建一个MTLBlitCommandEncoder类型的Encoder来实现内存操作； parallelRenderCommandEncoderWithDescriptor ：创建一个MTLParallelRenderCommandEncoder类型的Encoder，它用于支持多个MTLRenderCommandEncoder类型的⼦Encoder同时在不同的线程中运⾏，依然把所有绘制结果写入同一个attachment中，该attachment由MTLRenderPassDescriptor类型的入参指定。 ","date":"2021-12-18","objectID":"/2021/12/2_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/:5:2","tags":["Metal","图形渲染"],"title":"MetalGuide(1)指令组织和执行模型","uri":"/2021/12/2_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/"},{"categories":["计算机图形学"],"content":"2.5.3 多种用途的Command Encoder ​ a. 用于渲染的Command Encoder ​ 图形渲染可以被描述为一系列的Render Pass，一个MTLRenderCommandEncoder对象表示和一个Render Pass相关联的渲染状态和渲染命令。这个Encoder对象需要一个相关联的MTLRenderPassDescriptor对象，在这个descriptor对象中包含颜⾊、深度、模板等依赖信息。 ​ MTLRenderCommandEncoder拥有各类方法可以完成以下事项： ​ 设定图形资源，比如缓存和纹理对象，这些对象包含着顶点⽚元和纹理数据； ​ 设定固定图形渲染管线状态，包括视口，三角形填充模式，裁剪矩形，深度测试和模板测试等等。 ​ b. 用于并行计算的Command Encoder ​ 使用MTLCommandBuffer的computeCommandEncoder方法可以创建一个并行计算用的Command Encoder。 ​ 对于并⾏数据计算，MTLComputeCommandEncoder协议提供了方法来编码计算指令，以此设定计算程序和参数，调度计算程序执⾏。 ​ c. 用于位图操作的Command Encoder ​ 使用MTLCommandBuffer协议的blitCommandEncoder方法可以创建一个MTLBlitCommandEncoder。 ​ MTLBlitCommandEncoder协议提供了方法用来在缓存(MTLBuffer) 和纹理(MTLTexture)之间进⾏拷贝。 ​ 该协议还提供了用一种颜⾊填充纹理的方法，以及创建mipmap的方法。 ​ ","date":"2021-12-18","objectID":"/2021/12/2_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/:5:3","tags":["Metal","图形渲染"],"title":"MetalGuide(1)指令组织和执行模型","uri":"/2021/12/2_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/"},{"categories":["计算机图形学"],"content":"2.6 多线程与Command Buffer/Command Encoder ​ 很多的应用程序只是用一个线程来编码绘制指令到一个command buffer来绘制一帧画面。在每帧绘制的末尾， 提交commad buffer，如此可以排定和开始指令的执行。 ​ 如果希望并行地让command buffer执⾏指令编码，那么可以同时创建多个command buffer，使用多个线程，每个线程单独为一个command buffer编码指令。 ​ 如果事先知道command buffer应该以什么顺序执⾏，那么 MTLCommandBuffer的enqueue方法可以在command queue中声明执⾏行顺序，⽽不必等待执⾏编码和提交操作。否则只能等到command buffer被提交，这时在command queue中它就被指定了一个位置，顺序位于之前提交的 command buffer后面。 ​ 任一时刻只有一个GPU线程在访问command buffer，多线程的应用可以为每个command buffer准备一个线程，如此实现并⾏创建多个command buffer。 ​ 下图示例了一个3线程应用，每个线程都操作一个command buffer，每个线程中，任一时刻只有一个Encoder在访问它对应的command buffer。当你完成了编码，调用Encoder的endEncoding方法，然后一个新的Encoder才可以为command buffer编码指令。 参考链接: Apple-Metal-Programming-Guide Metal’s Best Practice ","date":"2021-12-18","objectID":"/2021/12/2_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/:6:0","tags":["Metal","图形渲染"],"title":"MetalGuide(1)指令组织和执行模型","uri":"/2021/12/2_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/"},{"categories":["C++"],"content":"摘要：Effective C++(第三版)内容第一、第二章的总结","date":"2021-12-12","objectID":"/2021/12/6_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/","tags":["C++","程序设计"],"title":"Effective C++(第三版)学习总结(一)","uri":"/2021/12/6_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/"},{"categories":["C++"],"content":"0.序言 这本C++的经典之作，作者是大佬Scott Meyers👉大佬主页，还写过其他几本影响深远的C++经典，例如《Effective STL》,《More Effective C++》,《Effective Mordern C++》,《Overview of the New C++(C++11/14)》等等。本人看的是中文版，侯捷老师翻译的,以前做的笔记是在自己的纸质笔记本上，现在挪到博客上来吧。 关于Effective C++，全书55个C++条款，许多人都做了笔记类的博客，大家视角不同可能侧重也不同，各花入各眼了。(PS:本文主干目录和原书一致，另外，由于原书在C++11之前写成，所以会根据本人开发经验新增一些个人感悟👉By the way环节) (本文为Effective-C++笔记系列的第一部分，涉及原书第1~3章，内容范围Rule01~12。为方便书写，Rule01简写为R01)。 废话不多说，直接进入正题。 ","date":"2021-12-12","objectID":"/2021/12/6_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/:1:0","tags":["C++","程序设计"],"title":"Effective C++(第三版)学习总结(一)","uri":"/2021/12/6_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/"},{"categories":["C++"],"content":"一.让自己习惯C++ ","date":"2021-12-12","objectID":"/2021/12/6_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/:2:0","tags":["C++","程序设计"],"title":"Effective C++(第三版)学习总结(一)","uri":"/2021/12/6_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/"},{"categories":["C++"],"content":"R01 视C++为一个语言联邦 如今的C++已经是个多重范式(multiparadigm)语言,同时支持面向过程形式、面向对象形式、函数形式、泛型形式、元编程形式。 要理解这么多特性，可以简单的归结为四种次语言(sublanguage)组成： C语言：C++仍以C为基础。C++是C的超集，区块 、语句、预处理、内置数据类型、数组、指针等全部来自于C语言； Object-Oriented C++: 面向对象特性。构造、析构、封装(encapsulation)、继承(inheritance)、多态(polymorhpism)、virtual函数(动态绑定)等； Template C++:C++的泛型(generic)编程的部分，也带来了黑魔法-模板元编程(TMP,Metaprogramming)； STL：STL(Standard Temlate Library)即标准模板库，它是template程序库。封装了各类容器(container)、配置器(allocator)、迭代器(iterator)、算法以及常用对象。 ","date":"2021-12-12","objectID":"/2021/12/6_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/:2:1","tags":["C++","程序设计"],"title":"Effective C++(第三版)学习总结(一)","uri":"/2021/12/6_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/"},{"categories":["C++"],"content":"R02 尽量以const,enum,inline替换#define 对于宏定义的常量，建议用const常量或者枚举enum替换 这样做的好处是方便调试，因为宏报错就是个常数值，没有符号表；并且宏不具有封装性(宏的作用域是在编译时是其定义之事)。 // 举例：MAX_DATA_COUNT在预处理阶段就会被替换，编译器不会见到它，所以一旦有相关报错，给的是100这个值 #define MAX_DATA_COUNT 100 const int MAX_DATA_COUNT = 100 ;//常量只有一份，宏会导致多份常量值 class Buffer{ public://...类其他部分省略 static const double factor_ = 4.0;//常量声明，\"in-class初值设定\"，旧式编译器需要在实现文件初始化 private: static const int ArrLength = 5; int arr[ArrLength]; }; 如果编译器不允许声明时\"in-class初值设定\",如果是整形常量，可以让枚举值来替代，而且枚举值不能被取地址。 对于宏定义的函数，建议用内联inline函数替换 宏函数没办法单行debug调试，而内联函数可以； 宏的写法即使小心翼翼的加好了括号，也可能造成意想不到的宏函数重复计算的问题。 #define CALL_WITH_MAX(a,b) f((a)\u003e(b) ? (a) :(b)) int a = 5, b = 0; CALL_WITH_MAX(++a,b); // a累加二次 CALL_WITH_MAX(++a,b+10); // a累加一次 // 定义个inline函数就不会有这个问题,(a,b)作为函数入参就只会计算一次 ","date":"2021-12-12","objectID":"/2021/12/6_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/:2:2","tags":["C++","程序设计"],"title":"Effective C++(第三版)学习总结(一)","uri":"/2021/12/6_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/"},{"categories":["C++"],"content":"R03 尽可能用const 说起const，先复习个面试高频题😁 //类型char在哪里没关系，关键看const和*的相对位置：const在*左边，指针所指物为常量; const在*右边，指针为常量； const char* p; // 指针p所指的字符串为常量，但是p可以修改 char* const p; // 指针p是常量，指向的字符串可修改 const修饰函数返回值时的防御性 const修饰函数的返回值，可以避免一些错误，如下： const Rational operator* (const Rational\u0026 lhs,const Rational\u0026 rhs); //存在Rational a,b,c; if(a*b = c) //例如手误 \"==\"打成了\"=\"，编译器会直接报错 const成员函数的限制 const成员函数有2个好处：明确理解函数是否修改对象内容；使“操作const对象”成为可能。 可以通过const特性让对象自动调用正确的版本： class TextBlock{//...类其他部分省略 const char\u0026 operator[](std::size_t index) const{ return text[index];} char\u0026 operator[](std::size_t index) { return text[index];} private: std::string text; } void print(const TextBlock\u0026 ctb){ std::cout\u003c\u003cctb[0] ;//根据const特性，调用 const TextBlock::operator[] } 思考：const成员函数不修改成员对象，那么，如果成员对象为指针char *p，仅修改p指向的内容，那它还是const成员函数吗？ 实测：const成员函数是允许p[2]= 'x'这一操作的，但是不允许p++； bitwise-constness(又称为physical constness)理念认为不是，不能更改任何对象内的任何一个bit。这种说法也有纰漏，const函数返回一个引用就失控了,外部可改； logical-constness理念则允许const成员函数修改成员变量的bits，但只有在客户端侦测不出的情况下; const成员函数如果一定要修改成员变量，成员变量使用 mutable 修饰即可. const与non-const的成员函数实现完全相同时 这种情况，如何去除代码冗余是个问题。不要封装出一个private函数然后一起调用，多了层调用。 正确做法👉 使用转型,让non-const调用const成员函数，如下为示例： class Rawdata { public: Rawdata(char *src):p_(src),length_(strlen(src)) {} const int\u0026 GetLength()const{ p_[1] = 'a';//为求简便,不作检查了。p_内容修改编译器是允许的. return length_; } int GetLength() { return const_cast\u003cint\u0026\u003e( (static_cast\u003cconst Rawdata\u0026\u003e(*this)).GetLength()); } private: char *p_ = nullptr; int length_ = 0; }; ","date":"2021-12-12","objectID":"/2021/12/6_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/:2:3","tags":["C++","程序设计"],"title":"Effective C++(第三版)学习总结(一)","uri":"/2021/12/6_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/"},{"categories":["C++"],"content":"R04 确定对象使用前先初始化 分清\"赋值\"和\"初始化\"，在类的构造函数体内使用等号\"=“赋值并非\"初始化”。成员变量的初始化是在构造函数的成员初始化列表实现，效率更高。 C++初始化的次序： Base class总是早于Derived Class被初始化； Class内的成员变量总是以声明次序被初始化； 举例：下图中的代码初始化顺序为声明顺序\"age_$\\rightarrow$name_$\\rightarrow$gender_ $\\rightarrow$isVip_\" class Customer { public: //这里只是为了验证，如果是实际工程代码，建议初值列表尽量和声明顺序保持一致 Customer(std::string gender, uint8_t age, std::string name, bool isVip = false) :isVip_(isVip), gender_(gender), name_(name), age_(age) {} private: uint8_t age_; std::string name_; std::string gender_; bool isVip_; }; By the way 💡：任何一个成员变量a的初始化流程：类内声明赋初值(C++11)-\u003e构造函数初始化列表-\u003e构造函数体内赋值. 函数体外static变量称为non-local static变量，这种变量可以在各自的编译单元正常工作，但C++无法保证初始化次序，当编译单元之间需要共享变量时，而该变量依赖non-local static，就可能会出问题。 解决办法是将这样的变量放回函数体内，成为local static，因为C++确保在函数被调用时一定会初始化这个static变量。 ","date":"2021-12-12","objectID":"/2021/12/6_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/:2:4","tags":["C++","程序设计"],"title":"Effective C++(第三版)学习总结(一)","uri":"/2021/12/6_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/"},{"categories":["C++"],"content":"二.构造/析构/赋值运算 ","date":"2021-12-12","objectID":"/2021/12/6_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/:3:0","tags":["C++","程序设计"],"title":"Effective C++(第三版)学习总结(一)","uri":"/2021/12/6_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/"},{"categories":["C++"],"content":"R05 了解C++默认编写并调用哪些函数 编译器可以暗自为Class创建default构造函数，copy构造函数(复制构造)，copy assigment(赋值构造)操作符，以及default析构函数。 class EmptyClass{}; 等价于👇 class EmptyClass { public: EmptyClass() {} // default构造函数 EmptyClass(const EmptyClass\u0026 rhs) {}//copy构造函数 ~EmptyClass() {}//default析构函数，注意是non-virtual EmptyClass\u0026 operator=(const EmptyClass\u0026 rhs) {}//copy assignment操作符 }; 如果一个非空Class自行声明了构造函数，编译器就不再为它创建default构造函数 如果一个Class内有引用变量或const变量，编译器不会为其生成copy-assignment函数，需要自己实现 class NameObject { public: NameObject(std::string\u0026 name, const int value) :nameValue_(name), objectVal_(value) {} private: std::string\u0026 nameValue_; const int objectVal_; };//考虑以下应用代码 std::string name(\"Mike\"), name2(\"Nicky\"); NameObject nObj(name,22), nObj2(name2,33); nObj2 = nObj;//这一句会导致编译失败，因为引用不能指向2个对象，且const不可改 ","date":"2021-12-12","objectID":"/2021/12/6_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/:3:1","tags":["C++","程序设计"],"title":"Effective C++(第三版)学习总结(一)","uri":"/2021/12/6_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/"},{"categories":["C++"],"content":"R06 不想编译器的自动生成的函数,明确拒绝 某些场景，类对象本身是认为独一无二的，比如描述人物性格的类Personality(可能不恰当)，不同的人性格不同，肯定是不希望能复制/赋值的。 如果不想编译器自动生成那几个函数，比如不想要复制构造或赋值构造，就明确在代码中禁止，也防止外部用户使用。 技巧1：可以声明为private函数但是不给出实现，让编译器报错； 技巧2：可以设立基类Base，让复制构造和赋值构造都为private函数，让目标类继承于Base类。 By the way C++11针对此类情况，给予了delete关键字一个新功能，在成员函数后面新增\"=delete\"，即可显式地拒绝这个函数的生成和调用.举例如下: class A { public: A(const A\u0026) = delete; A\u0026 operator=(const A\u0026) = delete; }; ","date":"2021-12-12","objectID":"/2021/12/6_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/:3:2","tags":["C++","程序设计"],"title":"Effective C++(第三版)学习总结(一)","uri":"/2021/12/6_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/"},{"categories":["C++"],"content":"R07 为多态基类声明virtual析构函数 针对Base* pBase= new DerivedObj()，释放pBase时，如果Base基类的析构函数None-Virtual，则会导致Derived的析构函数不会被调用，造成内存不完全释放，即内存泄漏； Non-Virtual的Class不要做基类； 如果不做基类，就不要声明析构函数为virtual函数，避免虚表为其分配vptr造成浪费； 如果想要抽象类，又暂时没有合适接口，可以让先虚析构成为纯虚函数，例如： class RawData{ public: virtual ~RawData() = 0; }; // 这里特殊的是，需要为这个纯虚函数提供定义 ~RawData::RawData(){} ","date":"2021-12-12","objectID":"/2021/12/6_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/:3:3","tags":["C++","程序设计"],"title":"Effective C++(第三版)学习总结(一)","uri":"/2021/12/6_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/"},{"categories":["C++"],"content":"R08 别让异常逃离析构函数 析构函数最好不要吐出异常 对于某个Widget类，如果析构函数抛出异常，那么vector\u003cwidget\u003e析构时可能连续抛出多个异常以至于无法处理，直接导致提前程序结束或者未定义行为。 如果有某个函数可能会抛出异常，并需要对异常做出反应，应该提供一个非析构的函数来处理 注意，在析构中抛异常并吞下(catch后go-on-execute)，会掩盖错误，也不是个好办法;抛异常后catch住并std::abort()反而可以提前终结『未定义行为』。 ","date":"2021-12-12","objectID":"/2021/12/6_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/:3:4","tags":["C++","程序设计"],"title":"Effective C++(第三版)学习总结(一)","uri":"/2021/12/6_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/"},{"categories":["C++"],"content":"R09 绝不在构造和析构过程中调用virtual函数 在Derived-Class的Base-Class构造期间，对象的类型是Base-Class，而非Derived，即使dynamic_cast也是这样认为的，因为此时virtual函数不会下降到Derived-Class的阶层；换句话说==\u003e “在Base-Class构造期间，virtual函数不是virtual函数” ； 在析构的时候也是类似道理，也不要在析构函数中调用virtual函数，间接调用也不行(比如non-Virtual-\u003evirtual)； 那么替代方案是？ 如果有这样一种情况，希望在子类构造时能调用父类的foo函数(下方logTransaction函数)，那么将foo改为non-Virtual函数，并且子类构造时调用父类构造函数，有参数时一并传过去； class Transaction { public: explict Transaction(const std::string\u0026 info,int id):id_(id) { logTransaction(info); } void logTransaction(const std::string\u0026 info) { std::cout \u003c\u003c info.c_str(); }//non-Virtual函数 private: int id_; }; class BuyTransaction :public Transaction { public: //将log信息传递给 基类Transaction构造函数； 并初始化了基类成员 BuyTransaction(const std::string\u0026 info, int id) :Transaction(info,id) {/**/} }; By the way 上述代码中，如果有几个Base构造函数，就得写几个Derived构造函数传参。为了简化这一步骤， 在现代C++11，推出了继承构造函数(Inheriting Constructor)，子类可以一个都不用写，直接写一句using声明即可，使用using BaseClass::BaseClass的形式，如下👇 class BuyTransaction :public Transaction { public: using Transaction::Transaction; //其他 }; ","date":"2021-12-12","objectID":"/2021/12/6_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/:3:5","tags":["C++","程序设计"],"title":"Effective C++(第三版)学习总结(一)","uri":"/2021/12/6_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/"},{"categories":["C++"],"content":"R10 令operator=返回一个reference to *this 关于赋值操作符operator= ，主流做法是： class Widget { public: Widget\u0026 operator=(const Widget \u0026rhs) { //... do some thing return *this; } }; 上述做法不局限于operator=，还有operator += ,-=,*=,/=等其他赋值运算符。 该主流协议/做法不是强制性的，只是个建议，因为这样可以允许连续赋值($x=y=z$的形式)。 该协议被内置类型，以及STL的类型(如string,vector,complex,shared_ptr)共同遵守。 ","date":"2021-12-12","objectID":"/2021/12/6_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/:3:6","tags":["C++","程序设计"],"title":"Effective C++(第三版)学习总结(一)","uri":"/2021/12/6_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/"},{"categories":["C++"],"content":"R11 在operator=中处理\"自我赋值\" 一个对象赋值给自己，这种看起来有点傻的做法，有时候会比较难以发觉。比如：a[i] = a[j]，如果 $i$ 和 $j$ 相等，就是“自我赋值”的经典场景了。 所以，我们需要一个尽量完备的赋值操作符函数🤔。 考虑如下类MapWidget，内有数据裸指针BitMap *pb_，在赋值时同时考虑异常安全和 “自我赋值” 安全(认同测试保障自我赋值安全)，是一个相对不错的实现。但是，认同测试会降低运行效率，根据实际工程实践情况(自我赋值概率极低 )可以酌情去掉。 class BitMap {/*省略类声明\u0026实现*/}; class MapWidget { private: BitMap * pb_ = nullptr; public: explicit MapWidget(BitMap *pb) :pb_(pb) {} MapWidget\u0026 operator=(const MapWidget\u0026 rhs) { if (this == \u0026rhs) return *this; //这一句为认同测试(identity test) BitMap *pOrig = pb_;//不要一上来就delete，而是保存this-\u003epb_ pb_ = new BitMap(*rhs.pb_);//因为这一句可能抛异常 delete pOrig; return *this; } }; Copy and Swap技术 上文中保障异常安全和 “自我赋值” 安全的技术手段，另外一个办法，就是Copy and Swap技术。这个技术的关键在于“修改对象数据的副本，然后在一个不抛异常的函数中将修改的数据和原件置换 ”。 void MapWidget::Swap(MapWidget\u0026 rhs){std::swap(rhs.pb_,pb_);} MapWidget\u0026 MapWidget::operator=(const MapWidget\u0026 rhs) { MapWidget temp(rhs); Swap(temp); return *this; } ","date":"2021-12-12","objectID":"/2021/12/6_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/:3:7","tags":["C++","程序设计"],"title":"Effective C++(第三版)学习总结(一)","uri":"/2021/12/6_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/"},{"categories":["C++"],"content":"R12 复制对象时别忘记其每一个成分 编写类的Copying函数时需要做到2点 这里的Copying函数是指有copy属性的特殊函数==\u003e copy构造函数和copy赋值操作符。 复制所有Local成员变量 如果成员复制的时候有遗漏，编译器并不会有怨言，这就埋下了隐患。如果新增了成员，要对应修改Copying函数。 调用所有Base-Class内部的适当的Copy函数 具体代码的推荐实现 如下👇： class Customer { public: Customer(std::string name, float money):name_(name),money_(money) {} private: std::string name_; float money_; }; class VipCustomer :public Customer { public: //注意：派生类要复制基类那部分的成员变量 using Customer::Customer; //参考R09 VipCustomer(const VipCustomer\u0026 rhs) :priority_(rhs.priority_),Customer(rhs){} VipCustomer\u0026 operator=(const VipCustomer\u0026 rhs){ Customer::operator=(rhs); priority_ = rhs.priority_; return *this; } void setPriority(int priority) { priority_ = priority; }; private: int priority_;//子类独有成员可以单独set函数赋值，或者构造函数初始化列表赋值 }; 不要用一个Copying函数去实现另一个 令copy-assignment操作符调用copy构造函数是不合理的；反之，后者调用前者也是无意义的。 如果2者有大量的代码是相同的，可以剥离一个类内private类型的init函数出来，提供给上述2者调用。 ","date":"2021-12-12","objectID":"/2021/12/6_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/:3:8","tags":["C++","程序设计"],"title":"Effective C++(第三版)学习总结(一)","uri":"/2021/12/6_effective-c-%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/"}]