[{"categories":["计算机图形学"],"content":"摘要：Fundamentals of Computer Graphics第四版，原书第2章Miscellaneous Math的总结","date":"2021-12-27","objectID":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/","tags":["图形学基础","图形渲染"],"title":"Fundamentals of Computer Graphics学习总结_第2章(杂项数学)","uri":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":" 序言：看原书第二章后做的笔记，关键术语留有英文注解, 有些内容补充了自己的理解，并非直接翻译原文。 本人水平有限，若有不当之处，欢迎交流与指正，谢谢。 原书第四版pdf下载链接：Github: t4world/Computer-Graphics Markdown 数学公式语法参考: Cmd Markdown 公式指导手册 1 集合与映射 通常，我们所指的函数是映射(mapping)的一种特殊情况。映射是集合A到集合B的一种对应关系。 笛卡尔积(Cartesian product)$A$x$B$是2个集合的元素的所有可能组合，即a$\\epsilon$A, b$\\epsilon$B,对所有可能的有序组合(a,b)。$A$ x $A$简写为$A^2$,以下常用符号： 符号 意义 $R$ 实数 $R^+$ 非负实数 $R^2$ 2维实数平面 $R^n$ n维实数笛卡尔空间 $Z$ 整数 $S^2$ 3D单位球面上的点 映射的表示方法 使用冒号和箭头,举例: $f: R \\rightarrow Z$ 其中前者为定义域(domain),后者为值域(target). 从编程语言的角度来看，也可以认为是 参数为$R$，返回值为$Z$。 ","date":"2021-12-27","objectID":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:0:0","tags":["图形学基础","图形渲染"],"title":"Fundamentals of Computer Graphics学习总结_第2章(杂项数学)","uri":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"1.1 逆映射 通常所说的反函数是一种逆映射。 对于一个映射 $f: A \\rightarrow B$,那么可能存在逆映射 $f^{-1} : B \\rightarrow A$. 即 对于 $b = f(a)$,有$f^{-1}(b)=a$. 存在逆映射的条件是： 对每一个b$\\epsilon$B,存在唯一确定的$a\\epsilon A$满足$f(a)=b$. 若在满足逆映射的条件下，此时f是函数，(即 对每一个a$\\epsilon$A,有唯一确定的b=f(a)),此时这种特殊的映射关系称为双射(bijection), $f$和$f^{-1}$互为反函数，值域和定义域对调。 反函数例子: f: R $\\rightarrow$ R,函数f(x)=$x^3$ ,反函数$f^{-1}(x)=\\sqrt[3]x$ ","date":"2021-12-27","objectID":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:1:0","tags":["图形学基础","图形渲染"],"title":"Fundamentals of Computer Graphics学习总结_第2章(杂项数学)","uri":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"1.2 区间 关于是否包含区间边界值，分为开区间和闭区间以及半开区间。 涉及到图形的表示，注意，例如表示一个单位立方体的3D区间，立方体内的点$x$可以表示为$x \\epsilon [0,1]^3$. 区间还有个方便之处，区间运算，并集(union,符号$\\cup$)，交集(intersection,符号$\\cap$)，差集(difference,符号-)等。 ","date":"2021-12-27","objectID":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:2:0","tags":["图形学基础","图形渲染"],"title":"Fundamentals of Computer Graphics学习总结_第2章(杂项数学)","uri":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"1.3 对数 对数是相对于指数关系而生的，针对一个底数a，求它的多少次方为x. 表现形式如下： $$y = \\log_a x \\iff a^y = x $$ 复习几个常用的公式： $a^{\\log_a (x )} = x$ $\\log_a {(a^x)} = x$ $\\log_a (xy) = \\log_a x +\\log_a y$ $\\log_a (x /y) = \\log_a x - \\log_a y$ $\\log_a x = \\log_a b \\cdot \\log_b x$ 有个特殊的底数为$e=2.718…$,用它作底数，那么对数形式则会简写为： $$\\ln x \\equiv \\log_e x$$ 它和指数函数的导数形式分别如下： $\\frac {d}{dx} \\log_a{x}=\\frac{1}{x\\ln a}$ $\\frac {d}{dx} a^{x} =a^x \\ln a$ $\\text{上述公式当a = e 时}, \\ln a = 1.$ 2 求解二次方程 复习一下初中数学知识, 一元二次方程的一般形式： $$Ax^2 + Bx + C = 0,$$ 求根判别式(discriminant)为 $\\Delta = B^2 - 4 \\cdot A \\cdot C$，有三种情况: $\\Delta\u003c0:$ 方程没有根 $\\Delta=0:$ 方程只有一个根, $x_0 =x_1 =\\frac{-B}{2A}$ $\\Delta\u003e0:$ 方程有2个根, $x_0= \\frac{-B+\\sqrt{\\Delta}}{2 \\cdot A} , x_1= \\frac{-B-\\sqrt{\\Delta}}{2 \\cdot A}$ 个人经验：注意, 开方和除法开销昂贵，图形学中为了简化运算，提倡对$x_0,x_1$ ,做简化： $\\text{令 }\\Delta _2 = {(\\frac{B}{2})}^2- A \\cdot C$ , 则 $x_0= \\frac{-(\\frac{B}{2})+\\sqrt{\\Delta _2}}{A} , x_1= \\frac{-(\\frac{B}{2})-\\sqrt{\\Delta _2}}{A}$ 3 三角学 ","date":"2021-12-27","objectID":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:3:0","tags":["图形学基础","图形渲染"],"title":"Fundamentals of Computer Graphics学习总结_第2章(杂项数学)","uri":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"3.1 角度 如下图所示，角度由2条射线(half-line)组成,射线将圆分成了2段弧(arc)，弧线长度即为角度大小,角度有正负之分,逆时针方向为正(counterclockwise)，图中的角度 $\\Phi$ 即为短的那段弧。按照这样的定义，角度值的取值范围为$[-\\pi , \\pi]$ 角度制(degrees)和弧度制(radians)的转换，因为整圆是$360^\\circ$,也是弧度制的$2\\pi$, 所以角度转换如下： $$degrees = \\frac{180}{\\pi} \\cdot radians$$ ","date":"2021-12-27","objectID":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:4:0","tags":["图形学基础","图形渲染"],"title":"Fundamentals of Computer Graphics学习总结_第2章(杂项数学)","uri":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"3.2 三角函数 说起三角函数，先复习勾股定理(也叫毕达哥拉斯定理，$Pythagorean-theorem$),如下图所示，简单的证明了斜边(hypotenuse)平方为2条直角边的平方和。 $$a^2 + o^2 = h^2,$$ 由此定义了正弦(sine),反正弦(arc sine),余弦(cosine),反余弦(arc cosine),正切(tangent),反正切(arc tangent). $\\sin \\Phi = o/ h$ $\\csc \\Phi = h/ o$ $\\cos \\Phi = a/h$ $\\sec \\Phi = h/a$ $\\tan \\Phi = o/a$ $\\cot \\Phi = a/o$ 涉及到图形学中的方位角(直角坐标和极坐标的映射)，有个实用的函数$atan2$,它比$atan$的数值更稳定,且值域更广，对于一个笛卡尔(Cartesian)直角坐标$(x,y)$如下所示： $$ atan2(y,x)= \\begin{cases} arctan(\\frac {y}{x}), \u0026 \\text { x \u003e 0} \\\\ arctan(\\frac {y}{x}) + \\pi, \u0026 \\text{ $y \\geq 0$,x\u003c0} \\\\ arctan(\\frac {y}{x}) - \\pi, \u0026 \\text{ y \u003c 0,x\u003c0} \\\\ +\\frac{ \\pi}{2}, \u0026 \\text{ y \u003e 0,x=0} \\\\ -\\frac{ \\pi}{2}, \u0026 \\text{ y \u003c 0,x=0} \\\\ undefined, \u0026 \\text{ y = 0,x=0} \\end{cases} $$ 以上的函数定义域和值域如下： $asin : [-1,1] \\mapsto[- \\pi / 2, \\pi /2];$ $acos: [-1,1] \\mapsto[0,\\pi];$ $atan:R \\mapsto[-\\pi/2,\\pi/2];$ $atan2: R^2 \\mapsto [-\\pi, \\pi]$ ","date":"2021-12-27","objectID":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:5:0","tags":["图形学基础","图形渲染"],"title":"Fundamentals of Computer Graphics学习总结_第2章(杂项数学)","uri":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"3.3 一些有用的特性 角度平移特性(高中数学老师说过,\"奇变偶不变，符号看象限\") $\\sin(-A) = - \\sin A$ $\\cos(-A) = \\cos A$ $\\tan(-A) = - \\tan A$ $\\sin(\\frac {\\pi} {2} - A) =\\cos A$ $\\cos(\\frac {\\pi} {2} -A) = \\sin A$ $\\tan(\\frac {\\pi} {2} -A) = \\cot A$ 勾股定理推导特性 ${\\sin}^2 A +{\\cos}^2 A=1$ ${\\sec}^2 A -{\\tan}^2 A=1$ ${\\csc}^2 A -{\\cot}^2 A=1$ 加减特性 $\\sin(A +B )=\\sin A \\cos B + \\sin B \\cos A$ $\\sin(A -B )=\\sin A \\cos B - \\sin B \\cos A$ $\\cos(A +B )=\\cos A \\cos B - \\sin A \\sin B$ $\\cos(A -B )=\\cos A \\cos B + \\sin A \\sin B$ $\\tan (A+B) =\\frac{\\tan A + \\tan B}{1- \\tan A \\tan B}$ $\\tan (A-B) =\\frac{\\tan A - \\tan B}{1+ \\tan A \\tan B}$ $\\sin (2A) = 2 \\sin A \\cos A$ $\\cos (2A) = \\cos ^2 A -\\sin ^2 A$ $\\tan (2A) =\\frac {2 \\tan A}{1 -\\tan ^2 A}$ 半角特性 $\\sin ^2 (\\frac{A}{2})=(1- \\cos A)/2$ $\\cos ^2 (\\frac{A}{2}) =(1+\\cos A)/2$ 积化和差 $\\sin A \\sin B = -\\frac {\\cos (A+B) -\\cos (A-B)}{2}$ $\\sin A \\cos B = \\frac {\\sin (A+B) +\\sin (A-B)}{2}$ $\\cos A \\cos B = \\frac {\\cos (A+B)+\\cos (A-B)}{2}$ 三角形特性 对于任意三角形，假设边长为$a,b,c$,三条边的对角分别为$A,B,C$，那么有以下等式： $$\\frac{\\sin A}{a} =\\frac{\\sin B}{b} =\\frac{\\sin C}{c} \\text{ (正弦定理)}$$ $$c^2 = a^2 + b^2 - 2 \\cdot a \\cdot b \\cdot \\cos C \\text{ (余弦定理)}$$ $$\\frac{a+b}{a-b} = \\frac{\\tan(\\frac{A+B}{2})}{\\tan(\\frac{A-B}{2})} \\text{ (正切定理)}$$ $$S_ \\Delta = \\frac {1}{4} \\sqrt {(a+b+c)(-a+b+c)(a-b+c)(a-b+c)(a+b-c)} \\text{ (海伦－秦九韶面积公式)}$$ $$\\text{或者，令} p = \\frac{a+b+c}{2} , S_ \\Delta = \\sqrt {p(p-a)(p-b)(p-c)}$$ 4 向量 向量，也称为矢量，通常表示为一段特定长度和特定方向的箭头$\\rightarrow$。通常，不会用来表示坐标或位置，而是偏移(offset)或者位移(displacement). ","date":"2021-12-27","objectID":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:6:0","tags":["图形学基础","图形渲染"],"title":"Fundamentals of Computer Graphics学习总结_第2章(杂项数学)","uri":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"4.1 向量运算 向量加减运算符合平行四边形原则(parallelogram rule),向量加减满足交换律(commutative property),即 $\\vec {a} + \\vec {b} = \\vec {b} + \\vec {a}$ . 向量乘法有多种形式，其中，如果$\\vec {a}$与数字$k$相乘，$k$为正数则方向不变，$k$为负数则方向相反，长度则乘以$k$的绝对值.例如 $3.5 \\vec{a}$,表示方向不变，长度变为原来的3.5倍. ","date":"2021-12-27","objectID":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:7:0","tags":["图形学基础","图形渲染"],"title":"Fundamentals of Computer Graphics学习总结_第2章(杂项数学)","uri":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"4.2 直角坐标下的向量 对于一个二维向量$\\vec {c}$，可以由任意2个不平行的基础向量组合而成： $$\\vec {c} = w_a \\vec{a} + w_b \\vec{b} ,\\text{($w_a$,$w_b$是唯一一组常数解)}$$ 那么，如果让这2个基础向量为直角坐标系的横轴$x$和纵轴$y$两个方向上的单位向量,则向量$\\vec{a}$表示为： $$\\vec a =x_a \\vec{x} + y_a \\vec{y}$$ 通常为了方便，也会直接用直角坐标$(x_a,y_a)$表示这个向量，或者使用一个列矩阵，$\\vec a =\\begin{bmatrix} x_a \\\\ y_a \\end{bmatrix}$, 为了书写和印刷方便，也会直接写为它的转置形式 ${\\vec a} ^ T=\\begin{bmatrix} x_a \u0026 y_a \\end{bmatrix}$ . ","date":"2021-12-27","objectID":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:8:0","tags":["图形学基础","图形渲染"],"title":"Fundamentals of Computer Graphics学习总结_第2章(杂项数学)","uri":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"4.3 点乘 向量点乘得到的为标量积,向量$\\vec{a}$和$\\vec{b}$的点乘为两个向量的长度相乘，再乘以夹角$\\Phi$的余弦值。表示为： $$\\vec{a} \\cdot \\vec{b} =\\lVert a \\rVert \\cdot \\lVert b \\rVert \\cdot \\cos \\Phi$$ 常用：用于计算2个向量的夹角余弦值，进而推算夹角大小。 向量点乘遵守结合律(associative property)和分配律(distributive property): $$\\vec {a} \\cdot \\vec {b} =\\vec{b} \\cdot \\vec{a}$$ $$\\vec {a} \\cdot (\\vec {b} + \\vec {c})=\\vec {a} \\cdot \\vec {b} +\\vec {a} \\cdot \\vec {c}$$ $$(k \\vec{a})\\cdot \\vec{b}=\\vec{a}\\cdot (k\\vec{b})=k\\vec{a}\\cdot \\vec{b}$$ 在直角坐标系下，假设有二维向量$\\vec{a}=(x_a,y_a)$和$\\vec{b}=(x_b,y_b)$，那么两者点乘结果为 $\\vec {a} \\cdot \\vec {b}=x_a x_b + y_a y_b$ . 类似地，如果是三维向量，那么: $\\vec {a} \\cdot \\vec {b}=x_a x_b + y_a y_b +z_a z_b$ ","date":"2021-12-27","objectID":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:9:0","tags":["图形学基础","图形渲染"],"title":"Fundamentals of Computer Graphics学习总结_第2章(杂项数学)","uri":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"4.4 叉乘 向量叉乘得到的为向量积，通常用于三维向量。 $\\vec{a} ,\\vec{b}$叉乘向量积的模长为这两个向量的模长相乘，再乘以夹角的正弦值,数值正好等于$\\vec{a} ,\\vec{b}$围成的平行四边形面积。 $$\\lVert \\vec{a} \\times \\vec{b} \\rVert=\\lVert \\vec{a} \\rVert \\lVert \\vec{b} \\rVert \\sin \\Phi ,\\text{(且方向同时垂直于$\\vec{a} ,\\vec{b}$)}$$ 下图为一个右手坐标系 定义$x,y,z$三轴的单位向量分别为： $$\\vec{x} =(1,0,0)$$ $$\\vec{y} =(0,1,0)$$ $$\\vec{z} =(0,0,1)$$ 那么$\\vec{x} \\times \\vec{y}$叉乘结果可以为人为规定为$+\\vec{z}$或$-\\vec{z}$,这里我们采用$+\\vec{z}$，则有： $$\\vec{x} \\times \\vec{y}=+\\vec{z}$$ $$\\vec{y} \\times \\vec{x}=-\\vec{z}$$ $$\\vec{y} \\times \\vec{z}=+\\vec{x}$$ $$\\vec{z} \\times \\vec{y}=-\\vec{x}$$ $$\\vec{z} \\times \\vec{x}=+\\vec{y}$$ $$\\vec{x} \\times \\vec{z}=-\\vec{y}$$ 对右手坐标系的解释：对于$\\vec {a} \\times \\vec{b}$,右手手掌与$\\vec{a}$平行，且四指向$\\vec{b}$弯曲，此时大拇指所指方向就是叉乘结果$\\vec {a} \\times \\vec{b}$的方向。 注意：常用的$x-y-z$直角坐标系为右手坐标系，即$\\vec{x} \\times \\vec{y}=+\\vec{z}$。 叉乘运算满足分配律，结合律(与常数)，但不满足交换律： $$\\vec{a} \\times (\\vec{b} + \\vec{c} ) = \\vec{a} \\times \\vec{b} + \\vec{a} \\times \\vec{c}$$ $$\\vec{a} \\times (k\\vec{b})=k(\\vec{a} \\times \\vec{b}) , \\text{ (常数可以提取出来)}$$ $$\\vec{a} \\times \\vec{b} = -(\\vec{b} \\times \\vec{a}), \\text{ (一交换则反向)}$$ 现在有向量$\\vec{a}=(x_a,y_a,z_a)$,或者表示为$\\vec{a}=x_a \\vec{x} + y_a \\vec{y} + z_a \\vec{z}$, 另一个向量 $\\vec{b} =(x_b, y_b, z_b)$, 那么： $$\\vec{a} \\times \\vec{b} =(x_a \\vec{x} + y_a \\vec{y} + z_a \\vec{z}) \\times( x_b \\vec{x} + y_b \\vec{y} + z_b \\vec{z})$$ $$=(y_a z_b - z_a y_b)\\vec{x} + (z_a x_b -x_a z_b)\\vec{y} +(x_a y_b - y_a x_b)\\vec{z}$$ 最终结果也可写作 $\\vec{a} \\times \\vec{b} =(y_a z_b - z_a y_b, z_a x_b -x_a z_b , x_a y_b - y_a x_b )$ . ","date":"2021-12-27","objectID":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:10:0","tags":["图形学基础","图形渲染"],"title":"Fundamentals of Computer Graphics学习总结_第2章(杂项数学)","uri":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"4.5 标准正交基与坐标系 标准正交基：在2D平面，有互相垂直的一组向量基 $\\vec{u} ,\\vec{v}$，且都为单位向量，即： $$\\lVert \\vec{u} \\rVert =\\lVert \\vec{v} \\rVert =1, \\text{and, }\\vec{u} \\cdot \\vec{v} =0$$ 如果是3D空间，则这组标准正交基$\\vec{u}, \\vec{v}, \\vec{w}$满足： $\\text{(1)} \\lVert \\vec{u} \\rVert =\\lVert \\vec{v} \\rVert =\\lVert \\vec{w} \\rVert =1$ $\\text{(2)} \\vec{u} \\cdot \\vec{v} =\\vec{v} \\cdot \\vec{w} =\\vec{w} \\cdot \\vec{u} =0$ $\\text{(3)} \\vec{w}=\\vec{u} \\times \\vec{v} \\text{ (右手坐标系)}$ 像这样的正交基 $\\vec{u} ,\\vec{v} , \\vec{w}$有无数组，我们通常默认选用直角坐标轴的单位向量$\\vec{x}, \\vec{y}, \\vec{z}$作为正交基，且原点为$O(0,0,0)$,这样的正则坐标系我们称为世界坐标系(world coordinate system)或全局坐标系(global coordinate system). 有一个物体坐标系$u-v-w$ ,该坐标系中有个向量$\\vec{a}$,如果要转换为在世界坐标系下的坐标,使用简单的点乘 即可得到，为 $u_a\\vec{u} +v_a\\vec{v} +w_a \\vec{w}$. ","date":"2021-12-27","objectID":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:11:0","tags":["图形学基础","图形渲染"],"title":"Fundamentals of Computer Graphics学习总结_第2章(杂项数学)","uri":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"4.6 单个向量构造向量基 设想较为常见的一种情形：给定一个向量$\\vec{a}$,我们希望能给出3个互相垂直的正交基$\\vec{u},\\vec{v},\\vec{w}$，要求$\\vec{w}$和$\\vec{a}$同向,并且不关注$\\vec{u},\\vec{v}$的具体指向。 分为3步： 取$\\vec{a}$的单位向量为$\\vec{w}$ ，即: $\\vec{w} =\\frac{\\vec{a}}{\\lVert \\vec{a} \\rVert}$ 任意取一个与$\\vec{w}$不共线的向量$\\vec{t}$, 两者叉乘后单位化得到$\\vec{u}$，即 : $\\vec{u}=\\frac{\\vec{t} \\times \\vec{w}}{\\lVert \\vec{t} \\times \\vec{w} \\rVert}$ 将上述得到的$\\vec{w} ,\\vec{u}$叉乘得到$\\vec{v}$ ，即: $\\vec{v} =\\vec{w} \\times \\vec{u}$ 书中提到这一场景适用于表面着色，因为法线方向很重要(垂直于表面),着色过程垂直于法线的表面向量无关紧要。 ","date":"2021-12-27","objectID":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:12:0","tags":["图形学基础","图形渲染"],"title":"Fundamentals of Computer Graphics学习总结_第2章(杂项数学)","uri":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"4.7 由两个向量构建向量基 在某些场景需要用2个不共线向量来构建坐标系，比如给定2个互相垂直(perpendicular)的向量$\\vec{a}$(指定$\\vec{w}$) ,$\\vec{b}$(指定$\\vec{v}$),则直接叉乘得到第三个向量基$\\vec{u}=\\vec{b} \\times \\vec{a}.$ 或者，给定的$\\vec{a},\\vec{b}$并不是完全垂直，而是近似垂直,比如成$80^\\circ$角，采用上一节的方法也可以得到最接近的解： $\\vec{w} =\\frac{\\vec{a}}{\\lVert \\vec{a} \\rVert}$, $\\vec{u}=\\frac{\\vec{b} \\times \\vec{w}}{\\lVert \\vec{b} \\times \\vec{w} \\rVert}$, $\\vec{v} =\\vec{w} \\times \\vec{u} \\text{ ,(向量} \\vec{v} \\text{ 很接近} \\vec{b})$ . 获得图形学中相机的Look-At 矩阵/向量也可以采用这一方法，向量$\\overrightarrow {direction}$是确定的$from$点到$to$点的向量，而$up$向量和$right$向量就看自己选择了(可以指定Right向量，再来确定Up向量)，这一点在LearnOpenGL-CN中的Camera章节有相关内容。 ","date":"2021-12-27","objectID":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:13:0","tags":["图形学基础","图形渲染"],"title":"Fundamentals of Computer Graphics学习总结_第2章(杂项数学)","uri":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"4.8 摆正向量基 某些场景下可能遇到这样的问题，由于浮点计算精度或者数据保存读取等原因，造成向量基精度丢失，向量基之间不再那么垂直，如何修正是个问题： 可以这样做：基于已有的$\\vec{w}, \\vec{v}$得到新的$\\vec{u}$,然后再计算$\\vec{u}$. 虽然得到了精确垂直的新向量基，但是，这并非最好的办法，因为新的向量基$\\vec{w}, \\vec{v},\\vec{u}$和原向量基之间，这3者的误差是不对等的, $\\vec{w}$误差最小，$\\vec{u}$误差最大。 在本书的第五章第5.4.1 节的奇异值分解可以很好的解决这一问题。 5 曲线与面 ","date":"2021-12-27","objectID":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:14:0","tags":["图形学基础","图形渲染"],"title":"Fundamentals of Computer Graphics学习总结_第2章(杂项数学)","uri":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"5.1 2D隐式曲线 先理解一下“隐式”:在我看来，隐式曲线就是隐函数来表示的曲线。隐函数，就是没法用$y=f(x)$来干净清晰的表示函数关系，而是转而使用类似方程$f(x,y)=0$的形式(例如开普勒方程$y-x-\\epsilon \\sin y=0$,$\\epsilon$为常熟)。 为人所熟知的隐式曲线必然是圆了，圆方程$f(x,y)=(x-x_c)^2 + (y-y_c)^2 -r^2$描绘了以$(x_c,y_c)$为圆心，$r$为半径的圆. 对任意的点$(x,y)$值，都可以计算出$f(x,y)$的值，则有： 点在圆内：$f(x,y)\u003c0$; 点在圆曲线上：$f(x,y)=0$; 点在圆外：$f(x,y)\u003e0$; 从向量的角度理解，可以认为圆心$c$,圆上的点为$p$, 则向量$\\overrightarrow{cp}$模长正好为圆半径$r$，即:$\\lVert \\overrightarrow{cp} \\rVert =r$。 从向量的角度来表示，比原来$x,y,z$之类的坐标表示更易懂，更能体现几何关系，也更不容易在写代码时犯错，尽可能用向量的形式来表示隐式关系。 ","date":"2021-12-27","objectID":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:15:0","tags":["图形学基础","图形渲染"],"title":"Fundamentals of Computer Graphics学习总结_第2章(杂项数学)","uri":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"5.2 2D梯度 假设函数$f(x,y)$是高度场的函数$height=f(x,y)$,那么梯度向量所指的方向就是指向上坡最陡的方向,或者说函数值增长最快的方向。一般是以偏微分的形式 $\\nabla f(x,y)$ 给出： $$\\nabla f(x,y)=(\\frac {\\partial f} {\\partial x} \\text{ ，} \\frac {\\partial f} {\\partial y} ) .$$ so，偏微分复习：$\\frac {\\partial f} {\\partial x} = lim_{\\Delta x \\to 0} \\frac{f(x+\\Delta x , y) - f(x,y)}{\\Delta x}$ 原文图注解：A surface height = f(x,y) is locally planar near(x,y) = (a,b). The gradient is a projection of the uphill direction onto the height = 0 plane. 如上图，对于二维曲线$f(x,y)=0$的点$p(x,y)$,则此时梯度向量垂直于该点的切向量，梯度向量此时为法线向量。 换句话说，把二维曲线$f(x,y)=0$看作是三维曲面$f(x,y)=h$ 被$xoy$水平面截出的等高线，这样上山的最陡路径投影在平面上，正好就是二维曲线的法向方向. 关于这一点，有位知乎答主做了很好的图文并茂的解释，深入理解可以移步$\\implies$ 知乎: 形象理解“梯度”与“法向量”的关系 另外，因为梯度指向了上坡方向(uphill),所以指向的是$f(x,y)\u003e0$的区域。 那么，为什么梯度和偏微分有关系呢？下图中，假设在很微小的一个区域，$height=f(x,y)$是一块平面，且向量$\\vec{a}$在这个$f$不变的区域移动了一小段距离，即$\\vec{a}=(\\Delta x,\\Delta y)$.因为上坡方向(uphill)垂直于向量$\\vec{a}$,即点积为0： $$(\\nabla f)\\cdot \\vec{a} \\equiv (x_\\nabla,y_\\nabla)\\cdot(x_a,y_a)=x_\\nabla \\Delta x + y_\\nabla \\Delta y=0 \\text{, (式2.5.2-a) }$$ 同样地，我们知道$f$的值没有改变，即$\\Delta f=0$: $$\\Delta f = \\frac {\\partial f} {\\partial x} \\Delta x + \\frac {\\partial f} {\\partial y} \\Delta y= \\frac {\\partial f} {\\partial x} x_a + \\frac {\\partial f} {\\partial y} y_a =0$$ 回顾向量知识，如果$(x,y)$ 和 $(x',y')$垂直，则$xx'+yy'=0$，(x',y')可以取值$(y,-x)$. 那么: $$(x_a,y_a)=k(\\frac{\\partial f}{\\partial y} , - \\frac{\\partial f}{\\partial x}) \\text{, (式2.5.2-b) }$$ 根据式子2.5.2-a和2.5.2-b，可以得出: $$(x_\\nabla, y_\\nabla) = m(\\frac{\\partial f}{\\partial x} , \\frac{\\partial f}{\\partial y}) \\text{, (式2.5.2-c) }$$ 通常取k\u003e0,且m=1. 隐式2D直线(implicit 2D lines) 考虑使用隐函数形式表达一条直线：$Ax+By+C=0$,这种一般形式包含了垂直于$x$轴没有斜率的情况。假设直线上存在两个不同的点$(x_0,y_0), (x_1,y_1)$，则: $$\\begin{cases} Ax_0 + By_0+C =0 \\\\ Ax_1 + By_1+C =0\\\\ \\end{cases}$$ 很明显，这是个不定方程。 梯度为$\\nabla f=(A,B)$, 又因为 $\\nabla f$垂直于$(\\Delta x, \\Delta y)$, 则与 (式2.5.2-c)同理，可以令$\\nabla f=(y_0 -y_1,x_1-x_0)$. 替换A，B，则有： $$(y_0 - y_1)x + (x_1 - x_0)y +C =0 \\text{, (式2.5.2-d)}$$ 对于(式2.5.2-d)，代入$(x_0,y_0)$，则有$C=x_0y_1 - x_1y_0$: $$(y_0 - y_1)x + (x_1 - x_0)y + x_0y_1 - x_1y_0=0$$ 那么写成\"斜率-截距式\"(slope-intercept): $$y =\\frac{y_1 -y_0}{x_1-x_0}x + \\frac{x_1y_0 - x_0y_1}{x_1-x_0}$$ 关于隐式表达式的另外一个有趣的属性是可以用来推算点到直线的有向距离，如下图，平行于直线的$f(x,y)$分布于$\\pm$两侧。 直线之间的距离为梯度的长度，而梯度为k(A,B)，距离则为： $$distance =k \\sqrt{A^2 + B^2}\\text{, (式2.5.2-e)}$$ $Ax + By+C =0$直线上的点$(x_0,y_0)$,则该点的梯度方向有某点$(a,b)=(x_0,y_0)+k(A,B)$,带入计算： $$f(a,b)=f(x_0+kA,y_0+kB)=k(A^2 +B^2)\\text{, (式2.5.2-f)}$$ 综合 (式2.5.2-e), (式2.5.2-f)可知，点$(a,b)$到直线$Ax + By+C =0$的距离： $$distance=\\frac{f(a,b)}{\\sqrt{A^2 + B^2}}$$ 隐式二次曲线(implicit quadric curves) 对于隐式的2D二次曲线，一般形式可以写作如下： $$Ax^2 + Bxy + Cy^2 +Dx + Ey +F =0$$ 该形式包含了椭圆(ellipse)，双曲线(hyperbola)，抛物线(parabola). ","date":"2021-12-27","objectID":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:16:0","tags":["图形学基础","图形渲染"],"title":"Fundamentals of Computer Graphics学习总结_第2章(杂项数学)","uri":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"5.3 3D隐式曲面 和2D隐式曲线类似，3D隐式曲面的表达式记作： $$f(x,y,z)=0.$$ 对曲面上任意点$p(x,y,z)$，有$f(p)=0$. ","date":"2021-12-27","objectID":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:17:0","tags":["图形学基础","图形渲染"],"title":"Fundamentals of Computer Graphics学习总结_第2章(杂项数学)","uri":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"5.4 隐式曲面的表面法线 和2D隐式曲线类似，3D隐式曲面上某点$p(x,y,z)$的法线正好就是该点的梯度: $$\\vec{n}=\\nabla f(p)=(\\frac {\\partial f(p)}{\\partial x}, \\frac {\\partial f(p)}{\\partial y} ,\\frac {\\partial f(p)}{\\partial z})$$ 并且法线$\\vec n$指向的方向为$f(q)\u003e0$的方向(点$q$不在曲面上). 需要注意的是，$f(p)=0$和$-f(p)=0$虽然描述的是同一个曲面，但是法线/梯度方向正好相反：$-\\nabla f(p) =\\nabla(-f(p))$. ","date":"2021-12-27","objectID":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:18:0","tags":["图形学基础","图形渲染"],"title":"Fundamentals of Computer Graphics学习总结_第2章(杂项数学)","uri":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"5.5 隐式平面 平面可以由一个已知的点$a$和已知的法线$\\vec n$来描述 对于平面上任意点$p$： $$(p-a) \\cdot \\vec n=0$$ 平面也可以由3个已知的点$a,b,c$来确定 法线可以通过叉乘得到$\\vec n=(b-a)\\times (c-a)$，对于平面上任意点$p$： $$(p-a)\\cdot ((b-a)\\times (c-a))=0$$ 写成行列式(determinant)则如下： $$\\begin{vmatrix} { x-x_a} \u0026 {y-y_a} \u0026 {z-z_a} \\\\ {x_b-x_a} \u0026 {y_b-y_a} \u0026 {z_b-z_a} \\\\ { x_c-x_a} \u0026 {y_c-y_a} \u0026 {z_c-z_a} \\\\ \\end{vmatrix}=0$$ 3D二次曲面(3D quadric surfaces) 2D曲线可以用二元二次多项式$(x,y)$来表示，类似地，3D曲面可以用三元二次多项式$(x,y,z)$来表示。 对于一个球面： $$f(p)=(p-c)^2-r^2 =0$$ 对于一个椭球面(ellipsoid)： $$f(p)= \\frac{(x-x_c)^2}{a^2} + \\frac{(y-y_c)^2}{b^2} +\\frac{(z-z_c)^2}{c^2} -1=0$$ 由曲面构建曲线(3D curves from implicit surfaces) 如果2个曲面相交，则得到了相交位置的曲线，该曲线的点$p$同时满足： $$ \\begin{cases} f(p)=0 ,\\\\ g(p)=0 .\\\\ \\end{cases}$$ ","date":"2021-12-27","objectID":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:19:0","tags":["图形学基础","图形渲染"],"title":"Fundamentals of Computer Graphics学习总结_第2章(杂项数学)","uri":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"5.6 带参数的2D曲线 带参数的函数：是指自变量$x$和因变量$y$都采用参数$t$表达，点$(x,y)$的位置由$t$来决定，即： $$\\begin{bmatrix} x \\\\ y \\end{bmatrix} =\\begin{bmatrix} g(t) \\\\ h(t) \\end{bmatrix}.$$ 当$t$在连续的改变时，连续函数$g(t),h(t)$也在改变,即点$p(x,y)$在曲线上\"移动\"了,$t$可以看作是时间，不同$t$区间的(x,y)变化幅度不同，点移动时就会有\"速度\"的概念。 带参数函数只看变量$t$的这一特性，给相关的程序编写也带来了很大的便利，只有一个函数入参，Cool. 带参数的2D直线(2D parametric lines) 2D直线上有2个已知的点$p_0(x_0,y_0),p_1(x_1,y_1)$,那么该直线可表示为： $$\\begin{bmatrix} x \\\\ y \\end{bmatrix} =\\begin{bmatrix} x_0+t(x_1-x_0) \\\\ y_0+t(y_1-y_0) \\end{bmatrix}.$$ 或者采用向量的概念：$p(t)=p_0+t(p_1-p_0)$ 如上图，从几何角度理解为“从p0出发前往p1,具体位置由参数t决定”,且$p(0)=p_0,p(1)=p_1$。所以基于这一点，直线可以表示为从一个定点$origin$出发,移动$t$个单位向量$\\vec u$，即： $$p(t)=origin + t \\cdot \\vec u$$ 而这种表示方法，在光线追踪计算时是表示一条光线的绝佳形式。 带参数的2D圆(2D parametric circles) 一个以$(x_c,y_c)$为圆心,$r$为半径的圆，带参数形式可以写作： $$\\begin{bmatrix} x \\\\ y \\end{bmatrix} =\\begin{bmatrix} x_c+ r \\cos \\Phi \\\\ y_c+ r \\sin \\Phi \\end{bmatrix}. \\text{ (其中$\\Phi \\in [0,2 \\pi)$)}$$ 而一个以$(x_c,y_c)$为椭圆中心,$a,b$为长轴、短轴的椭圆，带参数形式可以写作： $$\\begin{bmatrix} x \\\\ y \\end{bmatrix} =\\begin{bmatrix} x_c+ a \\cos \\Phi \\\\ y_c+ b \\sin \\Phi \\end{bmatrix}. \\text{ (其中$\\Phi \\in [0,2 \\pi)$)}$$ ","date":"2021-12-27","objectID":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:20:0","tags":["图形学基础","图形渲染"],"title":"Fundamentals of Computer Graphics学习总结_第2章(杂项数学)","uri":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"5.7 带参数的3D曲线 带参数的3D曲线形式如下： $$\\begin{cases} x=f(t) \\\\ y=g(t) \\\\ z=h(t) \\\\ \\end{cases}$$ 例如，绕$z$轴的螺旋线如下： $$\\begin{cases} x= \\cos t \\\\ y= \\sin t \\\\ z= t \\\\ \\end{cases}$$ 本章只阐述3D直线，不详细阐述3D曲线，而是在本书的第15章(Chapter15.Curves)详细阐述。 带参数的3D直线(3D parametric lines) 带参数的3D直线可以记作向量的形式，举例如下： $$\\begin{cases} x= 2+7t \\\\ y= 1+2 t \\\\ z= 3-5t\\\\ \\end{cases} \\quad \\text{向量形式$\\implies$} \\begin{cases} origin=(2,1,3)\\\\ \\overrightarrow {dircetion}= (7,2,-5) \\\\ position = origin + t \\cdot \\overrightarrow {dircetion} \\\\ \\end{cases}$$ ","date":"2021-12-27","objectID":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:21:0","tags":["图形学基础","图形渲染"],"title":"Fundamentals of Computer Graphics学习总结_第2章(杂项数学)","uri":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"5.8 带参数的3D曲面 不同于2D曲面，只有一个参数$t$,3D曲面需要2个参数$u,v$，$x,y,z$都可以表示为$(u,v)$有关的带参数形式： $$\\begin{cases} x= f(u,v) \\\\ z= h(u,v) \\\\ \\end{cases} \\quad \\text{向量形式$\\implies$} \\begin{bmatrix} x \\\\ y \\\\ z \\end{bmatrix}=p(u,v)$$ 举例：对于一个球面，给定的已知半径$r$，由经度角$\\phi$，纬度角$\\theta$这2个角度变化确认球面任意点： $$\\begin{cases} x= r \\cos \\phi \\sin \\theta \\\\ y= r \\sin \\phi \\sin \\theta \\\\ z= r \\cos \\theta \\\\ \\end{cases} \\quad \\text {可以反推} \\begin{cases} \\theta= arccos(z / \\sqrt{x^2 + y^2 +z^2}) \\\\ \\phi = atan2(y,x) \\\\ \\end{cases}$$ 考虑一下曲面的法线呢？ 首先定义函数$q(t)=p(t,v_0)$，此函数u自由变化且v值固定为$v_0$,这就定义了在曲面上的一条曲线，也叫“等参曲线”。(下图采用自AutoDesk工具ALIAS介绍，意义相近) 则q的导数$q'$和曲面相切，$q'$为P的偏微分$P_u$，同样地，还可以得到第二条切线$P_v$，那么该点的法线$\\vec n$指向曲面外，且同时垂直于这2条曲面切线： $$\\vec n = \\overrightarrow P_u \\times \\overrightarrow P_v$$ 6 线性插值 线性插值可能是图形学中最为常见的思想和计算操作了，回顾我们之前的带参数的2D直线，$p(t)=p_0+t(p_1-p_0)$，即$p(t)=(1-t)\\cdot p_0+t \\cdot p_1$,其实可以认为是在点$p_0,p_1$之间线性插值，权重为$t$. 更通用的一种情形，有$n+1$个散点，对应的$x$坐标$x_0,x_1 … x_{n-1},x_n$,对应的y值为$y_0,y_1 … y_{n-1},y_n$,此时想得到一条连续的函数$f(x)$,就可以通过在相邻的散点插值得到： $$f(x)=y_i+\\frac{x-x_i}{x_{i+1}-x_i}(y_{i+1}-y_i) \\text {,(此时的$t=\\frac{x-x_i}{x_{i+1}-x_i}$)}$$ 7 三角形 无论是2D三角形还是3D三角形，都是各种图形学程序中的基础模型图元(modeling primitive)。比如三角形的Color图元，只有3个顶点(Vertex)有Color值，三角形内的其他值则通过插值方法得到，通常直接采用重心坐标插值(barycentric coordinates)。 本节将分别讨论2D和3D三角形。 ","date":"2021-12-27","objectID":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:22:0","tags":["图形学基础","图形渲染"],"title":"Fundamentals of Computer Graphics学习总结_第2章(杂项数学)","uri":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"7.1 2D三角形 对于一个2D三角形，三个顶点为$a,b,c$，则可以立马通过向量叉乘($S=\\frac {1}{2} \\vec{ab} \\times \\vec{ac}$)得到它的面积： $$S = \\frac {1}{2} \\left | \\begin{array}{ccc} x_b-x_a \u0026 x_c-x_a\\\\ y_b-y_a \u0026 y_c-y_a \\\\ \\end{array} \\right |= \\frac {1}{2}(x_a y_b+x_b y_c+x_c y_c-x_a y_c-x_b y_a-x_c y_b)$$ (该公式的推导可以参考本书章节$Chapter5.Linear Algebra-5.3$.注意,考虑到叉乘的方向性，$a,b,c$三个点要成逆时针排列，否则得到面积的相反数.) 三角形的坐标插值，基本原理还是来自于平行四边形规则的向量合成，即使2个向量不平行，同样可以作为向量基。 首先，对于三角形所在平面内的任意点$p$,满足： $$p=a+\\beta \\vec{ab} + \\gamma \\vec{ac}=a+\\beta (b-a) + \\gamma (c-a)=(1-\\beta -\\gamma)a+\\beta b+\\gamma c$$ 为方便计算书写，令$\\alpha \\equiv 1-\\beta -\\gamma$,则$p(\\alpha,\\beta,\\gamma)=\\alpha a + \\beta b +\\gamma c.$ 注意，点$p$位于三角形内部的充要条件为: $\\alpha, \\beta,\\gamma \\in (0,1)$. 回顾2.5.2节隐式2D直线的内容，平行于直线$f(x,y)=0$的其他直线的函数值$f(x,y)$大于或小于0，分布于$f(x,y)=0$的两侧。如下图所示，我们规定$f_{ac}(x,y)=0$,且点b所在平行线$f_{ac}(x,y)_{\\beta}=1$. 那么在线段$ab$上的点$(x,y)$，$\\beta$值为： $$\\beta=\\frac{f_{ac}(x,y)}{f_{ac}(x_b,y_b)}$$ 基于隐式2D直线章节的内容，ab直线可表示为： $f_{ab}(x,y)\\equiv (y_a -y_b)x +(x_b-x_a)y + x_a y_b -x_b y_a=0$. 则相对应的$\\gamma$值为： $$\\gamma =\\frac {(y_a -y_b)x +(x_b-x_a)y + x_a y_b -x_b y_a}{(y_a -y_b)x_c +(x_b-x_a)y_c + x_a y_b -x_b y_a}$$ 同理，可计算得到点b对应的$\\beta$值,最后$\\alpha=1-\\beta -\\gamma$. 值得注意的是，$\\alpha,\\beta,\\gamma$值表征的是$f(x,y)的值，隐式地表征$点p到各条边的距离，所以，点p和三个顶点行成的3个小三角形和大三角形的比值其实就是$\\alpha,\\beta,\\gamma$,即如下图所示： ","date":"2021-12-27","objectID":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:23:0","tags":["图形学基础","图形渲染"],"title":"Fundamentals of Computer Graphics学习总结_第2章(杂项数学)","uri":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"7.2 3D三角形 对于上一节得到的2D三角形插值公式完全适用于3D三角形$abc$,同样有： $$p=(1-\\beta -\\gamma)a+\\beta b+\\gamma c$$ 三角形$abc$，三条边对应3个比例$\\alpha,\\beta,\\gamma$,则对于三角形内任意点$p$: $$\\alpha =\\frac{Area_{pbc}}{Area_{abc}}=\\frac{\\lVert (c-b)\\times(p-b) \\rVert} {\\lVert (b-a)\\times(c-a) \\rVert}$$ 令$\\vec n=(b-a)\\times(c-a)$,$\\vec n_a =(c-b)\\times(p-b)$，因为两者平行且同向($\\vec n \\cdot \\vec n_a=||\\vec n|| \\cdot ||\\vec n_a||$),则上式可化简： {% raw %} $$\\alpha =\\frac{\\lVert \\vec n_a \\rVert}{\\lVert \\vec n \\rVert }= \\frac{\\lVert \\vec n_a \\rVert \\cdot \\lVert \\vec n \\rVert }{\\lVert \\vec n \\rVert \\cdot \\lVert \\vec n \\rVert } =\\frac{\\vec n \\cdot \\vec n_a }{{\\lVert \\vec n \\rVert }^2 }$$ {% endraw %} 同理可得$\\beta, \\gamma$的值： {% raw %} $$\\beta =\\frac{\\vec n \\cdot \\vec n_b}{{\\lVert \\vec n \\rVert}^2}$$ $$\\gamma =\\frac{\\vec n \\cdot \\vec n_c}{{\\lVert \\vec n \\rVert}^2}$$ {% endraw %} 其中，$n_b =(a-c)\\times(p-c)$，$n_c =(b-a)\\times(p-a)$. $$\\text{——————– Chapter2(完结) @2021-12-19 ——————–}$$ ","date":"2021-12-27","objectID":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/:24:0","tags":["图形学基础","图形渲染"],"title":"Fundamentals of Computer Graphics学习总结_第2章(杂项数学)","uri":"/2021/12/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93_%E7%AC%AC2%E7%AB%A0%E6%9D%82%E9%A1%B9%E6%95%B0%E5%AD%A6/"},{"categories":["计算机图形学"],"content":"摘要：Metal官方文档MetalGuide系列第三部分 -\u003e Metal有关的Shader着色器程序,以及MetalLib库文件的生成与使用","date":"2021-12-26","objectID":"/2021/12/4_metalguide-3-%E7%9D%80%E8%89%B2%E5%99%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%BA%93/","tags":["Metal","图形渲染"],"title":"MetalGuide(3)着色器程序与库","uri":"/2021/12/4_metalguide-3-%E7%9D%80%E8%89%B2%E5%99%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%BA%93/"},{"categories":["计算机图形学"],"content":"1 如何创建Metal库(MTLLibrary) Case A. 从已编译的代码中创建Library 为了提升性能，可以利用xcode工具在app的创建过程中就把Metal-Shader源代码编译打包到一个库文件中，如 此避免了在app的运行时编译着色程序代码的开销。从已编译的二进制库中创建一个MTLLibrary对象，可以使 用如下的MTLDevice方法 ： newDefaultLibrary : 会return一个MTLLibrary，包含了渲染shader和app所需的并行计算程序； newLibraryWithFile:error : 它将返回一个MTLLibrary对象，从指定的库文件路径加载这个库文 件中的所有shader程序； newLibraryWithData:error :它将返回一一个MTLLibrary对象，从指定的二进制数据块对象加载数据块中的所有shader程序. Case B. 从源代码中创建Library 从包含有Metal-Shader代码编写的多个着色程序的字符串中创建MTLLibrary对象，这些方法将在MTLLibrary对象创建时编译源代码，具体的可以参考如下 MTLDevice方法 ： newLibraryWithSource:options:error: 属于同步阻塞调用 ,它编译输入字符串里的源代码创建多个 MTLFunction对象，最后返回一个包含这些MTLFunction对象的MTLLibrary对象； newLibraryWithSource:options:completionHandler: 属于异步调用，和上一个方法不同的是多了参数代码block块—completionHandler，block将在MTLLibrary对象创建完成后被调用 . 2 MTLFunction细节探究 ​ 如何从Library中获取Function ，可以用下述方法进行获取： ​ newFunctionWithName: 属于MTLLibrary的方法, 返回一个名字为输入参数的MTLFunction对象。如果在library中没有 找到一个方法其修饰名字匹配输入参数，那么该函数返回nil。 ","date":"2021-12-26","objectID":"/2021/12/4_metalguide-3-%E7%9D%80%E8%89%B2%E5%99%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%BA%93/:0:0","tags":["Metal","图形渲染"],"title":"MetalGuide(3)着色器程序与库","uri":"/2021/12/4_metalguide-3-%E7%9D%80%E8%89%B2%E5%99%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%BA%93/"},{"categories":["计算机图形学"],"content":"2.1 在运行时决定Function的细节 ​ 一个MTLFunction对象被定义为图形shader程序或是并行计算程序，它的实质内容在这个对象被创建前 就编译好了，而且shader程序的源代码不能直接被app使用.不过，可以在运行时查询下面的MTLFunction属性： ","date":"2021-12-26","objectID":"/2021/12/4_metalguide-3-%E7%9D%80%E8%89%B2%E5%99%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%BA%93/:1:0","tags":["Metal","图形渲染"],"title":"MetalGuide(3)着色器程序与库","uri":"/2021/12/4_metalguide-3-%E7%9D%80%E8%89%B2%E5%99%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%BA%93/"},{"categories":["计算机图形学"],"content":"2.2 相关的Reflection对象 ​ MTLFunction不提供访问shader程序参数的方法。但在pipeline state创建过程中，可以获得用于展示shader程序参数细节reflection对象(根据command encoder的类型不同， reflection对象分为MTLRenderPipelineReflection类型或 MTLComputePipelineReflection类型 )。 ​ 一个reflection对象包含了一个MTLArgument数组，视其关联的Encoder不同而不同： MTLRenderPipelineReflection：关联MTLRenderCommandEncoder ,包含的Arguments数组有vertexArguments和fragmentArguments 这2个属性； MTLComputePipelineReflection ：关联MTLComputeCommandEncoder ，包含的Argument数组表征并行计算程序的参数。 ​ 不是所有的shader程序的参数都在reflection对象中表示，一个reflection对象仅包含那些引用了相应资源的参数，通 过shader修饰符[[stage_in]]、 [[vertex_id]]、 [[attribute_id]]修饰的参数不会被包含在reflection对象中。 ","date":"2021-12-26","objectID":"/2021/12/4_metalguide-3-%E7%9D%80%E8%89%B2%E5%99%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%BA%93/:2:0","tags":["Metal","图形渲染"],"title":"MetalGuide(3)着色器程序与库","uri":"/2021/12/4_metalguide-3-%E7%9D%80%E8%89%B2%E5%99%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%BA%93/"},{"categories":["计算机图形学"],"content":"2.3 MTLArgument对象 ​ MTLArgument类型对象表示一个shader程序方法的入参细节： ​ 上述的属性type还决定了哪些其他MTLArgument属性是相关的，type类型不同，相关的属性也有所区别： MTLArgumentTypeTexture : textureType属性表征纹理类型(可能为texture1d_array， texture2d_ms， texturecube); textureDataType属性表征其分量数据类型(可能为half， float， int， uint）; MTLArgumentTypeThreadgroupMemory : 说明threadgroupMemoryAlignment和 threadgroupMemoryDataSize这两个属性相关； MTLArgumentTypeBuffer : 说明bufferAlignment, bufferDataSize, bufferDataType, bufferStructType这几个属性相关 。 ​ 例如：如果bufferDataType的值是MTLDataTypeStruct ，那么bufferStructType属性含有一个MTLStructType类型的值 ,同时bufferDataSize属性表示这个结构体的长度 (bytes数量); 如果缓存Argument是数组，那么bufferDataType属性则表征的是数组元素的类型，同时bufferDataSize属性表示的也只是数组中一个元素的长度。 参考链接: Apple-Metal-Programming-Guide Metal’s Best Practice ","date":"2021-12-26","objectID":"/2021/12/4_metalguide-3-%E7%9D%80%E8%89%B2%E5%99%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%BA%93/:3:0","tags":["Metal","图形渲染"],"title":"MetalGuide(3)着色器程序与库","uri":"/2021/12/4_metalguide-3-%E7%9D%80%E8%89%B2%E5%99%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%BA%93/"},{"categories":null,"content":"经历 专业打杂😉，焊过板子，写过嵌入式C和Qt桌面应用，也调过一些视觉算法API，现从事于图形学C++相关的开发工作。 另外 在图像渲染领域还是个菜鸟🤪，希望遇到志同道合的朋友多多交流，互相进步！ PS: 欢迎评论👨‍👩‍👧‍👦，并且主页头像下方的 Email📧 与 Github👩‍💻 可戳-_~ ","date":"2021-12-25","objectID":"/about/:0:0","tags":null,"title":"关于我","uri":"/about/"},{"categories":["计算机图形学"],"content":"摘要：Metal官方文档MetalGuide系列第二部分 -\u003e Metal资源与对象，即纹理Texture和Buffer","date":"2021-12-25","objectID":"/2021/12/3_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/","tags":["Metal","图形渲染"],"title":"MetalGuide(2)资源与对象","uri":"/2021/12/3_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/"},{"categories":["计算机图形学"],"content":"0.资源对象 资源对象，主要包含为缓存Buffers和纹理Textures。 ​ MTLBuffer它表示一块非格式化的内存可以存放任何类型的数据。它通常用于存放顶点数据、着色程序和计算状态数据。 ​ MTLTexture，它表示一块有格式的图像数据，有特定的纹理类型和像素格式。它通常被用作顶点着色程序、片元着色程序、或是并行计算函数的纹理源，它也可以存放图形渲染的结果输出。通常MTLTexture结构为这几种：1维、2维、或3维的图像，或是1维、2维的图像数组，或是拥有6个2维图像的立方体。 ​ MTLSamplerState，虽然采样器不是资源，但它总是用于纹理对象的查找计算。 1. 有关Buffer对象 ","date":"2021-12-25","objectID":"/2021/12/3_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/:0:0","tags":["Metal","图形渲染"],"title":"MetalGuide(2)资源与对象","uri":"/2021/12/3_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/"},{"categories":["计算机图形学"],"content":"1.1 创建Buffer对象 ​ 一个MTLBuffer对象表示了一个可以装载任何类型数据的内存片段。 ​ 下面的MTLDevice方法可以用于创建并返回类型MTLBuffer对象: ","date":"2021-12-25","objectID":"/2021/12/3_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/:1:0","tags":["Metal","图形渲染"],"title":"MetalGuide(2)资源与对象","uri":"/2021/12/3_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/"},{"categories":["计算机图形学"],"content":"1.2 Buffer的对象方法 ​ Buffer缓存对象有2种方法： contents: 返回缓存对象对应内存的CPU地址; newTextureWithDescriptor:offset:bytesPerRow: 创建某种特定类型的纹理。 2.Texture对象 ","date":"2021-12-25","objectID":"/2021/12/3_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/:2:0","tags":["Metal","图形渲染"],"title":"MetalGuide(2)资源与对象","uri":"/2021/12/3_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/"},{"categories":["计算机图形学"],"content":"2.1 创建Texture对象 ​ 下列的方法用于创建并返回一个MTLTexture对象： newTextureWithDescriptor ：新分配内存并创建一个MTLTexture对象，创建时需要传入的MTLTextureDescriptor参数描述了纹理的属性； ⚠️它隶属于MTLDevice方法； newTextureViewWithPixelFormat ： 该方法创建出来的 MTLTexture新对象和调用源对象共享存储，并重新解释了源纹理对象对应内存的图像格式；调用入参的MTLPixelFormat参数类型必须兼容源纹理对象的图像格式；⚠️它隶属于MTLTexture方法; newTextureWithDescriptor:offset:bytesPerRow ：创建一个MTLTexture对 象，共享调用源对象的内存，作为它自己的图像数据；⚠️它隶属于MTLBuffer方法。 ","date":"2021-12-25","objectID":"/2021/12/3_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/:3:0","tags":["Metal","图形渲染"],"title":"MetalGuide(2)资源与对象","uri":"/2021/12/3_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/"},{"categories":["计算机图形学"],"content":"2.2 纹理描述符 ​ MTLTextureDescriptor(纹理描述符)描述用于创建一个MTLTexture对象的各属性。包括图形尺寸(宽，高，深)，像素格式，组合模式(数组或是立方体)还有mipmaps的数量。 这些属性都只用在MTLTexture对象的创建过程中。当纹理对象创建完毕，descritor中的值后续再改变也不会影响纹理之前由它创建的对象。指定纹理的维度与组合模式(数组或立方) ​ Texture Descriptor内容组成以及含义如下图： ","date":"2021-12-25","objectID":"/2021/12/3_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/:4:0","tags":["Metal","图形渲染"],"title":"MetalGuide(2)资源与对象","uri":"/2021/12/3_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/"},{"categories":["计算机图形学"],"content":"2.3 创建纹理描述符 ​ 对一个2D纹理或是立方纹理来说，下面的快捷方法可以创建MTLTextureDescriptor对象并且自动设置多个值： texture2DDescriptorWithPixelFormat:width:height:mipmapped: 创建一个描述2D纹理的MTLTextureDescriptor对象，入参width和height定义2D纹理的尺寸， descriptor的type属性自动设置为MTLTextureType2D，属性depth和属性arrayLength自动设置为1； textureCubeDescriptorWithPixelFormat:size:mipmapped: 创建一个描述立方纹理的MTLTextureDescriptor对象, 入参size被设置给width和height， type属性自动设置为MTLTextureTypeCube，属性depth和属性arrayLength自动设置为1 。 上面两个快捷方法都接受一个入参pixelFormat，它定义了纹理的像素格式。这两个方法都接受一个入参mipmapped(值为YES/NO)，它指定纹理是否支持mipmap ； ","date":"2021-12-25","objectID":"/2021/12/3_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/:5:0","tags":["Metal","图形渲染"],"title":"MetalGuide(2)资源与对象","uri":"/2021/12/3_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/"},{"categories":["计算机图形学"],"content":"2.4 纹理分片(slice) ​ 纹理分片是一个单独纹理数据(可能是1维、 2维或是3维)以及所有和它关联的mipmap。 具有以下特点： 其基层的mipmap尺寸由MTLTextureDescriptor对象的width , height , depth属性设定； mipmap的第 i 层的尺寸是基层的1/2i ; 立方cube(6个2维分片)和数组array(每个数组元素对应1个分片)类型的纹理可以有多个分片；一个单独纹理数据(可能是1维、 2维或是3维)只能有1个分片； ","date":"2021-12-25","objectID":"/2021/12/3_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/:6:0","tags":["Metal","图形渲染"],"title":"MetalGuide(2)资源与对象","uri":"/2021/12/3_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/"},{"categories":["计算机图形学"],"content":"2.5 Copy图像数据进出纹理对象 ​ 以同步阻塞式拷贝图像数据进出纹理对象的内存，可以使用如下方法： replaceRegion:mipmapLevel:slice:withBytes:bytesPerRow:bytesPerImage: 从withBytes参数表示的资源对象中拷贝指定区域的像素数据到一个指定的纹理切片的指定内存区域； replaceRegion:mipmapLevel:withBytes:bytesPerRow: 和前一个方法类似，只是slice和bytesPerImage设置为0; getBytes:bytesPerRow:bytesPerImage:fromRegion:mipmapLevel:slice: 获取指定切片的指定区域的像素数据 ; getBytes:bytesPerRow:fromRegion:mipmapLevel: 和前一个方法类似，只是slice和bytesPerImage设置为0; ","date":"2021-12-25","objectID":"/2021/12/3_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/:7:0","tags":["Metal","图形渲染"],"title":"MetalGuide(2)资源与对象","uri":"/2021/12/3_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/"},{"categories":["计算机图形学"],"content":"2.6 纹理MTLTexture像素格式 ​ MTLTexture对象的MTLPixelFormat属性指定颜色、深度或是模板缓存数据中每一个像素如何组织。有3种像素格式：原生格式(ordinary),紧密填充格式(packed)和**压缩格式(**compressed): 原生格式 ：只有8、16或是32位颜色值，每个分量以升序内存地址排列，第一个分量处于最低的内存地址处 ；例如MTLPixelFormatRGBA8Unorm是一个32位格式颜色值 ，RGBA都各自占8bit; 紧密填充格式 ：把多个颜色分量结合起来从最低位LSB到最高位MSB存放在一个16位或是32位的值中 ；例如 MTLPixelFormatRGB10A2Uint是一个32位的填充格式色值,RGB都各自占8bit, A占2bit； 压缩格式 ：用于排列像素块的，每个块的布局被设定为这种像素格式；只能被用于2D、 2D数组或是立方类型的纹理; 其他格式：MTLPixelFormatGBGR422和MTLPixelFormatBGRG422是两种特殊的像素格式，用于存储YUV颜色空间的像素数据，只支持不含mipmap且width为偶数的2D类型的纹理。 还有几种支持sRGB颜色空间的格式，比如MTLPixelFormatRGBA8Unorm_sRGB和 MTLPixelFormatETC2_RGB8_sRGB ，sRGB颜色空间和线性颜色空间可以相互转换。 ","date":"2021-12-25","objectID":"/2021/12/3_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/:8:0","tags":["Metal","图形渲染"],"title":"MetalGuide(2)资源与对象","uri":"/2021/12/3_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/"},{"categories":["计算机图形学"],"content":"2.7 采样器状态(Sampler States)与纹理 ​ MTLSamplerState对象(采样器状态)包含了用于纹理查找 的属性。 ​ MTLSamplerState定义了寻址、过滤还有其他属性，用于一个图形着⾊色程序或是并行计算着色程序对一个MTLTexture对象实施采样操作。创建一个采样器state对象的步骤如下图： ​ ⚠️注意：descriptor的属性值仅在创建MTLSamplerState对象时生效，state对象创建完成后，改变descriptor的属性值不会影响已经创建的state对象。 3. CPU/GPU内存一致性 ​ CPU和GPU都可以访问同一个MTLResource类型的对象管理的存储数据。但是GPU和CPU的操作是异步进行的，为保持一致性，注意该事项： ​ 当MTLDevice对象执行一个MTLCommandBuffer对象时，它只有在command buffer被提交之前才能观察到由CPU引起的Command-Buffer内存变化，一旦被提交即状态为MTLCommandBufferStatusCommitted ，MTLDevice对象就观察不到这些资源的变化情况了。 参考链接: Apple-Metal-Programming-Guide Metal’s Best Practice ","date":"2021-12-25","objectID":"/2021/12/3_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/:9:0","tags":["Metal","图形渲染"],"title":"MetalGuide(2)资源与对象","uri":"/2021/12/3_metalguide-2-%E8%B5%84%E6%BA%90%E4%B8%8E%E5%AF%B9%E8%B1%A1/"},{"categories":["折腾"],"content":"摘要：基于Hugo框架和Github-Page搭建个人博客","date":"2021-12-19","objectID":"/2021/12/5_%E5%9F%BA%E4%BA%8Ehugo%E5%92%8Cgithub-page%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","tags":["Hugo","Github Page"],"title":"利用Hugo和Github-Pages搭建免费的个人博客","uri":"/2021/12/5_%E5%9F%BA%E4%BA%8Ehugo%E5%92%8Cgithub-page%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["折腾"],"content":"0.为什么选Hugo+Github-Page 说起博客，除了用个人vps+wordPress这种麻烦但diy程度高的方式，比较流行的应该就是CSDN，博客园和简书，以及GithubPage(同类还有GiteePage)。因为可以对自己博客的完全掌控性，以及管理便利性，大多数博主各方面权衡后，选择了GitHubPage搭建静态网页的形式，与之配合的静态博客框架有jekyll、hexo和hugo。 有博主对3种框架进行过简单的测试对比，编译速度应该是Hugo\u003eHexo\u003eJekyll。 Jekyll由Ruby开发，是Github Page默认原生支持的框架，本人了解不多。 Hexo由Node.js开发，应该是使用人数最多的，主题齐全美观，功能稳定，部署和配置比Hugo稍微麻烦些。 而Hugo，由GO语言开发，号称是最快的静态网站部署框架(200篇博文编译大概1秒)，现在也有不少人从Hexo迁移到Hugo，所以还是选Hugo吧。 简述过程： Github Page，可以用来免费部署静态网站，使用效果也很直接，创建一个代码仓库，然后将上述的静态网站框架包含的文件拖进去，选择主题配置好，然后本地编译后得到静态网页内容，一起Push到远端仓库，Github Page会帮你部署好网站，假设usernamexxx是你的Github账号，那么进入域名https://usernamexxx.github.io 就可以打开你的博客了(当然这个域名可以后续自己折腾换成其他，这是后话了)。 1.准备工作 拥有一个Github账号，参考腾讯云：一步一步教你注册GitHub账号及简单使用. (邮箱建议不要用qq邮箱，虽然用了后面也有办法换，但在后续CDN加速的时候qq邮箱可能有问题) 电脑安装Git，下载安装地址：安装 Git. 电脑安装Hugo 最简单的办法，就是直接下载二进制免安装包，安装包下载地址Hugo-Release,选择最新的安装包，解压到本地某目录，并添加一下环境变量PATH即可。 如果坚持用命令行: 如果是mac系统，相信你已经有了brew程序，直接执行brew install hugo即可完成安装。 如果是Windows系统想要命令行安装，则管理员身份证运行终端，执行: # 如果有chocolatey，就直接执行 choco install hugo -confirm # 如果没有chocolatey，就先安装一下 powershell -NoProfile -ExecutionPolicy unrestricted -Command \"iex ((new-object net.webclient).DownloadString('https://chocolatey.org/install.ps1'))\" # 设置环境变量 SET PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin 安装成功后，命令行执行 hugo version 检查hugo版本，能正确打印版本信息即表示正常安装。 2.开通Github-Page 不太熟悉Github的朋友，官方写了很好的Quick Start，图文并茂的，直接贴链接吧，Github Page:Websites for you and your projects. 熟悉Github的朋友，直接新建一个public的仓库，如果用户名为usernamexxx仓库名为usernamexxx.github.io。 成功之后，请立即克隆到本地，并测试第一个网页，比克隆到D盘路径\"/d/Files\",执行如下命令： #假设用户名是usernamexxx cd /d/Files git clone https://github.com/usernamexxx/usernamexxx.github.io.git cd usernamexxx.github.io #测试第一个网页 echo \"Hello World\" \u003e index.html git add --all git commit -m \"Initial commit\" git push -u origin main 注意⚠ 上述Git-Push时可能会遇到填写账号密码的问题，密码注意是需要填写Access Token，可以直接访问Github-Developer-Setting,生成一个token，当作本次密码填入(Github从2021年8月份开始就需要这样通过https推代码了))。 Git简单设置避免后续麻烦： #windows平台需要执行这个，避免行尾\\r\\n,CRLF的提示，挺烦的 git config --global core.autocrlf false #终端环境保存https的token密码，避免每次都输入密码 git config --global credential.helper store 虽然这个免费的服务有一些限制：项目大小最大为1GB，每月带宽使用不超过100GB，每小时最多构建10个版本。对于个人博客网站，是绰绰有余了，所以不用担心。 3.新建hugo site站点 对于Windows系统，以下命令行都建议在Git-Bash中运行。 如上一节所述，我们的仓库在路径\"/d/Files/usernamexxx.github.io\". #cd到git仓库的目录 cd /d/Files/usernamexxx.github.io #确认关联到了远端仓库https://github.com/usernamexxx/usernamexxx.github.io.git git branch -v # 新建hugo站点,起个英文site名，比如MyHugoBlog hugo new site MyHugoBlog ##文件夹下会生成如下 # MyHugoBlog # ├─archetypes # ├─content (markdown内容存放处,一般是content/post/hello.md) # ├─data # ├─layouts # ├─static (站点静态资源存放处,比如image,js,css) # ├─themes # └─config.toml (站点最重要的配置文件) #cd到站点目录的原因：所有hugo命令都要在hugo根目录下执行 cd MyHugoBlog 4.设置主题 Hugo支持非常多简洁又美观的主题，可以在Hugo中文站的主题列表里或者Hugo官方站的主题列表挑选，看个人喜好了。这里可以不用太纠结，可以先随便选一个，让站点运行起来先，可以很方便就换掉的(配置文件里的theme选项)。 举例，看中了Even主题,Github地址为：https://github.com/olOwOlo/hugo-theme-even ，不要直接下载或直接clone，考虑到后续可能想有自定义修改，去Github界面fork到你自己仓库，然后再添加为子模块： cd /d/Files/usernamexxx.github.io git submodule add https://github.com/usernamexxx/hugo-theme-even MyHugoBlog/theme/even 5.创建hugo新文章 hugo的新文章在content/post目录，或者content/posts目录，看个人习惯而定，试用了几个主题，不同主题默认位置可能是二者其一。例如，执行下述hugo命令： cd /d/Files/usernamexxx.github.io/MyHugoBlog #会新建文件content/post/MyFirst.md hugo new post/MyFirst.md 新生成的markdown文档默认如下(三个短横---之间是配置选项，正文内容从短横之后开始)，可以手动添加一下正文内容 ： --- title: \"First\" date: 2022-01-03T15:19:14+08:00 draft: true --- # 正文内容在这里 - Hello world,first post! 其中draft的含义是草稿的意思，在正式发布的时候不会被包含和编译，那时要改为false。 所有文章的通用设置在根目录的config.toml进行配置，需要关注的有如下选项，更多选项请参考hugo-configuration baseURL = 'https://usernamexxx.github.io' languageCode = 'zh-cn' title = \"my blog\" theme = \"even\" publishDir=\"../docs\" 上述publishDir也可以不配置，默认是根目录下的public目录，意思是后续编译出的静态网页文件存放的目录，不和hugo的内容文件混在一起的话，方便后续查看Git-Log以及其他部署工作。 至此，Hugo新站点的骨架都搭建完了，可以本地调试看看效果了，在命令行运行： cd /d/Files/usernamexxx.github.io/MyHugoBlog hugo server -w 终端提示\"Web Server is available at http://localhost:1313/ (bind address 127.0.0.1)\"，访问localHost本地URL： http://localhost:1313 ，即可看到上述添加的MyFirst.md里的内容，并且保持终端site运行的情况下，手动修改markdown内容，保存一下","date":"2021-12-19","objectID":"/2021/12/5_%E5%9F%BA%E4%BA%8Ehugo%E5%92%8Cgithub-page%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:0:0","tags":["Hugo","Github Page"],"title":"利用Hugo和Github-Pages搭建免费的个人博客","uri":"/2021/12/5_%E5%9F%BA%E4%BA%8Ehugo%E5%92%8Cgithub-page%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["脚本"],"content":"摘要：10个简单好用的Linux命令","date":"2021-12-18","objectID":"/2021/12/1_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/","tags":["shell脚本","linux"],"title":"10个容易遗忘但好用的Linux命令","uri":"/2021/12/1_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["脚本"],"content":"1) pgrep ​ pgrep名字前有个p，我们可以猜到这是进程相关的grep命令。不过，这个命令主要是用来列举进程ID的。 $ pgrep -u username_xx ​ 这个命令相当于： ##效果待定,awk命令不熟悉(逃 ps -ef | egrep '^username_xx' | awk '{print $2}' ","date":"2021-12-18","objectID":"/2021/12/1_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/:0:1","tags":["shell脚本","linux"],"title":"10个容易遗忘但好用的Linux命令","uri":"/2021/12/1_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["脚本"],"content":"2）pstree ​ 这个命令可以用树形的方式列出进程。 ","date":"2021-12-18","objectID":"/2021/12/1_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/:0:2","tags":["shell脚本","linux"],"title":"10个容易遗忘但好用的Linux命令","uri":"/2021/12/1_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["脚本"],"content":"3）bc ​ 这个命令主要是做一个精度比较高的数学运算的。比如开平方根等。下面是一个我们利用bc命令写的一个脚本（文件名：square.sh） #!/bin/bash if [ $# == 0 ] then echo 'Usage: sqrt number' exit 1 else echo -e \"sqrt($1)\\nquit\\n\" | bc -q -i fi #运行方式：./squar.sh 或者 ./square.sh 10.00 ","date":"2021-12-18","objectID":"/2021/12/1_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/:0:3","tags":["shell脚本","linux"],"title":"10个容易遗忘但好用的Linux命令","uri":"/2021/12/1_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["脚本"],"content":"4）split ​ 把一个很大的文件分割成一些小的文件，注意，split执行后源文件仍然在的。 #例如把上文的square.sh分割成多个文件,先查看大小，发现是124字节 ls -al #sqx_为前缀，会得到3个文件:sqx_aa,sqx_ab,sqx_ac split -b 50 square.sh sqx_ #把文件重新合并，使用cat命令即可 cat sqx_* \u003e square.sh.new ","date":"2021-12-18","objectID":"/2021/12/1_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/:0:4","tags":["shell脚本","linux"],"title":"10个容易遗忘但好用的Linux命令","uri":"/2021/12/1_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["脚本"],"content":"5）nl ​ nl命令其它和cat命令很像，只不过它会打上行号。 #不加后续的head命令也可以 liwenyao@ubuntu:~$ nl square.sh | head -n 5 1 #!/bin/bash 2 if [ $# == 0 ] 3 then echo 'Usage: sqrt number' 4 exit 1 5 else ","date":"2021-12-18","objectID":"/2021/12/1_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/:0:5","tags":["shell脚本","linux"],"title":"10个容易遗忘但好用的Linux命令","uri":"/2021/12/1_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["脚本"],"content":"6）mkfifo ​ mkfifo的作用是创建一个有名管道，平时使用的较多的是无名管道，例如“ls | grep txt”. ​ 有名管道创建后可以像文件一样存在文件夹中，像是一个缓存区。 ​ 使用举例如下： #在终端窗口1执行如下命令，ls没有输出内容 mkfifo pipex ls \u003e pipex #打开终端窗口2执行如下命，会看到 ls 命令输出的内容 cat \u003c pipex 拓展：常用的管道命令有==\u003e cut、grep、sort、wc、uniq tee：重定向，既能在屏幕输出，又能保存到文件中 tr、col、join、paste、expand、split ","date":"2021-12-18","objectID":"/2021/12/1_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/:0:6","tags":["shell脚本","linux"],"title":"10个容易遗忘但好用的Linux命令","uri":"/2021/12/1_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["脚本"],"content":"7）ldd ​ 这个命令可以知道你的一个可执行文件所使用了动态链接库 ###假设有个文件calc.so,命令后接文件名即可，具体参数选项可参照命令help内容 ldd calc.so ","date":"2021-12-18","objectID":"/2021/12/1_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/:0:7","tags":["shell脚本","linux"],"title":"10个容易遗忘但好用的Linux命令","uri":"/2021/12/1_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["脚本"],"content":"8）col ​ Linux col命令用于过滤控制字符。 ​ 在许多UNIX说明文件里，都有RLF控制字符。当我们运用shell特殊字符\"\u003e“和”»\"，把说明文件的内容输出成纯文本文件时，控制字符会变成乱码，col指令则能有效滤除这些控制字符。 ​ 下面以 man 命令帮助文档为例，讲解col 命令的使用。 ​ 将man 命令的帮助文档保存为man_help，使用-b 参数过滤所有控制字符。在终端中使用如下命令： #man命令用法，man + linux命令 man man | col -b \u003e man_help ","date":"2021-12-18","objectID":"/2021/12/1_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/:0:8","tags":["shell脚本","linux"],"title":"10个容易遗忘但好用的Linux命令","uri":"/2021/12/1_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["脚本"],"content":"9）xmlwf ​ 这个命令可以让你检查一下一个XML文档是否是所有的tag都是正常的。 ","date":"2021-12-18","objectID":"/2021/12/1_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/:0:9","tags":["shell脚本","linux"],"title":"10个容易遗忘但好用的Linux命令","uri":"/2021/12/1_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["脚本"],"content":"10）lsof ​ 这个命令可以列出打开了的文件。 [root@RHELSVR5 ~]# lsof | grep TCP httpd 548 apache 4u IPv6 14300967 TCP *:http (LISTEN) httpd 548 apache 6u IPv6 14300972 TCP *:https (LISTEN) httpd 561 apache 4u IPv6 14300967 TCP *:http (LISTEN) httpd 561 apache 6u IPv6 14300972 TCP *:https (LISTEN) ","date":"2021-12-18","objectID":"/2021/12/1_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/:0:10","tags":["shell脚本","linux"],"title":"10个容易遗忘但好用的Linux命令","uri":"/2021/12/1_10%E4%B8%AAlinux%E5%AE%B9%E6%98%93%E9%81%97%E5%BF%98%E4%BD%86%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"categories":["计算机图形学"],"content":"摘要：Metal官方文档MetalGuide系列第一部分 -\u003e 基本的指令和执行模型","date":"2021-12-18","objectID":"/2021/12/2_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/","tags":["Metal","图形渲染"],"title":"MetalGuide(1)指令组织和执行模型","uri":"/2021/12/2_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/"},{"categories":["计算机图形学"],"content":"1. 基本概念认知 ​ Metal 是一个和 OpenGL ES 类似的面向底层的图形编程接口，通过使用相关的API 可以直接操作 GPU。不过不同的是，Metal不具有跨平台特性，只针对苹果的平台系统使用，并且编程开发语言为Objective - C或Swift。 ​ Metal框架支持GPU加速的3D图形渲染和并⾏数据计算，它提供了一系列的API用于在细粒度和低层次上组织、处理、提交图形渲染指令、并⾏计算指令，并管理和这些指令相关联的数据和资源。使用Metal的一个主要⽬标是减少GPU执⾏这些计算的开销。 2. 指令组织和执行模型 ​ 一个command queue包含了一系列command buffers。command queue用于组织它拥有的各个command buffer按序执行。一个command buffers包含多个被编码的指令，这些指令将在一个特定的设备上执⾏。一个Encoder可以将绘制、计算、位图传输指令推入一个command buffer，最后这些command buffer将被提交到设备执⾏。 ​ 任一时刻，只会有一个Encoder是处于激活状态的，它可以向一个command buffer提交指令。前一个Encoder结束后，另一个Encoder才可以被创建并用于同一个command buffer。 ​ 最终，他们的逻辑模型类似于下图： ","date":"2021-12-18","objectID":"/2021/12/2_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/:0:0","tags":["Metal","图形渲染"],"title":"MetalGuide(1)指令组织和执行模型","uri":"/2021/12/2_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/"},{"categories":["计算机图形学"],"content":"2.1 何为设备 ​ 一个MTLDevice对象代表一个可以执行指令的GPU，该协议包含创建新的command queue的方法、从内存申请缓存的方法、创建纹理对象的方法以及查询设备功能的方法。调用MTLCreateSystemDefaultDevice方法获取系统首选的设备对象。 ","date":"2021-12-18","objectID":"/2021/12/2_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/:1:0","tags":["Metal","图形渲染"],"title":"MetalGuide(1)指令组织和执行模型","uri":"/2021/12/2_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/"},{"categories":["计算机图形学"],"content":"2.2 暂态/非暂态(Non-Transient)对象 ​ 故名思义，两者是按照对象的生命周期来区分的。 在Metal中有些对象被设计成暂态，使用它们⾮常轻量。另外一些则要昂贵许多，因此它们应该拥有长的生命周期。 非暂态对象特点： 暂态对象特点： ","date":"2021-12-18","objectID":"/2021/12/2_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/:2:0","tags":["Metal","图形渲染"],"title":"MetalGuide(1)指令组织和执行模型","uri":"/2021/12/2_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/"},{"categories":["计算机图形学"],"content":"2.3 指令队列(Command Queue) ​ 一个command queue管理着一个在GPU上即将执⾏的command buffer有序队列。同一个队列的所有command buffer都会被按照入队的次序执⾏。通常，command queue是线程安全的，允许多个command buffer 同时编码。 ​ 如何创建Command Queue，以下的2个方法都是可行的: newCommandQueue newCommandQueueWithMaxCommandBufferCount ⚠️：Command Queue是非暂态对象，是具有长生命周期的，不要反复地创建和销毁这种对象。 ","date":"2021-12-18","objectID":"/2021/12/2_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/:3:0","tags":["Metal","图形渲染"],"title":"MetalGuide(1)指令组织和执行模型","uri":"/2021/12/2_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/"},{"categories":["计算机图形学"],"content":"2.4 指令缓存(Command Buffer) ","date":"2021-12-18","objectID":"/2021/12/2_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/:4:0","tags":["Metal","图形渲染"],"title":"MetalGuide(1)指令组织和执行模型","uri":"/2021/12/2_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/"},{"categories":["计算机图形学"],"content":"2.4.1 Command Buffer的特点 ​ 一个command buffer在被GPU执行之前会存储多个被编码的指令。一个command buffer可以包含多种类型的编码。 ​ Command Buffer具有以下特点： 一帧渲染即使含有多个RenderPass或多个计算处理程序、多个位图操作，都可以被编码到同一个Command Buffer中； 它是暂态对象，不支持重用；一旦被提交等待执行，即进入队列； 它还代表了app中独立的可被追踪的任务单元。 ","date":"2021-12-18","objectID":"/2021/12/2_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/:4:1","tags":["Metal","图形渲染"],"title":"MetalGuide(1)指令组织和执行模型","uri":"/2021/12/2_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/"},{"categories":["计算机图形学"],"content":"2.4.2 创建Command Buffer ​ 如何创建Command Buffer对象，以下的2个方法都是可行的: commandBuffer：数据是强引用的，一个MTLCommandBuffer对象只能提交给创建它的那个command queue。 commandBufferWithUnretainedReferences：数据不是强引用的，在可以保证和command buffer相关数据在其被执⾏时都有引用计数的情况下，又极端需要提升性能，才会使用该方法。使用时需要格外注意引用计数。 ","date":"2021-12-18","objectID":"/2021/12/2_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/:4:2","tags":["Metal","图形渲染"],"title":"MetalGuide(1)指令组织和执行模型","uri":"/2021/12/2_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/"},{"categories":["计算机图形学"],"content":"2.4.3 执行指令 ​ MTLCommandBuffer协议使用如下的方法来设定其在指令队列中的执⾏顺序： enqueue：为一个command buffer在command queue中预定一个位置，但是不会提交这个command buffer。当这个command buffer最终被提交时，指令队列把它安排在对应的enqueue顺序队列中执行。 commit：使得command buffer尽可能快地被执⾏，但还是得等到所有在command queue中的早前排入队列的 其他command buffer被执行完成后才能执⾏。如果commad queue中没有排在前面的command buffer，该方法隐式执⾏enqueue操作。 ","date":"2021-12-18","objectID":"/2021/12/2_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/:4:3","tags":["Metal","图形渲染"],"title":"MetalGuide(1)指令组织和执行模型","uri":"/2021/12/2_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/"},{"categories":["计算机图形学"],"content":"2.4.4 注册处理程序块(Register Handler Blocks) ​ 下列的MTLCommandBuffer的方法可以监视指令的执⾏。使用了这些方法注册处理程序块，那么在某个线程中，这些处理程序块会按照执⾏顺序被调用。这些处理程序块应该是迅速可被执⾏完成的，如果有开销⼤的造成阻塞的任务，那么应该将它们安排到其他线程执⾏行。 addScheduledHandler : 注册的处理程序块将在command buffer被“排定好”(scheduled)时调用。“排定好”一般是指，MTLCommandBuffer对象或系统API提交的所有任务之间的依赖关系都能被满⾜。 waitUntilScheduled : 调用后就开始等待，return时机为所有command buffer被“排定好”而且addScheduledHandler方法注册的处理程序块都执行完毕。 addCompletedHandler : 注册的处理程序块将在command buffer被执⾏完毕后立即调用；一个command buffer对象可以注册多个这样的处理程序块。 waitUntilCompleted : 调用后就开始等待，return时机为所有command buffer都执行完而且addCompletedHandler注册的处理程序块都执行完毕。 presentDrawable : 较为便捷，它用于当command buffer处于“排定好”时呈现一个可显示资源 (CAMetalDrawable类型对象)的内容。 执行完毕后，需要关注以下2种Command Buffer的属性： status: 只读属性，包含了一个MTLCommandBufferStatus类型的枚举值，它反映了command buffer在其生命周期中处于哪个阶段。 error：如果command buffer成功执⾏，值为nil。如果有异常发生，值为“Command Buffer Error Codes”类型。且status属性被设 置为MTLCommandBufferStatusError。 ","date":"2021-12-18","objectID":"/2021/12/2_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/:4:4","tags":["Metal","图形渲染"],"title":"MetalGuide(1)指令组织和执行模型","uri":"/2021/12/2_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/"},{"categories":["计算机图形学"],"content":"2.5 指令编码(Command Encoder) ","date":"2021-12-18","objectID":"/2021/12/2_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/:5:0","tags":["Metal","图形渲染"],"title":"MetalGuide(1)指令组织和执行模型","uri":"/2021/12/2_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/"},{"categories":["计算机图形学"],"content":"2.5.1 Command Encoder的特点 ​ Command Encoder用来编码渲染和计算指令，然后被推入到一个command buffer并最终在GPU上执行。它具有以下特点： 它有多个对象方法可以往Command Buffer里追加指令； 当一个Encoder是激活状态时，就可以调用endEncoding方法向它所属的command buffer推送指令； 推送完成后要写入更多的指令，就创建一个新的 Encoder。 ","date":"2021-12-18","objectID":"/2021/12/2_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/:5:1","tags":["Metal","图形渲染"],"title":"MetalGuide(1)指令组织和执行模型","uri":"/2021/12/2_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/"},{"categories":["计算机图形学"],"content":"2.5.2 创建Command Encoder ​ MTLCommandBuffer协议中的若干方法都可以创建Command Encoder对象，这些对象可以向对应的command buffer推送指令。具体地，以下的4个方法都是可行的: renderCommandEncoderWithDescriptor ：创建一个MTLRenderCommandEncoder类型的Encoder实现图形渲染，图形绘制用到的attachment附件由那个MTLRenderPassDescriptor类型的入参对象指定； computeCommandEncoder ：创建一个MTLComputeCommandEncoder类型的Encoder来实现并行数据计算； blitCommandEncoder ：创建一个MTLBlitCommandEncoder类型的Encoder来实现内存操作； parallelRenderCommandEncoderWithDescriptor ：创建一个MTLParallelRenderCommandEncoder类型的Encoder，它用于支持多个MTLRenderCommandEncoder类型的⼦Encoder同时在不同的线程中运⾏，依然把所有绘制结果写入同一个attachment中，该attachment由MTLRenderPassDescriptor类型的入参指定。 ","date":"2021-12-18","objectID":"/2021/12/2_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/:5:2","tags":["Metal","图形渲染"],"title":"MetalGuide(1)指令组织和执行模型","uri":"/2021/12/2_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/"},{"categories":["计算机图形学"],"content":"2.5.3 多种用途的Command Encoder ​ a. 用于渲染的Command Encoder ​ 图形渲染可以被描述为一系列的Render Pass，一个MTLRenderCommandEncoder对象表示和一个Render Pass相关联的渲染状态和渲染命令。这个Encoder对象需要一个相关联的MTLRenderPassDescriptor对象，在这个descriptor对象中包含颜⾊、深度、模板等依赖信息。 ​ MTLRenderCommandEncoder拥有各类方法可以完成以下事项： ​ 设定图形资源，比如缓存和纹理对象，这些对象包含着顶点⽚元和纹理数据； ​ 设定固定图形渲染管线状态，包括视口，三角形填充模式，裁剪矩形，深度测试和模板测试等等。 ​ b. 用于并行计算的Command Encoder ​ 使用MTLCommandBuffer的computeCommandEncoder方法可以创建一个并行计算用的Command Encoder。 ​ 对于并⾏数据计算，MTLComputeCommandEncoder协议提供了方法来编码计算指令，以此设定计算程序和参数，调度计算程序执⾏。 ​ c. 用于位图操作的Command Encoder ​ 使用MTLCommandBuffer协议的blitCommandEncoder方法可以创建一个MTLBlitCommandEncoder。 ​ MTLBlitCommandEncoder协议提供了方法用来在缓存(MTLBuffer) 和纹理(MTLTexture)之间进⾏拷贝。 ​ 该协议还提供了用一种颜⾊填充纹理的方法，以及创建mipmap的方法。 ​ ","date":"2021-12-18","objectID":"/2021/12/2_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/:5:3","tags":["Metal","图形渲染"],"title":"MetalGuide(1)指令组织和执行模型","uri":"/2021/12/2_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/"},{"categories":["计算机图形学"],"content":"2.6 多线程与Command Buffer/Command Encoder ​ 很多的应用程序只是用一个线程来编码绘制指令到一个command buffer来绘制一帧画面。在每帧绘制的末尾， 提交commad buffer，如此可以排定和开始指令的执行。 ​ 如果希望并行地让command buffer执⾏指令编码，那么可以同时创建多个command buffer，使用多个线程，每个线程单独为一个command buffer编码指令。 ​ 如果事先知道command buffer应该以什么顺序执⾏，那么 MTLCommandBuffer的enqueue方法可以在command queue中声明执⾏行顺序，⽽不必等待执⾏编码和提交操作。否则只能等到command buffer被提交，这时在command queue中它就被指定了一个位置，顺序位于之前提交的 command buffer后面。 ​ 任一时刻只有一个GPU线程在访问command buffer，多线程的应用可以为每个command buffer准备一个线程，如此实现并⾏创建多个command buffer。 ​ 下图示例了一个3线程应用，每个线程都操作一个command buffer，每个线程中，任一时刻只有一个Encoder在访问它对应的command buffer。当你完成了编码，调用Encoder的endEncoding方法，然后一个新的Encoder才可以为command buffer编码指令。 参考链接: Apple-Metal-Programming-Guide Metal’s Best Practice ","date":"2021-12-18","objectID":"/2021/12/2_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/:6:0","tags":["Metal","图形渲染"],"title":"MetalGuide(1)指令组织和执行模型","uri":"/2021/12/2_metalguide-1-%E6%8C%87%E4%BB%A4%E7%BB%84%E7%BB%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/"}]